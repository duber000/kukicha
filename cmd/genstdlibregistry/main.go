// genstdlibregistry generates internal/semantic/stdlib_registry_gen.go by
// scanning all stdlib/*.kuki source files and extracting exported function
// return counts. Run via "make genstdlibregistry" or "go run ./cmd/genstdlibregistry".
//
// This implements the "Automatic Inference" improvement described in COMPILER-FIX.md:
// instead of maintaining a hand-written registry in semantic.go, the registry is
// derived directly from the .kuki source files so it stays in sync automatically.
package main

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/duber000/kukicha/internal/ast"
	"github.com/duber000/kukicha/internal/parser"
)

func main() {
	// Expect to be run from the repo root (where stdlib/ lives).
	matches, err := filepath.Glob("stdlib/*/*.kuki")
	if err != nil {
		fmt.Fprintf(os.Stderr, "glob error: %v\n", err)
		os.Exit(1)
	}

	// pkgName -> funcName -> returnCount
	// We track by pkgName so duplicate function names in different packages
	// are handled correctly. If the same qualified name appears twice (shouldn't
	// happen in valid Kukicha), we keep the larger return count.
	registry := map[string]int{}

	for _, path := range matches {
		base := filepath.Base(path)
		if strings.HasSuffix(base, "_test.kuki") {
			continue
		}

		src, err := os.ReadFile(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "read %s: %v\n", path, err)
			continue
		}

		p, err := parser.New(string(src), path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "lex %s: %v\n", path, err)
			continue
		}

		prog, parseErrs := p.Parse()
		if len(parseErrs) > 0 {
			for _, e := range parseErrs {
				fmt.Fprintf(os.Stderr, "parse warning %s: %v\n", path, e)
			}
		}
		if prog == nil || prog.PetioleDecl == nil {
			continue
		}

		pkgName := prog.PetioleDecl.Name.Value

		for _, decl := range prog.Declarations {
			fd, ok := decl.(*ast.FunctionDecl)
			if !ok {
				continue
			}

			// Skip unexported functions (start with lowercase).
			name := fd.Name.Value
			if len(name) == 0 || name[0] < 'A' || name[0] > 'Z' {
				continue
			}

			// Skip methods — they have a receiver and are called as value.Method(),
			// not as pkg.Method(), so they don't belong in this registry.
			if fd.Receiver != nil {
				continue
			}

			returnCount := len(fd.Returns)
			if returnCount == 0 {
				// Void functions don't need an entry; the codegen handles them fine.
				continue
			}

			key := pkgName + "." + name
			if existing, exists := registry[key]; !exists || returnCount > existing {
				registry[key] = returnCount
			}
		}
	}

	// Build sorted entries for stable, diff-friendly output.
	entries := make([]string, 0, len(registry))
	for k, v := range registry {
		entries = append(entries, fmt.Sprintf("\t%q: %d,", k, v))
	}
	sort.Strings(entries)

	src := fmt.Sprintf(`// Code generated by cmd/genstdlibregistry; DO NOT EDIT.
// Run "make genstdlibregistry" to regenerate after changing stdlib/*.kuki files.

package semantic

// generatedStdlibRegistry maps qualified Kukicha stdlib function names (pkg.Func)
// to the number of return values they produce. The semantic analyzer uses this
// to correctly decompose pipe expressions and onerr clauses for imported functions.
//
// Generated from: stdlib/*/*.kuki (excludes *_test.kuki, methods, unexported funcs,
// and void functions).
var generatedStdlibRegistry = map[string]int{
%s
}
`, strings.Join(entries, "\n"))

	formatted, fmtErr := format.Source([]byte(src))
	if fmtErr != nil {
		fmt.Fprintf(os.Stderr, "gofmt error: %v\n", fmtErr)
		// Fall back to unformatted — still valid Go.
		formatted = []byte(src)
	}

	outPath := filepath.Join("internal", "semantic", "stdlib_registry_gen.go")
	if err := os.WriteFile(outPath, formatted, 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "write %s: %v\n", outPath, err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d entries.\n", outPath, len(registry))
}
