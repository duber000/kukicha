// genstdlibregistry generates internal/semantic/stdlib_registry_gen.go by
// scanning all stdlib/*.kuki source files and extracting exported function
// return counts. Run via "make genstdlibregistry" or "go run ./cmd/genstdlibregistry".
//
// This implements the "Automatic Inference" improvement described in COMPILER-FIX.md:
// instead of maintaining a hand-written registry in semantic.go, the registry is
// derived directly from the .kuki source files so it stays in sync automatically.
package main

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/duber000/kukicha/internal/ast"
	"github.com/duber000/kukicha/internal/parser"
)

func main() {
	// Expect to be run from the repo root (where stdlib/ lives).
	matches, err := filepath.Glob("stdlib/*/*.kuki")
	if err != nil {
		fmt.Fprintf(os.Stderr, "glob error: %v\n", err)
		os.Exit(1)
	}

	registry, scanErrs := scanRegistry(matches)
	if len(scanErrs) > 0 {
		for _, e := range scanErrs {
			fmt.Fprintln(os.Stderr, e)
		}
		fmt.Fprintln(os.Stderr, "aborting: stdlib scan had errors; registry not updated")
		os.Exit(1)
	}

	formatted := formatRegistry(registry)

	outPath := filepath.Join("internal", "semantic", "stdlib_registry_gen.go")
	if err := os.WriteFile(outPath, formatted, 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "write %s: %v\n", outPath, err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d entries.\n", outPath, len(registry))
}

// scanRegistry reads and parses all .kuki files in paths, returning a map of
// qualified function name → return count. Skips _test.kuki files, unexported
// functions, methods, and void functions. Returns accumulated errors.
func scanRegistry(paths []string) (map[string]int, []error) {
	registry := map[string]int{}
	var errs []error

	for _, path := range paths {
		base := filepath.Base(path)
		if strings.HasSuffix(base, "_test.kuki") {
			continue
		}

		src, err := os.ReadFile(path)
		if err != nil {
			errs = append(errs, fmt.Errorf("read %s: %v", path, err))
			continue
		}

		p, err := parser.New(string(src), path)
		if err != nil {
			errs = append(errs, fmt.Errorf("lex %s: %v", path, err))
			continue
		}

		prog, parseErrs := p.Parse()
		if len(parseErrs) > 0 {
			for _, e := range parseErrs {
				errs = append(errs, fmt.Errorf("parse error %s: %v", path, e))
			}
		}
		if prog == nil || prog.PetioleDecl == nil {
			continue
		}

		pkgName := prog.PetioleDecl.Name.Value

		for _, decl := range prog.Declarations {
			fd, ok := decl.(*ast.FunctionDecl)
			if !ok {
				continue
			}

			// Skip unexported functions (start with lowercase).
			name := fd.Name.Value
			if len(name) == 0 || name[0] < 'A' || name[0] > 'Z' {
				continue
			}

			// Skip methods — they have a receiver and are called as value.Method(),
			// not as pkg.Method(), so they don't belong in this registry.
			if fd.Receiver != nil {
				continue
			}

			returnCount := len(fd.Returns)
			if returnCount == 0 {
				// Void functions don't need an entry; the codegen handles them fine.
				continue
			}

			key := pkgName + "." + name
			if existing, exists := registry[key]; !exists || returnCount > existing {
				registry[key] = returnCount
			}
		}
	}

	return registry, errs
}

// formatRegistry generates the Go source code for stdlib_registry_gen.go from
// the given registry map. Returns gofmt'd source.
func formatRegistry(registry map[string]int) []byte {
	entries := make([]string, 0, len(registry))
	for k, v := range registry {
		entries = append(entries, fmt.Sprintf("\t%q: %d,", k, v))
	}
	sort.Strings(entries)

	src := fmt.Sprintf(`// Code generated by cmd/genstdlibregistry; DO NOT EDIT.
// Run "make genstdlibregistry" to regenerate after changing stdlib/*.kuki files.

package semantic

// generatedStdlibRegistry maps qualified Kukicha stdlib function names (pkg.Func)
// to the number of return values they produce. The semantic analyzer uses this
// to correctly decompose pipe expressions and onerr clauses for imported functions.
//
// Generated from: stdlib/*/*.kuki (excludes *_test.kuki, methods, unexported funcs,
// and void functions).
var generatedStdlibRegistry = map[string]int{
%s
}
`, strings.Join(entries, "\n"))

	formatted, fmtErr := format.Source([]byte(src))
	if fmtErr != nil {
		// Fall back to unformatted — still valid Go.
		return []byte(src)
	}
	return formatted
}
