commit 7b38dd598a0e718bc0c96e7cb126ad343a182b03
Author: Tivon Luker <tnluker@protonmail.com>
Date:   Fri Feb 27 22:03:38 2026 -0500

    feat(codegen,parser): support bidirectional loops and fix keyword parsing
    - Implement support for descending numeric for loops (e.g., from N to 0) by
      generating bidirectional condition checks in Go.
    - Resolve parser ambiguity where 'empty' and 'error' keywords were sometimes
      misidentified as identifiers in expressions (e.g., 'err != empty or ...').
    - Fix struct literal parsing to allow 'empty' and 'error' as field names.
    - Add TestFindLast and TestFindLastOr to slice stdlib to verify loop direction.
    - Update codegen and slice tests to reflect new output and type requirements.

diff --git a/internal/codegen/codegen_stmt.go b/internal/codegen/codegen_stmt.go
index 7da74be..f99036e 100644
--- a/internal/codegen/codegen_stmt.go
+++ b/internal/codegen/codegen_stmt.go
@@ -424,24 +424,68 @@ func (g *Generator) generateForNumericStmt(stmt *ast.ForNumericStmt) {
 	start := g.exprToString(stmt.Start)
 	end := g.exprToString(stmt.End)
 
-	// for i from 0 to N  →  for i := range N  (range-over-int, Go 1.22+)
+	// for i from A to/through B  →  supports both A <= B and A > B
+	// Generates:
+	// _start, _end := A, B
+	// if _start <= _end {
+	//     for varName := _start; varName <= _end; varName++ { ... }
+	// } else {
+	//     for varName := _start; varName >= _end; varName-- { ... }
+	// }
+	// Optimization: for i from 0 to N stays as range-over-int (Go 1.22+)
 	if !stmt.Through && start == "0" {
 		g.writeLine(fmt.Sprintf("for %s := range %s {", varName, end))
 	} else {
-		var condition string
-		if stmt.Through {
-			condition = fmt.Sprintf("%s <= %s", varName, end)
+		// Use unique internal variable names to avoid collisions with varName
+		startVar := "_" + varName + "Start"
+		endVar := "_" + varName + "End"
+
+		g.writeLine("{")
+		g.indent++
+		g.writeLine(fmt.Sprintf("%s, %s := %s, %s", startVar, endVar, start, end))
+
+		// Check for range-over-int optimization if start is 0
+		if !stmt.Through {
+			g.writeLine(fmt.Sprintf("if %s <= %s {", startVar, endVar))
+			g.indent++
+			g.writeLine(fmt.Sprintf("for %s := %s; %s < %s; %s++ {", varName, startVar, varName, endVar, varName))
+			g.indent++
+			g.generateBlock(stmt.Body)
+			g.indent--
+			g.writeLine("}")
+			g.indent--
+			g.writeLine("} else {")
+			g.indent++
+			g.writeLine(fmt.Sprintf("for %s := %s; %s > %s; %s-- {", varName, startVar, varName, endVar, varName))
+			g.indent++
+			g.generateBlock(stmt.Body)
+			g.indent--
+			g.writeLine("}")
+			g.indent--
+			g.writeLine("}")
 		} else {
-			condition = fmt.Sprintf("%s < %s", varName, end)
+			g.writeLine(fmt.Sprintf("if %s <= %s {", startVar, endVar))
+			g.indent++
+			g.writeLine(fmt.Sprintf("for %s := %s; %s <= %s; %s++ {", varName, startVar, varName, endVar, varName))
+			g.indent++
+			g.generateBlock(stmt.Body)
+			g.indent--
+			g.writeLine("}")
+			g.indent--
+			g.writeLine("} else {")
+			g.indent++
+			g.writeLine(fmt.Sprintf("for %s := %s; %s >= %s; %s-- {", varName, startVar, varName, endVar, varName))
+			g.indent++
+			g.generateBlock(stmt.Body)
+			g.indent--
+			g.writeLine("}")
+			g.indent--
+			g.writeLine("}")
 		}
-		g.writeLine(fmt.Sprintf("for %s := %s; %s; %s++ {", varName, start, condition, varName))
-	}
-
-	g.indent++
-	g.generateBlock(stmt.Body)
-	g.indent--
 
-	g.writeLine("}")
+		g.indent--
+		g.writeLine("}")
+	}
 }
 
 func (g *Generator) generateForConditionStmt(stmt *ast.ForConditionStmt) {
diff --git a/internal/codegen/codegen_test.go b/internal/codegen/codegen_test.go
index a2a0283..71a66d2 100644
--- a/internal/codegen/codegen_test.go
+++ b/internal/codegen/codegen_test.go
@@ -611,8 +611,8 @@ func TestNumericForLoopThrough(t *testing.T) {
 		t.Fatalf("codegen error: %v", err)
 	}
 
-	if !strings.Contains(output, "for i := 0; i <= 10; i++") {
-		t.Errorf("expected numeric for loop with <=, got: %s", output)
+	if !strings.Contains(output, "for i := _iStart; i <= _iEnd; i++") {
+		t.Errorf("expected numeric for loop with bidirectional check, got: %s", output)
 	}
 }
 
diff --git a/internal/parser/parser.go b/internal/parser/parser.go
index 1ea1223..c770c2b 100644
--- a/internal/parser/parser.go
+++ b/internal/parser/parser.go
@@ -202,16 +202,11 @@ func (p *Parser) isIdentifierFollower() bool {
 	switch next {
 	case lexer.TOKEN_WALRUS, lexer.TOKEN_ASSIGN,
 		lexer.TOKEN_DOT, lexer.TOKEN_LBRACKET,
-		lexer.TOKEN_COMMA, lexer.TOKEN_RPAREN, lexer.TOKEN_RBRACKET,
-		lexer.TOKEN_PLUS, lexer.TOKEN_MINUS, lexer.TOKEN_STAR, lexer.TOKEN_SLASH, lexer.TOKEN_PERCENT,
+		lexer.TOKEN_COMMA, lexer.TOKEN_RPAREN, lexer.TOKEN_RBRACKET, lexer.TOKEN_RBRACE,
 		lexer.TOKEN_PLUS_PLUS, lexer.TOKEN_MINUS_MINUS,
-		lexer.TOKEN_DOUBLE_EQUALS, lexer.TOKEN_NOT_EQUALS,
-		lexer.TOKEN_LT, lexer.TOKEN_LTE, lexer.TOKEN_GT, lexer.TOKEN_GTE,
-		lexer.TOKEN_PIPE, lexer.TOKEN_AND, lexer.TOKEN_OR,
-		lexer.TOKEN_ONERR:
+		lexer.TOKEN_SEMICOLON:
 		return true
 	default:
 		return false
 	}
 }
-
diff --git a/internal/parser/parser_expr.go b/internal/parser/parser_expr.go
index 425cc0c..73b0b4d 100644
--- a/internal/parser/parser_expr.go
+++ b/internal/parser/parser_expr.go
@@ -383,7 +383,11 @@ func (p *Parser) parsePrimaryExpr() ast.Expression {
 		}
 		return p.parseIdentifierOrStructLiteral()
 	case lexer.TOKEN_EMPTY:
-		if p.isIdentifierFollower() {
+		// empty is almost always a literal unless it's an assignment or member access
+		next := p.peekNextToken().Type
+		if next == lexer.TOKEN_WALRUS || next == lexer.TOKEN_ASSIGN ||
+			next == lexer.TOKEN_DOT || next == lexer.TOKEN_LBRACKET ||
+			next == lexer.TOKEN_COLON {
 			token := p.advance()
 			return &ast.Identifier{Token: token, Value: token.Lexeme}
 		}
@@ -392,7 +396,7 @@ func (p *Parser) parsePrimaryExpr() ast.Expression {
 		token := p.advance()
 		return &ast.DiscardExpr{Token: token}
 	case lexer.TOKEN_ERROR:
-		if p.isIdentifierFollower() {
+		if p.isIdentifierFollower() || p.check(lexer.TOKEN_RPAREN) || p.check(lexer.TOKEN_COMMA) || p.check(lexer.TOKEN_COLON) {
 			token := p.advance()
 			return &ast.Identifier{Token: token, Value: token.Lexeme}
 		}
@@ -1011,4 +1015,3 @@ func (p *Parser) parseMapLiteral() ast.Expression {
 		Pairs:   pairs,
 	}
 }
-
diff --git a/stdlib/kube/kube.go b/stdlib/kube/kube.go
index 5a736e4..9e50c33 100644
--- a/stdlib/kube/kube.go
+++ b/stdlib/kube/kube.go
@@ -22,17 +22,17 @@ import (
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:38
 type Cluster struct {
-	client    any
+	client any
 	namespace string
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:43
 type Config struct {
-	kubeconfig       string
-	context          string
-	inCluster        bool
+	kubeconfig string
+	context string
+	inCluster bool
 	retryMaxAttempts int
-	retryDelayMs     int
+	retryDelayMs int
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:51
@@ -88,10 +88,10 @@ type NamespaceItem struct {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:91
 type PodEvent struct {
 	eventType string
-	name      string
+	name string
 	namespace string
-	phase     string
-	ready     bool
+	phase string
+	ready bool
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:101
@@ -213,7 +213,7 @@ func Connect() (Cluster, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:178
 	home, err := os.UserHomeDir()
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:179
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:180
 		return Cluster{}, fmt.Errorf("kube connect: %w", err)
 	}
@@ -222,14 +222,14 @@ func Connect() (Cluster, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:182
 	config, cfgErr := clientcmd.BuildConfigFromFlags("", kubeconfig)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:183
-	if cfgErr != nil {
+	if (cfgErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:184
 		return Cluster{}, fmt.Errorf("kube connect: %w", cfgErr)
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:185
 	cs, csErr := kubernetes.NewForConfig(config)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:186
-	if csErr != nil {
+	if (csErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:187
 		return Cluster{}, fmt.Errorf("kube connect: %w", csErr)
 	}
@@ -244,14 +244,14 @@ func openOnce(cfg Config) (Cluster, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:193
 		restConfig, err := rest.InClusterConfig()
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:194
-		if err != nil {
+		if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:195
 			return Cluster{}, fmt.Errorf("kube in-cluster: %w", err)
 		}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:196
 		cs, csErr := kubernetes.NewForConfig(restConfig)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:197
-		if csErr != nil {
+		if (csErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:198
 			return Cluster{}, fmt.Errorf("kube open: %w", csErr)
 		}
@@ -261,11 +261,11 @@ func openOnce(cfg Config) (Cluster, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:200
 	kubeconfig := cfg.kubeconfig
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:201
-	if kubeconfig == "" {
+	if (kubeconfig == "") {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:202
 		home, homeErr := os.UserHomeDir()
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:203
-		if homeErr != nil {
+		if (homeErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:204
 			return Cluster{}, fmt.Errorf("kube config: %w", homeErr)
 		}
@@ -277,21 +277,21 @@ func openOnce(cfg Config) (Cluster, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:207
 	overrides := &clientcmd.ConfigOverrides{}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:208
-	if cfg.context != "" {
+	if (cfg.context != "") {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:209
 		overrides.CurrentContext = cfg.context
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:210
 	restConfig, rcErr := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, overrides).ClientConfig()
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:211
-	if rcErr != nil {
+	if (rcErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:212
 		return Cluster{}, fmt.Errorf("kube open: %w", rcErr)
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:213
 	cs, csErr := kubernetes.NewForConfig(restConfig)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:214
-	if csErr != nil {
+	if (csErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:215
 		return Cluster{}, fmt.Errorf("kube open: %w", csErr)
 	}
@@ -302,14 +302,14 @@ func openOnce(cfg Config) (Cluster, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:220
 func Open(cfg Config) (Cluster, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:221
-	if cfg.retryMaxAttempts <= 1 {
+	if (cfg.retryMaxAttempts <= 1) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:222
 		return openOnce(cfg)
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:224
 	delayMs := cfg.retryDelayMs
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:225
-	if delayMs <= 0 {
+	if (delayMs <= 0) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:226
 		delayMs = 1000
 	}
@@ -320,11 +320,11 @@ func Open(cfg Config) (Cluster, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:229
 	lastErr := errors.New("no attempts made")
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:230
-	for attempt < retryCfg.MaxAttempts {
+	for (attempt < retryCfg.MaxAttempts) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:231
 		cluster, err := openOnce(cfg)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:232
-		if err == nil {
+		if (err == nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:233
 			return cluster, nil
 		}
@@ -344,7 +344,7 @@ func ListPods(c Cluster) (PodList, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:243
 	pods, err := clientset(c).CoreV1().Pods(c.namespace).List(ctx.Value(ctx.Background()), metav1.ListOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:244
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:245
 		return PodList{}, fmt.Errorf("kube list pods: %w", err)
 	}
@@ -357,7 +357,7 @@ func ListPodsLabeled(c Cluster, selector string) (PodList, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:250
 	pods, err := clientset(c).CoreV1().Pods(c.namespace).List(ctx.Value(ctx.Background()), metav1.ListOptions{LabelSelector: selector})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:251
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:252
 		return PodList{}, fmt.Errorf("kube list pods labeled: %w", err)
 	}
@@ -370,7 +370,7 @@ func GetPod(c Cluster, name string) (Pod, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:257
 	p, err := clientset(c).CoreV1().Pods(c.namespace).Get(ctx.Value(ctx.Background()), name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:258
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:259
 		return Pod{}, fmt.Errorf("kube get pod: %w", err)
 	}
@@ -383,7 +383,7 @@ func DeletePod(c Cluster, name string) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:264
 	err := clientset(c).CoreV1().Pods(c.namespace).Delete(ctx.Value(ctx.Background()), name, metav1.DeleteOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:265
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:266
 		return fmt.Errorf("kube delete pod: %w", err)
 	}
@@ -396,7 +396,7 @@ func ListDeployments(c Cluster) (DeploymentList, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:273
 	deps, err := clientset(c).AppsV1().Deployments(c.namespace).List(ctx.Value(ctx.Background()), metav1.ListOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:274
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:275
 		return DeploymentList{}, fmt.Errorf("kube list deployments: %w", err)
 	}
@@ -409,7 +409,7 @@ func GetDeployment(c Cluster, name string) (Deployment, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:280
 	dep, err := clientset(c).AppsV1().Deployments(c.namespace).Get(ctx.Value(ctx.Background()), name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:281
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:282
 		return Deployment{}, fmt.Errorf("kube get deployment: %w", err)
 	}
@@ -422,7 +422,7 @@ func ScaleDeployment(c Cluster, name string, replicas int32) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:287
 	scale, err := clientset(c).AppsV1().Deployments(c.namespace).GetScale(ctx.Value(ctx.Background()), name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:288
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:289
 		return fmt.Errorf("kube scale get: %w", err)
 	}
@@ -431,7 +431,7 @@ func ScaleDeployment(c Cluster, name string, replicas int32) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:291
 	_, updateErr := clientset(c).AppsV1().Deployments(c.namespace).UpdateScale(ctx.Value(ctx.Background()), name, scale, metav1.UpdateOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:292
-	if updateErr != nil {
+	if (updateErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:293
 		return fmt.Errorf("kube scale update: %w", updateErr)
 	}
@@ -444,7 +444,7 @@ func DeleteDeployment(c Cluster, name string) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:298
 	err := clientset(c).AppsV1().Deployments(c.namespace).Delete(ctx.Value(ctx.Background()), name, metav1.DeleteOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:299
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:300
 		return fmt.Errorf("kube delete deployment: %w", err)
 	}
@@ -457,12 +457,12 @@ func RolloutRestart(c Cluster, name string) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:305
 	dep, err := clientset(c).AppsV1().Deployments(c.namespace).Get(ctx.Value(ctx.Background()), name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:306
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:307
 		return fmt.Errorf("kube rollout restart get: %w", err)
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:308
-	if dep.Spec.Template.ObjectMeta.Annotations == nil {
+	if (dep.Spec.Template.ObjectMeta.Annotations == nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:309
 		dep.Spec.Template.ObjectMeta.Annotations = map[string]string{}
 	}
@@ -471,7 +471,7 @@ func RolloutRestart(c Cluster, name string) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:311
 	_, updateErr := clientset(c).AppsV1().Deployments(c.namespace).Update(ctx.Value(ctx.Background()), dep, metav1.UpdateOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:312
-	if updateErr != nil {
+	if (updateErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:313
 		return fmt.Errorf("kube rollout restart update: %w", updateErr)
 	}
@@ -482,7 +482,7 @@ func RolloutRestart(c Cluster, name string) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:320
 func WaitDeploymentReady(c Cluster, name string, timeoutSeconds int64) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:321
-	if timeoutSeconds <= 0 {
+	if (timeoutSeconds <= 0) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:322
 		timeoutSeconds = 300
 	}
@@ -493,19 +493,19 @@ func WaitDeploymentReady(c Cluster, name string, timeoutSeconds int64) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:325
 		dep, err := clientset(c).AppsV1().Deployments(c.namespace).Get(ctx.Value(ctx.Background()), name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:326
-		if err != nil {
+		if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:327
 			return fmt.Errorf("kube wait deployment get: %w", err)
 		}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:328
 		desired := int32(1)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:329
-		if dep.Spec.Replicas != nil {
+		if (dep.Spec.Replicas != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:330
 			desired = *dep.Spec.Replicas
 		}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:331
-		if ((dep.Status.ObservedGeneration >= dep.Generation) && (dep.Status.ReadyReplicas >= desired)) && (dep.Status.UpdatedReplicas >= desired) {
+		if (((dep.Status.ObservedGeneration >= dep.Generation) && (dep.Status.ReadyReplicas >= desired)) && (dep.Status.UpdatedReplicas >= desired)) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:332
 			return nil
 		}
@@ -522,7 +522,7 @@ func WaitDeploymentReady(c Cluster, name string, timeoutSeconds int64) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:339
 func WaitPodReady(c Cluster, name string, timeoutSeconds int64) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:340
-	if timeoutSeconds <= 0 {
+	if (timeoutSeconds <= 0) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:341
 		timeoutSeconds = 180
 	}
@@ -533,7 +533,7 @@ func WaitPodReady(c Cluster, name string, timeoutSeconds int64) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:344
 		p, err := clientset(c).CoreV1().Pods(c.namespace).Get(ctx.Value(ctx.Background()), name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:345
-		if err != nil {
+		if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:346
 			return fmt.Errorf("kube wait pod get: %w", err)
 		}
@@ -542,7 +542,7 @@ func WaitPodReady(c Cluster, name string, timeoutSeconds int64) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:348
 		for _, cond := range p.Status.Conditions {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:349
-			if cond.Type == corev1.PodReady {
+			if (cond.Type == corev1.PodReady) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:350
 				ready = (cond.Status == corev1.ConditionTrue)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:351
@@ -573,26 +573,26 @@ func WaitDeploymentReadyCtx(c Cluster, h ctx.Handle, name string) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:362
 		dep, err := clientset(c).AppsV1().Deployments(c.namespace).Get(goCtx, name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:363
-		if err != nil {
+		if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:364
 			return fmt.Errorf("kube wait deployment get: %w", err)
 		}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:365
 		desired := int32(1)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:366
-		if dep.Spec.Replicas != nil {
+		if (dep.Spec.Replicas != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:367
 			desired = *dep.Spec.Replicas
 		}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:368
-		if ((dep.Status.ObservedGeneration >= dep.Generation) && (dep.Status.ReadyReplicas >= desired)) && (dep.Status.UpdatedReplicas >= desired) {
+		if (((dep.Status.ObservedGeneration >= dep.Generation) && (dep.Status.ReadyReplicas >= desired)) && (dep.Status.UpdatedReplicas >= desired)) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:369
 			return nil
 		}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:370
 		ctxErr := goCtx.Err()
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:371
-		if ctxErr != nil {
+		if (ctxErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:372
 			return fmt.Errorf("kube wait deployment: %w", ctxErr)
 		}
@@ -610,7 +610,7 @@ func WaitPodReadyCtx(c Cluster, h ctx.Handle, name string) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:379
 		p, err := clientset(c).CoreV1().Pods(c.namespace).Get(goCtx, name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:380
-		if err != nil {
+		if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:381
 			return fmt.Errorf("kube wait pod get: %w", err)
 		}
@@ -619,7 +619,7 @@ func WaitPodReadyCtx(c Cluster, h ctx.Handle, name string) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:383
 		for _, cond := range p.Status.Conditions {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:384
-			if cond.Type == corev1.PodReady {
+			if (cond.Type == corev1.PodReady) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:385
 				ready = (cond.Status == corev1.ConditionTrue)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:386
@@ -634,7 +634,7 @@ func WaitPodReadyCtx(c Cluster, h ctx.Handle, name string) error {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:389
 		ctxErr := goCtx.Err()
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:390
-		if ctxErr != nil {
+		if (ctxErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:391
 			return fmt.Errorf("kube wait pod: %w", ctxErr)
 		}
@@ -648,7 +648,7 @@ func ListServices(c Cluster) (ServiceList, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:398
 	svcs, err := clientset(c).CoreV1().Services(c.namespace).List(ctx.Value(ctx.Background()), metav1.ListOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:399
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:400
 		return ServiceList{}, fmt.Errorf("kube list services: %w", err)
 	}
@@ -661,7 +661,7 @@ func GetService(c Cluster, name string) (Service, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:405
 	svc, err := clientset(c).CoreV1().Services(c.namespace).Get(ctx.Value(ctx.Background()), name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:406
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:407
 		return Service{}, fmt.Errorf("kube get service: %w", err)
 	}
@@ -674,7 +674,7 @@ func ListNodes(c Cluster) (NodeList, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:414
 	nodes, err := clientset(c).CoreV1().Nodes().List(ctx.Value(ctx.Background()), metav1.ListOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:415
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:416
 		return NodeList{}, fmt.Errorf("kube list nodes: %w", err)
 	}
@@ -687,7 +687,7 @@ func GetNode(c Cluster, name string) (Node, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:421
 	n, err := clientset(c).CoreV1().Nodes().Get(ctx.Value(ctx.Background()), name, metav1.GetOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:422
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:423
 		return Node{}, fmt.Errorf("kube get node: %w", err)
 	}
@@ -700,7 +700,7 @@ func ListNamespaces(c Cluster) (NamespaceList, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:430
 	nsList, err := clientset(c).CoreV1().Namespaces().List(ctx.Value(ctx.Background()), metav1.ListOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:431
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:432
 		return NamespaceList{}, fmt.Errorf("kube list namespaces: %w", err)
 	}
@@ -716,9 +716,6 @@ func Pods(pl PodList) []Pod {
 	result := make([]Pod, len(podList.Items))
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:441
 	for i := range len(podList.Items) {
-//line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:442
-		result[i] = Pod{pod: &podList.Items[i]}
-	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:443
 	return result
 }
@@ -731,9 +728,6 @@ func Deployments(dl DeploymentList) []Deployment {
 	result := make([]Deployment, len(depList.Items))
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:449
 	for i := range len(depList.Items) {
-//line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:450
-		result[i] = Deployment{dep: &depList.Items[i]}
-	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:451
 	return result
 }
@@ -746,9 +740,6 @@ func Services(sl ServiceList) []Service {
 	result := make([]Service, len(svcList.Items))
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:457
 	for i := range len(svcList.Items) {
-//line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:458
-		result[i] = Service{svc: &svcList.Items[i]}
-	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:459
 	return result
 }
@@ -761,9 +752,6 @@ func Nodes(nl NodeList) []Node {
 	result := make([]Node, len(nodeList.Items))
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:465
 	for i := range len(nodeList.Items) {
-//line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:466
-		result[i] = Node{node: &nodeList.Items[i]}
-	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:467
 	return result
 }
@@ -776,9 +764,6 @@ func Namespaces(nsl NamespaceList) []NamespaceItem {
 	result := make([]NamespaceItem, len(nsList.Items))
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:473
 	for i := range len(nsList.Items) {
-//line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:474
-		result[i] = NamespaceItem{ns: &nsList.Items[i]}
-	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:475
 	return result
 }
@@ -812,14 +797,14 @@ func PodAge(p Pod) string {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:497
 	d := time.Since(pod(p).CreationTimestamp.Time)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:498
-	if d.Hours() >= 24 {
+	if (d.Hours() >= 24) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:499
 		days := (d.Hours() / 24)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:500
 		return fmt.Sprintf("%dd", int(days))
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:501
-	if d.Hours() >= 1 {
+	if (d.Hours() >= 1) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:502
 		return fmt.Sprintf("%dh", int(d.Hours()))
 	}
@@ -832,7 +817,7 @@ func PodReady(p Pod) bool {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:507
 	for _, cond := range pod(p).Status.Conditions {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:508
-		if cond.Type == corev1.PodReady {
+		if (cond.Type == corev1.PodReady) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:509
 			return (cond.Status == corev1.ConditionTrue)
 		}
@@ -869,7 +854,7 @@ func DeploymentName(d Deployment) string {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:530
 func DeploymentReplicas(d Deployment) int32 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:531
-	if deployment(d).Spec.Replicas != nil {
+	if (deployment(d).Spec.Replicas != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:532
 		return *deployment(d).Spec.Replicas
 	}
@@ -888,7 +873,7 @@ func DeploymentImage(d Deployment) string {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:541
 	containers := deployment(d).Spec.Template.Spec.Containers
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:542
-	if len(containers) > 0 {
+	if (len(containers) > 0) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:543
 		return containers[0].Image
 	}
@@ -940,7 +925,7 @@ func NodeReady(n Node) bool {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:576
 	for _, cond := range node(n).Status.Conditions {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:577
-		if cond.Type == corev1.NodeReady {
+		if (cond.Type == corev1.NodeReady) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:578
 			return (cond.Status == corev1.ConditionTrue)
 		}
@@ -962,14 +947,14 @@ func NodeRoles(n Node) []string {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:587
 			role := kukistring.TrimPrefix(label, prefix)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:588
-			if role != "" {
+			if (role != "") {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:589
 				roles = append(roles, role)
 			}
 		}
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:590
-	if len(roles) == 0 {
+	if (len(roles) == 0) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:591
 		roles = append(roles, "<none>")
 	}
@@ -996,7 +981,7 @@ func watchPodsWithContext(h ctx.Handle, c Cluster) ([]PodEvent, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:609
 	watcher, err := clientset(c).CoreV1().Pods(c.namespace).Watch(goCtx, metav1.ListOptions{})
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:610
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:611
 		return nil, fmt.Errorf("kube watch pods: %w", err)
 	}
@@ -1008,36 +993,36 @@ func watchPodsWithContext(h ctx.Handle, c Cluster) ([]PodEvent, error) {
 	for {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:615
 		select {
-		case <-goCtx.Done():
+			case <-goCtx.Done():
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:617
-			return events, nil
-		case event, ok := <-watcher.ResultChan():
+				return events, nil
+			case event, ok := <-watcher.ResultChan():
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:619
-			if !ok {
+				if !ok {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:620
-				return events, nil
-			}
+					return events, nil
+				}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:621
-			p, podOk := event.Object.(*corev1.Pod)
+				p, podOk := event.Object.(*corev1.Pod)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:622
-			if !podOk {
+				if !podOk {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:623
-				continue
-			}
+					continue
+				}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:624
-			ready := false
+				ready := false
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:625
-			for _, cond := range p.Status.Conditions {
+				for _, cond := range p.Status.Conditions {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:626
-				if cond.Type == corev1.PodReady {
+					if (cond.Type == corev1.PodReady) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:627
-					ready = (cond.Status == corev1.ConditionTrue)
+						ready = (cond.Status == corev1.ConditionTrue)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:628
-					break
+						break
+					}
 				}
-			}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:635
-			events = append(events, PodEvent{eventType: string(event.Type), name: p.Name, namespace: p.Namespace, phase: string(p.Status.Phase), ready: ready})
+				events = append(events, PodEvent{eventType: string(event.Type), name: p.Name, namespace: p.Namespace, phase: string(p.Status.Phase), ready: ready})
 		}
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:636
@@ -1047,7 +1032,7 @@ func watchPodsWithContext(h ctx.Handle, c Cluster) ([]PodEvent, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:640
 func WatchPods(c Cluster, timeoutSeconds int64) ([]PodEvent, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:641
-	if timeoutSeconds <= 0 {
+	if (timeoutSeconds <= 0) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:642
 		timeoutSeconds = 30
 	}
@@ -1070,7 +1055,7 @@ func PodLogs(c Cluster, name string, handles ...ctx.Handle) (string, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:656
 	goCtx := ctx.Value(ctx.Background())
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:657
-	if len(handles) > 0 {
+	if (len(handles) > 0) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:658
 		goCtx = ctx.Value(handles[0])
 	}
@@ -1079,7 +1064,7 @@ func PodLogs(c Cluster, name string, handles ...ctx.Handle) (string, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:660
 	stream, err := req.Stream(goCtx)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:661
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:662
 		return "", fmt.Errorf("kube pod logs: %w", err)
 	}
@@ -1088,7 +1073,7 @@ func PodLogs(c Cluster, name string, handles ...ctx.Handle) (string, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:664
 	data, readErr := io.ReadAll(stream)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:665
-	if readErr != nil {
+	if (readErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:666
 		return "", fmt.Errorf("kube pod logs read: %w", readErr)
 	}
@@ -1103,7 +1088,7 @@ func PodLogsTail(c Cluster, name string, lines int64) (string, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:672
 	stream, err := req.Stream(ctx.Value(ctx.Background()))
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:673
-	if err != nil {
+	if (err != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:674
 		return "", fmt.Errorf("kube pod logs tail: %w", err)
 	}
@@ -1112,7 +1097,7 @@ func PodLogsTail(c Cluster, name string, lines int64) (string, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:676
 	data, readErr := io.ReadAll(stream)
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:677
-	if readErr != nil {
+	if (readErr != nil) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/kube/kube.kuki:678
 		return "", fmt.Errorf("kube pod logs tail read: %w", readErr)
 	}
diff --git a/stdlib/random/random.go b/stdlib/random/random.go
index ff21e20..0afb196 100644
--- a/stdlib/random/random.go
+++ b/stdlib/random/random.go
@@ -12,9 +12,6 @@ func String(length int) string {
 	b := make([]byte, length)
 //line /var/home/tluker/repos/go/kukicha/stdlib/random/random.kuki:11
 	for i := range length {
-//line /var/home/tluker/repos/go/kukicha/stdlib/random/random.kuki:12
-		b[i] = charset[rand.Intn(len(charset))]
-	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/random/random.kuki:13
 	return string(b)
 }
diff --git a/stdlib/slice/slice.go b/stdlib/slice/slice.go
index a152c3c..d9ea555 100644
--- a/stdlib/slice/slice.go
+++ b/stdlib/slice/slice.go
@@ -357,11 +357,24 @@ func FindIndex[T any](items []T, predicate func(T) bool) int {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:242
 func FindLast[T any](items []T, predicate func(T) bool) (T, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:243
-	for i := (len(items) - 1); i <= 0; i++ {
+	{
+		_iStart, _iEnd := (len(items) - 1), 0
+		if _iStart <= _iEnd {
+			for i := _iStart; i <= _iEnd; i++ {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:244
-		if predicate(items[i]) {
+				if predicate(items[i]) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:245
-			return items[i], nil
+					return items[i], nil
+				}
+			}
+		} else {
+			for i := _iStart; i >= _iEnd; i-- {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:244
+				if predicate(items[i]) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:245
+					return items[i], nil
+				}
+			}
 		}
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:246
@@ -371,11 +384,24 @@ func FindLast[T any](items []T, predicate func(T) bool) (T, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:250
 func FindLastOr[T any](items []T, predicate func(T) bool, defaultValue T) T {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:251
-	for i := (len(items) - 1); i <= 0; i++ {
+	{
+		_iStart, _iEnd := (len(items) - 1), 0
+		if _iStart <= _iEnd {
+			for i := _iStart; i <= _iEnd; i++ {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:252
+				if predicate(items[i]) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:253
+					return items[i]
+				}
+			}
+		} else {
+			for i := _iStart; i >= _iEnd; i-- {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:252
-		if predicate(items[i]) {
+				if predicate(items[i]) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:253
-			return items[i]
+					return items[i]
+				}
+			}
 		}
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:254
diff --git a/stdlib/slice/slice_test.go b/stdlib/slice/slice_test.go
index 93fc5e4..6aaa261 100644
--- a/stdlib/slice/slice_test.go
+++ b/stdlib/slice/slice_test.go
@@ -597,3 +597,71 @@ func TestChunk(t *testing.T) {
 		test.AssertEqual(t, len(none), 0)
 	})
 }
+
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:397
+func TestFindLast(t *testing.T) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:398
+	items := []string{"apple", "banana", "cherry", "banana", "date"}
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:400
+	t.Run("found last element", func(t *testing.T) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:401
+		val, err := slice.FindLast(items, func(v string) bool { return (v == "banana") })
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:402
+		test.AssertNoError(t, err)
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:403
+		test.AssertEqual(t, val, "banana")
+	})
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:409
+	t.Run("found last with condition", func(t *testing.T) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:414
+		itemsWithIds := []Item{Item{Id: 1, Name: "a"}, Item{Id: 2, Name: "b"}, Item{Id: 3, Name: "a"}}
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:415
+		val, err := slice.FindLast(itemsWithIds, func(v Item) bool { return (v.Name == "a") })
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:416
+		test.AssertNoError(t, err)
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:417
+		test.AssertEqual(t, Item(val).Id, 3)
+	})
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:420
+	t.Run("not found returns error", func(t *testing.T) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:421
+		_, err := slice.FindLast(items, func(v string) bool { return (v == "grape") })
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:422
+		test.AssertError(t, err)
+	})
+}
+
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:426
+func TestFindLastOr(t *testing.T) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:427
+	items := []string{"apple", "banana", "cherry", "banana", "date"}
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:429
+	t.Run("match found", func(t *testing.T) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:430
+		val := slice.FindLastOr(items, func(s string) bool { return (s == "banana") }, "none")
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:431
+		test.AssertEqual(t, val, "banana")
+	})
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:434
+	t.Run("match last item", func(t *testing.T) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:439
+		itemsWithIds := []Item{Item{Id: 1, Name: "a"}, Item{Id: 2, Name: "b"}, Item{Id: 3, Name: "a"}}
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:440
+		val := slice.FindLastOr(itemsWithIds, func(v Item) bool { return (v.Name == "a") }, Item{Id: 0, Name: ""})
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:441
+		test.AssertEqual(t, Item(val).Id, 3)
+	})
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:444
+	t.Run("no match uses default", func(t *testing.T) {
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:445
+		def := slice.FindLastOr(items, func(s string) bool { return (s == "grape") }, "none")
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:446
+		test.AssertEqual(t, def, "none")
+	})
+}
+
+//line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:449
+type Item struct {
+	Id   int
+	Name string
+}
diff --git a/stdlib/slice/slice_test.kuki b/stdlib/slice/slice_test.kuki
index 03ea2ce..1d89e75 100644
--- a/stdlib/slice/slice_test.kuki
+++ b/stdlib/slice/slice_test.kuki
@@ -393,3 +393,59 @@ func TestChunk(t reference testing.T)
         none := slice.Chunk(items, 0)
         test.AssertEqual(t, len(none), 0)
     )
+# --- TestFindLast ---
+func TestFindLast(t reference testing.T)
+    items := list of string{"apple", "banana", "cherry", "banana", "date"}
+
+    t.Run("found last element", (t reference testing.T) =>
+        val, err := slice.FindLast(items, (v string) => v == "banana")
+        test.AssertNoError(t, err)
+        test.AssertEqual(t, val, "banana")
+        # How to verify it's the LAST one? We can check with a unique property if available,
+        # but here we can just trust the logic if it doesn't fail.
+        # Ideally we'd use a list of structs with IDs.
+    )
+
+    t.Run("found last with condition", (t reference testing.T) =>
+        itemsWithIds := list of Item{
+            Item{Id: 1, Name: "a"},
+            Item{Id: 2, Name: "b"},
+            Item{Id: 3, Name: "a"},
+        }
+        val, err := slice.FindLast(itemsWithIds, (v Item) => v.Name == "a")
+        test.AssertNoError(t, err)
+        test.AssertEqual(t, (val as Item).Id, 3)
+    )
+
+    t.Run("not found returns error", (t reference testing.T) =>
+        _, err := slice.FindLast(items, (v string) => v == "grape")
+        test.AssertError(t, err)
+    )
+
+# --- TestFindLastOr ---
+func TestFindLastOr(t reference testing.T)
+    items := list of string{"apple", "banana", "cherry", "banana", "date"}
+
+    t.Run("match found", (t reference testing.T) =>
+        val := items |> slice.FindLastOr((s string) => s == "banana", "none")
+        test.AssertEqual(t, val, "banana")
+    )
+
+    t.Run("match last item", (t reference testing.T) =>
+        itemsWithIds := list of Item{
+            Item{Id: 1, Name: "a"},
+            Item{Id: 2, Name: "b"},
+            Item{Id: 3, Name: "a"},
+        }
+        val := itemsWithIds |> slice.FindLastOr((v Item) => v.Name == "a", Item{Id: 0, Name: ""})
+        test.AssertEqual(t, (val as Item).Id, 3)
+    )
+
+    t.Run("no match uses default", (t reference testing.T) =>
+        def := items |> slice.FindLastOr((s string) => s == "grape", "none")
+        test.AssertEqual(t, def, "none")
+    )
+
+type Item
+    Id   int
+    Name string
diff --git a/stdlib/string/string_test.go b/stdlib/string/string_test.go
index 908f153..a1f7186 100644
--- a/stdlib/string/string_test.go
+++ b/stdlib/string/string_test.go
@@ -11,9 +11,9 @@ import (
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:10
 type StringCase struct {
-	name  string
+	name string
 	input string
-	want  string
+	want string
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:16
@@ -42,10 +42,10 @@ func TestToUpperToLower(t *testing.T) {
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:38
 type TrimCase struct {
-	name   string
-	input  string
+	name string
+	input string
 	cutset string
-	want   string
+	want string
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:44
@@ -219,10 +219,10 @@ func TestSearchFunctions(t *testing.T) {
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:164
 type IndexCase struct {
-	name  string
+	name string
 	input string
-	sub   string
-	want  int
+	sub string
+	want int
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:170
@@ -251,10 +251,10 @@ func TestIndexFunctions(t *testing.T) {
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:191
 type CountCase struct {
-	name  string
+	name string
 	input string
-	sub   string
-	want  int
+	sub string
+	want int
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:197
@@ -303,25 +303,15 @@ func TestRepeat(t *testing.T) {
 	counts := []int{3, 1, 0}
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:231
 	for i := range len(cases) {
-//line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:232
-		tc := cases[i]
-//line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:233
-		n := counts[i]
-//line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:234
-		t.Run(tc.name, func(t *testing.T) {
-//line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:235
-			test.AssertEqual(t, kukistring.Repeat(tc.input, n), tc.want)
-		})
-	}
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:239
 type PadCase struct {
-	name  string
+	name string
 	input string
 	width int
-	pad   string
-	want  string
+	pad string
+	want string
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/string/string_test.kuki:246

commit 32d7938ede8aab91ef540f27a082059f22c6603f
Author: Tivon Luker <tnluker@protonmail.com>
Date:   Fri Feb 27 19:38:54 2026 -0500

    fix: resolve all three documented compiler limitations
    
    - Float literals: use original source text instead of fmt.Sprintf("%f")
      to preserve precision (e.g., 0.000000001 no longer truncated)
    
    - Generic slice functions: make all remaining slice functions generic.
      Get/FirstOne/LastOne/Find/FindLast/Pop/Shift now use [T any];
      Unique/Contains/IndexOf now use [K comparable]. Position-aware
      zero-value logic emits *new(T) only when return type uses a
      placeholder, nil otherwise.
    
    - Context-sensitive empty/error: allow both keywords as variable names
      via isIdentifierFollower() lookahead in the parser. Keywords still
      work as expected when followed by type names or string literals.
    
    Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>

diff --git a/.agent/skills/kukicha/troubleshooting.md b/.agent/skills/kukicha/troubleshooting.md
index 8a55a70..68c9a42 100644
--- a/.agent/skills/kukicha/troubleshooting.md
+++ b/.agent/skills/kukicha/troubleshooting.md
@@ -414,7 +414,7 @@ kukicha check myfile.kuki
 | Error | Likely Cause |
 |-------|--------------|
 | "unexpected NEWLINE" | Missing expression or extra blank line |
-| "expected identifier" | Using reserved word as variable name |
+| "expected identifier" | Using a keyword in an unsupported position (note: `empty` and `error` can be used as variable names) |
 | "type mismatch" | Wrong type in assignment/return |
 | "undeclared name" | Variable used before declaration |
 | "not enough arguments" | Missing function arguments |
diff --git a/.claude/skills/kukicha/troubleshooting.md b/.claude/skills/kukicha/troubleshooting.md
index 8a55a70..68c9a42 100644
--- a/.claude/skills/kukicha/troubleshooting.md
+++ b/.claude/skills/kukicha/troubleshooting.md
@@ -414,7 +414,7 @@ kukicha check myfile.kuki
 | Error | Likely Cause |
 |-------|--------------|
 | "unexpected NEWLINE" | Missing expression or extra blank line |
-| "expected identifier" | Using reserved word as variable name |
+| "expected identifier" | Using a keyword in an unsupported position (note: `empty` and `error` can be used as variable names) |
 | "type mismatch" | Wrong type in assignment/return |
 | "undeclared name" | Variable used before declaration |
 | "not enough arguments" | Missing function arguments |
diff --git a/AGENTS.md b/AGENTS.md
index 6e5df89..fb65e63 100644
--- a/AGENTS.md
+++ b/AGENTS.md
@@ -1,4 +1,4 @@
-# AGENTS.md
+# CLAUDE.md
 
 Kukicha is a beginner-friendly programming language that **transpiles to Go**.
 Current version: **0.0.10**
@@ -14,7 +14,7 @@ When editing `.kuki` files, write **Kukicha syntax, NOT Go**.
 | `*User` | `reference User` |
 | `&user` | `reference of user` |
 | `*ptr` | `dereference ptr` |
-| `nil` | `empty` |
+| `nil` | `empty` (also usable as variable name) |
 | `{ }` braces | 4-space indentation |
 | `==` | `equals` (or `==`) |
 | `func (t T) Method()` | `func Method on t T` |
@@ -61,6 +61,8 @@ func GroupBy(items list of any, keyFunc func(any) any2) map of any2 to list of a
 ```
 The compiler generates: `func GroupBy[T any, K comparable](items []T, keyFunc func(T) K) map[K][]T`
 
+Functions that use `any2` only (no `any`): `Unique`, `Contains`, `IndexOf`. These emit `[K comparable]` as the sole type parameter.
+
 Application code just calls `logs |> slice.GroupBy(getLevel)` — no generics syntax needed.
 
 ## Kukicha Syntax Quick Reference
@@ -69,6 +71,7 @@ Application code just calls `logs |> slice.GroupBy(getLevel)` — no generics sy
 ```kukicha
 count := 42              # Type inferred
 count = 100              # Reassignment
+val, error := f()        # 'error' and 'empty' can be used as variable names
 ```
 
 ### Functions (explicit types required)
@@ -292,7 +295,7 @@ select
 
 ## Security Checks (Compiler-Enforced)
 
-The compiler enforces SQL injection, XSS, SSRF, path traversal, command injection, and open redirect checks at compile time. See **[`stdlib/AGENTS.md`](stdlib/AGENTS.md)** for the full check table and safe alternatives.
+The compiler enforces SQL injection, XSS, SSRF, path traversal, command injection, and open redirect checks at compile time. See **[`stdlib/CLAUDE.md`](stdlib/CLAUDE.md)** for the full check table and safe alternatives.
 
 ## Build & Test Commands
 
@@ -339,7 +342,7 @@ import "stdlib/ctx" as ctxpkg          # alias — use when the package name con
 import "github.com/jackc/pgx/v5" as pgx  # external package with alias
 ```
 
-Use `as alias` whenever the package's last path segment clashes with a local variable name. See **[`stdlib/AGENTS.md`](stdlib/AGENTS.md)** for the canonical alias table.
+Use `as alias` whenever the package's last path segment clashes with a local variable name. See **[`stdlib/CLAUDE.md`](stdlib/CLAUDE.md)** for the canonical alias table.
 
 ## Critical Rules
 
@@ -358,11 +361,11 @@ Typical workflow for new syntax:
 4. **Codegen** (`internal/codegen/`) - Generate corresponding Go code
 5. **Tests** - Add tests in each modified package
 
-See **[`internal/AGENTS.md`](internal/AGENTS.md)** for the full compiler reference.
+See **[`internal/CLAUDE.md`](internal/CLAUDE.md)** for the full compiler reference.
 
 ## Stdlib Packages
 
-See **[`stdlib/AGENTS.md`](stdlib/AGENTS.md)** for the full package reference, API details, and common usage patterns.
+See **[`stdlib/CLAUDE.md`](stdlib/CLAUDE.md)** for the full package reference, API details, and common usage patterns.
 
 Import with: `import "stdlib/slice"`
 
diff --git a/CLAUDE.md b/CLAUDE.md
index 3b7cbc2..fb65e63 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -14,7 +14,7 @@ When editing `.kuki` files, write **Kukicha syntax, NOT Go**.
 | `*User` | `reference User` |
 | `&user` | `reference of user` |
 | `*ptr` | `dereference ptr` |
-| `nil` | `empty` |
+| `nil` | `empty` (also usable as variable name) |
 | `{ }` braces | 4-space indentation |
 | `==` | `equals` (or `==`) |
 | `func (t T) Method()` | `func Method on t T` |
@@ -61,6 +61,8 @@ func GroupBy(items list of any, keyFunc func(any) any2) map of any2 to list of a
 ```
 The compiler generates: `func GroupBy[T any, K comparable](items []T, keyFunc func(T) K) map[K][]T`
 
+Functions that use `any2` only (no `any`): `Unique`, `Contains`, `IndexOf`. These emit `[K comparable]` as the sole type parameter.
+
 Application code just calls `logs |> slice.GroupBy(getLevel)` — no generics syntax needed.
 
 ## Kukicha Syntax Quick Reference
@@ -69,6 +71,7 @@ Application code just calls `logs |> slice.GroupBy(getLevel)` — no generics sy
 ```kukicha
 count := 42              # Type inferred
 count = 100              # Reassignment
+val, error := f()        # 'error' and 'empty' can be used as variable names
 ```
 
 ### Functions (explicit types required)
diff --git a/docs/LIMITATIONS.md b/docs/LIMITATIONS.md
index 629b216..f642abf 100644
--- a/docs/LIMITATIONS.md
+++ b/docs/LIMITATIONS.md
@@ -1,13 +1,17 @@
 # Kukicha Language Limitations
 
-Known gaps between Kukicha syntax and Go patterns. 
-
-1. empty is a reserved keyword — can't be used as a
-  variable name - same as error
-2. Non-generic slice functions (Unique, Contains,
-  IndexOf, Get, FirstOne, LastOne, Find, Pop, Shift) take
-   []any literally, not []T — must pass list of any{...}
-  at call sites
-3. Float literals lose precision in codegen — avoid
-  small tolerances like 0.000000001; use simple range
-  checks (x < 3.14 or x > 3.15) instead
+No known limitations at this time.
+
+Previously documented gaps (all resolved):
+
+1. ~~`empty` and `error` as variable names~~ — Fixed: context-sensitive
+   parsing now allows both keywords to be used as identifiers when
+   followed by assignment, operators, or delimiters.
+
+2. ~~Non-generic slice functions~~ — Fixed: all slice functions are now
+   generic. `Get`, `FirstOne`, `LastOne`, `Find`, `FindLast`, `Pop`,
+   `Shift` use `[T any]`; `Unique`, `Contains`, `IndexOf` use
+   `[K comparable]`.
+
+3. ~~Float literal precision~~ — Fixed: codegen now preserves the original
+   source text for float literals instead of formatting through `%f`.
diff --git a/internal/AGENTS.md b/internal/AGENTS.md
index ce8a6b5..c85c1f3 100644
--- a/internal/AGENTS.md
+++ b/internal/AGENTS.md
@@ -1,6 +1,6 @@
-# internal/AGENTS.md
+# internal/CLAUDE.md
 
-Compiler internals reference. Read this when working in `internal/`. For language syntax and build commands see the root `AGENTS.md`.
+Compiler internals reference. Read this when working in `internal/`. For language syntax and build commands see the root `CLAUDE.md`.
 
 ## Pipeline Overview
 
@@ -64,7 +64,7 @@ Add the keyword string → `TokenType` mapping in `token.go`'s `keywords` map an
 - Recursive descent
 - **Error collection** (not fail-fast): errors are appended to `p.errors`, parsing continues. This allows multiple errors per compile.
 - `peekToken()` calls `skipIgnoredTokens()` first, which skips `TOKEN_COMMENT` and `TOKEN_SEMICOLON`
-- Context-sensitive keywords: `list`, `map`, `channel` are only keywords when followed by `of` in a type context — this allows them as variable names elsewhere
+- Context-sensitive keywords: `list`, `map`, `channel` are only keywords when followed by `of` in a type context — this allows them as variable names elsewhere. `empty` and `error` are context-sensitive too: `isIdentifierFollower()` checks if the next token indicates identifier usage (assignment, operators, delimiters); if so, they parse as identifiers instead of `EmptyExpr`/`ErrorExpr`
 
 ### Key helpers
 
@@ -75,6 +75,7 @@ Add the keyword string → `TokenType` mapping in `token.go`'s `keywords` map an
 | `skipNewlines()` | Skip `TOKEN_NEWLINE` tokens |
 | `parseBlock()` | Parse `INDENT … DEDENT` block into `*ast.BlockStmt` |
 | `parseTypeAnnotation()` | Parse any Kukicha type (`list of T`, `map of K to V`, `reference T`, etc.) |
+| `isIdentifierFollower()` | Returns true if next token indicates `empty`/`error` is being used as an identifier |
 
 ### Adding a new statement
 
@@ -199,6 +200,7 @@ make genstdlibregistry   # or: make generate (runs everything)
 | `funcDefaults map[string]*FuncDefaults` | Default parameter info for wrapper generation |
 | `placeholderMap map[string]string` | Generic placeholder substitution (`"any"→"T"`, `"any2"→"K"`) |
 | `currentOnErrVar string` | Error variable name in active `onerr` block (for `{error}` interpolation) |
+| `currentReturnIndex int` | Index of return value being generated (-1 if not in return); used to emit `*new(T)` vs `nil` for bare `empty` in generic stdlib functions |
 | `exprReturnCounts map[ast.Expression]int` | From semantic — drives `onerr` multi-value split |
 
 ### onerr code generation
@@ -211,6 +213,9 @@ When `isStdlibIter` is true (or per-function for `stdlib/slice`), the generator
 1. Builds a `placeholderMap` mapping placeholder → Go type param name (`T`, `K`)
 2. Emits `[T any, K comparable]` on the function signature
 3. Substitutes placeholders throughout parameter and return types
+4. Emits `*new(T)` or `*new(K)` for bare `empty` in return position when the return type uses a placeholder (otherwise emits `nil`)
+
+All `stdlib/slice` functions are generic: `genericSafe` map lists `[T any]` functions, `comparableSafe` map lists `[K comparable]` functions (`Unique`, `Contains`, `IndexOf`), and `GroupBy` gets both `[T any, K comparable]`.
 
 Application code never sees this — it just calls functions normally.
 
diff --git a/internal/CLAUDE.md b/internal/CLAUDE.md
index 7fbb037..c85c1f3 100644
--- a/internal/CLAUDE.md
+++ b/internal/CLAUDE.md
@@ -64,7 +64,7 @@ Add the keyword string → `TokenType` mapping in `token.go`'s `keywords` map an
 - Recursive descent
 - **Error collection** (not fail-fast): errors are appended to `p.errors`, parsing continues. This allows multiple errors per compile.
 - `peekToken()` calls `skipIgnoredTokens()` first, which skips `TOKEN_COMMENT` and `TOKEN_SEMICOLON`
-- Context-sensitive keywords: `list`, `map`, `channel` are only keywords when followed by `of` in a type context — this allows them as variable names elsewhere
+- Context-sensitive keywords: `list`, `map`, `channel` are only keywords when followed by `of` in a type context — this allows them as variable names elsewhere. `empty` and `error` are context-sensitive too: `isIdentifierFollower()` checks if the next token indicates identifier usage (assignment, operators, delimiters); if so, they parse as identifiers instead of `EmptyExpr`/`ErrorExpr`
 
 ### Key helpers
 
@@ -75,6 +75,7 @@ Add the keyword string → `TokenType` mapping in `token.go`'s `keywords` map an
 | `skipNewlines()` | Skip `TOKEN_NEWLINE` tokens |
 | `parseBlock()` | Parse `INDENT … DEDENT` block into `*ast.BlockStmt` |
 | `parseTypeAnnotation()` | Parse any Kukicha type (`list of T`, `map of K to V`, `reference T`, etc.) |
+| `isIdentifierFollower()` | Returns true if next token indicates `empty`/`error` is being used as an identifier |
 
 ### Adding a new statement
 
@@ -199,6 +200,7 @@ make genstdlibregistry   # or: make generate (runs everything)
 | `funcDefaults map[string]*FuncDefaults` | Default parameter info for wrapper generation |
 | `placeholderMap map[string]string` | Generic placeholder substitution (`"any"→"T"`, `"any2"→"K"`) |
 | `currentOnErrVar string` | Error variable name in active `onerr` block (for `{error}` interpolation) |
+| `currentReturnIndex int` | Index of return value being generated (-1 if not in return); used to emit `*new(T)` vs `nil` for bare `empty` in generic stdlib functions |
 | `exprReturnCounts map[ast.Expression]int` | From semantic — drives `onerr` multi-value split |
 
 ### onerr code generation
@@ -211,6 +213,9 @@ When `isStdlibIter` is true (or per-function for `stdlib/slice`), the generator
 1. Builds a `placeholderMap` mapping placeholder → Go type param name (`T`, `K`)
 2. Emits `[T any, K comparable]` on the function signature
 3. Substitutes placeholders throughout parameter and return types
+4. Emits `*new(T)` or `*new(K)` for bare `empty` in return position when the return type uses a placeholder (otherwise emits `nil`)
+
+All `stdlib/slice` functions are generic: `genericSafe` map lists `[T any]` functions, `comparableSafe` map lists `[K comparable]` functions (`Unique`, `Contains`, `IndexOf`), and `GroupBy` gets both `[T any, K comparable]`.
 
 Application code never sees this — it just calls functions normally.
 
diff --git a/internal/codegen/codegen.go b/internal/codegen/codegen.go
index ef95d1b..573cd52 100644
--- a/internal/codegen/codegen.go
+++ b/internal/codegen/codegen.go
@@ -60,18 +60,20 @@ type Generator struct {
 	mcpTarget            bool                     // True if targeting MCP (Model Context Protocol)
 	currentOnErrVar      string                   // Current onerr error variable name (for block-style onerr {error} references)
 	currentOnErrAlias    string                   // Named alias for caught error in current onerr block (e.g., "e" for "onerr as e")
+	currentReturnIndex   int                      // Index of return value being generated (-1 if not in return)
 	stdlibModuleBase     string                   // Base module path for rewriting "stdlib/X" imports (default: defaultStdlibModuleBase)
 }
 
 // New creates a new code generator
 func New(program *ast.Program) *Generator {
 	return &Generator{
-		program:          program,
-		indent:           0,
-		autoImports:      make(map[string]bool),
-		pkgAliases:       make(map[string]string),
-		funcDefaults:     make(map[string]*FuncDefaults),
-		stdlibModuleBase: defaultStdlibModuleBase,
+		program:            program,
+		indent:             0,
+		autoImports:        make(map[string]bool),
+		pkgAliases:         make(map[string]string),
+		funcDefaults:       make(map[string]*FuncDefaults),
+		stdlibModuleBase:   defaultStdlibModuleBase,
+		currentReturnIndex: -1,
 	}
 }
 
diff --git a/internal/codegen/codegen_expr.go b/internal/codegen/codegen_expr.go
index 2b19a0d..21fc133 100644
--- a/internal/codegen/codegen_expr.go
+++ b/internal/codegen/codegen_expr.go
@@ -33,7 +33,7 @@ func (g *Generator) exprToString(expr ast.Expression) string {
 		}
 		return fmt.Sprintf("%d", e.Value)
 	case *ast.FloatLiteral:
-		return fmt.Sprintf("%f", e.Value)
+		return e.Token.Lexeme
 	case *ast.RuneLiteral:
 		return fmt.Sprintf("'%s'", g.escapeRune(e.Value))
 	case *ast.StringLiteral:
@@ -91,10 +91,27 @@ func (g *Generator) exprToString(expr ast.Expression) string {
 			}
 			return g.zeroValueForType(e.Type)
 		}
-		// In generic stdlib/iter context, use *new(T) for zero value instead of nil
-		if g.isStdlibIter && g.placeholderMap != nil {
-			if _, hasT := g.placeholderMap["any"]; hasT {
-				return "*new(T)"
+		// In generic stdlib context, use *new(T) or *new(K) for zero value instead of nil
+		// But only if the return type at this position actually uses a placeholder type
+		if (g.isStdlibIter || g.isStdlibSlice()) && g.placeholderMap != nil {
+			// If we're in a return statement and know the return type, check if it's a placeholder
+			if g.currentReturnIndex >= 0 && g.currentReturnIndex < len(g.currentReturnTypes) {
+				retType := g.currentReturnTypes[g.currentReturnIndex]
+				if _, hasT := g.placeholderMap["any"]; hasT && g.typeContainsPlaceholder(retType, "any") {
+					return "*new(T)"
+				}
+				if _, hasK := g.placeholderMap["any2"]; hasK && g.typeContainsPlaceholder(retType, "any2") {
+					return "*new(K)"
+				}
+				// Return type doesn't use a placeholder — fall through to nil
+			} else {
+				// Not in a return statement context — use *new(T) as default
+				if _, hasT := g.placeholderMap["any"]; hasT {
+					return "*new(T)"
+				}
+				if _, hasK := g.placeholderMap["any2"]; hasK {
+					return "*new(K)"
+				}
 			}
 		}
 		return "nil"
diff --git a/internal/codegen/codegen_stdlib.go b/internal/codegen/codegen_stdlib.go
index 8f4a06f..7734fab 100644
--- a/internal/codegen/codegen_stdlib.go
+++ b/internal/codegen/codegen_stdlib.go
@@ -182,7 +182,49 @@ func (g *Generator) inferSliceTypeParameters(decl *ast.FunctionDecl) []*TypePara
 		"FindOr":     true,
 		"FindIndex":  true,
 		"FindLastOr": true,
+		"Get":        true,
+		"FirstOne":   true,
+		"LastOne":    true,
+		"Find":       true,
+		"FindLast":   true,
+		"Pop":        true,
+		"Shift":      true,
+	}
+
+	// Functions that use any2 (comparable) but not any as first type param
+	comparableSafe := map[string]bool{
+		"Unique":   true,
+		"Contains": true,
+		"IndexOf":  true,
+	}
+
+	if comparableSafe[decl.Name.Value] {
+		// These functions use any2 only — emit [K comparable] as the sole type parameter
+		usesAny2 := false
+		for _, param := range decl.Parameters {
+			if g.typeContainsPlaceholder(param.Type, "any2") {
+				usesAny2 = true
+				break
+			}
+		}
+		if !usesAny2 {
+			for _, ret := range decl.Returns {
+				if g.typeContainsPlaceholder(ret, "any2") {
+					usesAny2 = true
+					break
+				}
+			}
+		}
+		if usesAny2 {
+			typeParams = append(typeParams, &TypeParameter{
+				Name:        "K",
+				Placeholder: "any2",
+				Constraint:  "comparable",
+			})
+		}
+		return typeParams
 	}
+
 	if !genericSafe[decl.Name.Value] {
 		return typeParams
 	}
diff --git a/internal/codegen/codegen_stmt.go b/internal/codegen/codegen_stmt.go
index 25528ce..7da74be 100644
--- a/internal/codegen/codegen_stmt.go
+++ b/internal/codegen/codegen_stmt.go
@@ -177,6 +177,7 @@ func (g *Generator) generateReturnStmt(stmt *ast.ReturnStmt) {
 
 	values := make([]string, len(stmt.Values))
 	for i, val := range stmt.Values {
+		g.currentReturnIndex = i
 		valStr := g.exprToString(val)
 
 		// Apply type coercion if we have matching return types
@@ -188,6 +189,7 @@ func (g *Generator) generateReturnStmt(stmt *ast.ReturnStmt) {
 		values[i] = valStr
 	}
 
+	g.currentReturnIndex = -1
 	g.writeLine(fmt.Sprintf("return %s", strings.Join(values, ", ")))
 }
 
diff --git a/internal/codegen/codegen_test.go b/internal/codegen/codegen_test.go
index abb8852..a2a0283 100644
--- a/internal/codegen/codegen_test.go
+++ b/internal/codegen/codegen_test.go
@@ -2073,3 +2073,97 @@ func Wrap(handler http.Handler) http.Handler
 		t.Errorf("expected return handler, got: %s", output)
 	}
 }
+
+func TestFloatLiteralPrecision(t *testing.T) {
+	input := `func Main()
+    x := 0.000000001
+    y := 3.14159265358979
+`
+
+	p, err := parser.New(input, "test.kuki")
+	if err != nil {
+		t.Fatalf("parser error: %v", err)
+	}
+
+	program, parseErrors := p.Parse()
+	if len(parseErrors) > 0 {
+		t.Fatalf("parse errors: %v", parseErrors)
+	}
+
+	gen := New(program)
+	output, err := gen.Generate()
+	if err != nil {
+		t.Fatalf("codegen error: %v", err)
+	}
+
+	if !strings.Contains(output, "0.000000001") {
+		t.Errorf("expected float 0.000000001 to be preserved, got: %s", output)
+	}
+	if !strings.Contains(output, "3.14159265358979") {
+		t.Errorf("expected float 3.14159265358979 to be preserved, got: %s", output)
+	}
+}
+
+func TestErrorAsVariableName(t *testing.T) {
+	input := `func Main()
+    val, error := divide(10, 0)
+    print(error)
+
+func divide(a int, b int) (int, error)
+    if b == 0
+        return 0, error "division by zero"
+    return a / b, empty
+`
+
+	p, err := parser.New(input, "test.kuki")
+	if err != nil {
+		t.Fatalf("parser error: %v", err)
+	}
+
+	program, parseErrors := p.Parse()
+	if len(parseErrors) > 0 {
+		t.Fatalf("parse errors: %v", parseErrors)
+	}
+
+	gen := New(program)
+	output, err := gen.Generate()
+	if err != nil {
+		t.Fatalf("codegen error: %v", err)
+	}
+
+	// error used as variable name in multi-value assignment
+	if !strings.Contains(output, "val, error := divide(10, 0)") {
+		t.Errorf("expected 'val, error := divide(10, 0)', got: %s", output)
+	}
+	// error keyword still works as errors.New()
+	if !strings.Contains(output, `errors.New("division by zero")`) {
+		t.Errorf("expected errors.New for error keyword, got: %s", output)
+	}
+}
+
+func TestEmptyAsVariableName(t *testing.T) {
+	input := `func Main()
+    empty := 42
+    print(empty)
+`
+
+	p, err := parser.New(input, "test.kuki")
+	if err != nil {
+		t.Fatalf("parser error: %v", err)
+	}
+
+	program, parseErrors := p.Parse()
+	if len(parseErrors) > 0 {
+		t.Fatalf("parse errors: %v", parseErrors)
+	}
+
+	gen := New(program)
+	output, err := gen.Generate()
+	if err != nil {
+		t.Fatalf("codegen error: %v", err)
+	}
+
+	if !strings.Contains(output, "empty := 42") {
+		t.Errorf("expected 'empty := 42', got: %s", output)
+	}
+}
diff --git a/internal/parser/parser.go b/internal/parser/parser.go
index 46742e3..1ea1223 100644
--- a/internal/parser/parser.go
+++ b/internal/parser/parser.go
@@ -193,3 +193,25 @@ func (p *Parser) skipNewlines() {
 	}
 }
 
+// isIdentifierFollower returns true if the next token indicates that the current
+// token (empty/error) is being used as an identifier rather than a keyword.
+// Tokens that follow identifiers: assignment, postfix, member access, indexing,
+// operators, delimiters, end-of-line.
+func (p *Parser) isIdentifierFollower() bool {
+	next := p.peekNextToken().Type
+	switch next {
+	case lexer.TOKEN_WALRUS, lexer.TOKEN_ASSIGN,
+		lexer.TOKEN_DOT, lexer.TOKEN_LBRACKET,
+		lexer.TOKEN_COMMA, lexer.TOKEN_RPAREN, lexer.TOKEN_RBRACKET,
+		lexer.TOKEN_PLUS, lexer.TOKEN_MINUS, lexer.TOKEN_STAR, lexer.TOKEN_SLASH, lexer.TOKEN_PERCENT,
+		lexer.TOKEN_PLUS_PLUS, lexer.TOKEN_MINUS_MINUS,
+		lexer.TOKEN_DOUBLE_EQUALS, lexer.TOKEN_NOT_EQUALS,
+		lexer.TOKEN_LT, lexer.TOKEN_LTE, lexer.TOKEN_GT, lexer.TOKEN_GTE,
+		lexer.TOKEN_PIPE, lexer.TOKEN_AND, lexer.TOKEN_OR,
+		lexer.TOKEN_ONERR:
+		return true
+	default:
+		return false
+	}
+}
+
diff --git a/internal/parser/parser_expr.go b/internal/parser/parser_expr.go
index 26b33c9..425cc0c 100644
--- a/internal/parser/parser_expr.go
+++ b/internal/parser/parser_expr.go
@@ -383,11 +383,19 @@ func (p *Parser) parsePrimaryExpr() ast.Expression {
 		}
 		return p.parseIdentifierOrStructLiteral()
 	case lexer.TOKEN_EMPTY:
+		if p.isIdentifierFollower() {
+			token := p.advance()
+			return &ast.Identifier{Token: token, Value: token.Lexeme}
+		}
 		return p.parseEmptyExpr()
 	case lexer.TOKEN_DISCARD:
 		token := p.advance()
 		return &ast.DiscardExpr{Token: token}
 	case lexer.TOKEN_ERROR:
+		if p.isIdentifierFollower() {
+			token := p.advance()
+			return &ast.Identifier{Token: token, Value: token.Lexeme}
+		}
 		return p.parseErrorExpr()
 	case lexer.TOKEN_MAKE:
 		return p.parseMakeExpr()
@@ -435,7 +443,7 @@ func (p *Parser) parsePrimaryExpr() ast.Expression {
 
 func (p *Parser) parseIdentifier() *ast.Identifier {
 	token := p.advance()
-	if token.Type != lexer.TOKEN_IDENTIFIER {
+	if token.Type != lexer.TOKEN_IDENTIFIER && token.Type != lexer.TOKEN_EMPTY && token.Type != lexer.TOKEN_ERROR {
 		p.error(token, "expected identifier")
 		return nil
 	}
diff --git a/internal/parser/parser_stmt.go b/internal/parser/parser_stmt.go
index aabdbde..4109a65 100644
--- a/internal/parser/parser_stmt.go
+++ b/internal/parser/parser_stmt.go
@@ -717,9 +717,9 @@ func (p *Parser) checkMultiValueAssignment() bool {
 	// Supports 2 or more identifiers on the left-hand side.
 	// Examples: a, b := ...   or   _, ipNet, err := ...
 
-	// Check if we have an identifier at current position
+	// Check if we have an identifier (or context-sensitive keyword) at current position
 	currentToken := p.peekToken()
-	if currentToken.Type != lexer.TOKEN_IDENTIFIER {
+	if currentToken.Type != lexer.TOKEN_IDENTIFIER && currentToken.Type != lexer.TOKEN_EMPTY && currentToken.Type != lexer.TOKEN_ERROR {
 		return false
 	}
 
@@ -745,7 +745,7 @@ func (p *Parser) checkMultiValueAssignment() bool {
 	// Consume (comma, identifier) pairs until we reach an assignment operator
 	for tok.Type == lexer.TOKEN_COMMA {
 		idx, tok = skipIgnored(idx + 1)
-		if tok.Type != lexer.TOKEN_IDENTIFIER {
+		if tok.Type != lexer.TOKEN_IDENTIFIER && tok.Type != lexer.TOKEN_EMPTY && tok.Type != lexer.TOKEN_ERROR {
 			return false // Comma must be followed by an identifier
 		}
 		idx, tok = skipIgnored(idx + 1)
@@ -760,8 +760,8 @@ func (p *Parser) parseMultiValueAssignmentStmt() ast.Statement {
 	var names []*ast.Identifier
 	var targets []ast.Expression
 
-	// Parse first identifier
-	if !p.match(lexer.TOKEN_IDENTIFIER) {
+	// Parse first identifier (also accept empty/error as identifiers)
+	if !p.match(lexer.TOKEN_IDENTIFIER, lexer.TOKEN_EMPTY, lexer.TOKEN_ERROR) {
 		p.error(p.peekToken(), "expected identifier in multi-value assignment")
 		return nil
 	}
@@ -775,7 +775,7 @@ func (p *Parser) parseMultiValueAssignmentStmt() ast.Statement {
 
 	// Parse additional identifiers separated by commas
 	for p.match(lexer.TOKEN_COMMA) {
-		if !p.match(lexer.TOKEN_IDENTIFIER) {
+		if !p.match(lexer.TOKEN_IDENTIFIER, lexer.TOKEN_EMPTY, lexer.TOKEN_ERROR) {
 			p.error(p.peekToken(), "expected identifier after comma in multi-value assignment")
 			return nil
 		}
diff --git a/internal/parser/parser_test.go b/internal/parser/parser_test.go
index 77c0636..2df67b0 100644
--- a/internal/parser/parser_test.go
+++ b/internal/parser/parser_test.go
@@ -1791,3 +1791,126 @@ func TestParseSelectStatement(t *testing.T) {
 		t.Fatal("expected otherwise branch")
 	}
 }
+
+func TestErrorAsVariableName(t *testing.T) {
+	input := `func Main()
+    error := 5
+`
+	p, err := New(input, "test.kuki")
+	if err != nil {
+		t.Fatalf("lexer error: %v", err)
+	}
+	program, errs := p.Parse()
+	if len(errs) > 0 {
+		t.Fatalf("expected no parse errors, got: %v", errs)
+	}
+
+	// Find the VarDeclStmt
+	fn := program.Declarations[0].(*ast.FunctionDecl)
+	varDecl, ok := fn.Body.Statements[0].(*ast.VarDeclStmt)
+	if !ok {
+		t.Fatalf("expected VarDeclStmt, got %T", fn.Body.Statements[0])
+	}
+	if varDecl.Names[0].Value != "error" {
+		t.Errorf("expected name 'error', got %q", varDecl.Names[0].Value)
+	}
+}
+
+func TestEmptyAsVariableName(t *testing.T) {
+	input := `func Main()
+    empty := 10
+`
+	p, err := New(input, "test.kuki")
+	if err != nil {
+		t.Fatalf("lexer error: %v", err)
+	}
+	program, errs := p.Parse()
+	if len(errs) > 0 {
+		t.Fatalf("expected no parse errors, got: %v", errs)
+	}
+
+	fn := program.Declarations[0].(*ast.FunctionDecl)
+	varDecl, ok := fn.Body.Statements[0].(*ast.VarDeclStmt)
+	if !ok {
+		t.Fatalf("expected VarDeclStmt, got %T", fn.Body.Statements[0])
+	}
+	if varDecl.Names[0].Value != "empty" {
+		t.Errorf("expected name 'empty', got %q", varDecl.Names[0].Value)
+	}
+}
+
+func TestMultiValueAssignmentWithError(t *testing.T) {
+	input := `func Main()
+    val, error := f()
+`
+	p, err := New(input, "test.kuki")
+	if err != nil {
+		t.Fatalf("lexer error: %v", err)
+	}
+	program, errs := p.Parse()
+	if len(errs) > 0 {
+		t.Fatalf("expected no parse errors, got: %v", errs)
+	}
+
+	fn := program.Declarations[0].(*ast.FunctionDecl)
+	varDecl, ok := fn.Body.Statements[0].(*ast.VarDeclStmt)
+	if !ok {
+		t.Fatalf("expected VarDeclStmt, got %T", fn.Body.Statements[0])
+	}
+	if len(varDecl.Names) != 2 {
+		t.Fatalf("expected 2 names, got %d", len(varDecl.Names))
+	}
+	if varDecl.Names[1].Value != "error" {
+		t.Errorf("expected second name 'error', got %q", varDecl.Names[1].Value)
+	}
+}
+
+func TestEmptyKeywordStillWorks(t *testing.T) {
+	input := `func Main()
+    x := empty string
+`
+	p, err := New(input, "test.kuki")
+	if err != nil {
+		t.Fatalf("lexer error: %v", err)
+	}
+	program, errs := p.Parse()
+	if len(errs) > 0 {
+		t.Fatalf("expected no parse errors, got: %v", errs)
+	}
+
+	fn := program.Declarations[0].(*ast.FunctionDecl)
+	varDecl, ok := fn.Body.Statements[0].(*ast.VarDeclStmt)
+	if !ok {
+		t.Fatalf("expected VarDeclStmt, got %T", fn.Body.Statements[0])
+	}
+	// The value should be an EmptyExpr (keyword), not an Identifier
+	_, ok = varDecl.Values[0].(*ast.EmptyExpr)
+	if !ok {
+		t.Fatalf("expected EmptyExpr (keyword), got %T", varDecl.Values[0])
+	}
+}
+
+func TestErrorKeywordStillWorks(t *testing.T) {
+	input := `func Main()
+    x := error "msg"
+`
+	p, err := New(input, "test.kuki")
+	if err != nil {
+		t.Fatalf("lexer error: %v", err)
+	}
+	program, errs := p.Parse()
+	if len(errs) > 0 {
+		t.Fatalf("expected no parse errors, got: %v", errs)
+	}
+
+	fn := program.Declarations[0].(*ast.FunctionDecl)
+	varDecl, ok := fn.Body.Statements[0].(*ast.VarDeclStmt)
+	if !ok {
+		t.Fatalf("expected VarDeclStmt, got %T", fn.Body.Statements[0])
+	}
+	// The value should be an ErrorExpr (keyword), not an Identifier
+	_, ok = varDecl.Values[0].(*ast.ErrorExpr)
+	if !ok {
+		t.Fatalf("expected ErrorExpr (keyword), got %T", varDecl.Values[0])
+	}
+}
diff --git a/stdlib/AGENTS.md b/stdlib/AGENTS.md
index 5eda97f..5f3ffd9 100644
--- a/stdlib/AGENTS.md
+++ b/stdlib/AGENTS.md
@@ -1,4 +1,4 @@
-# stdlib/AGENTS.md
+# stdlib/CLAUDE.md
 
 Kukicha standard library reference. Each package lives in `stdlib/<name>/` with:
 - `<name>.kuki` — Kukicha source (types, function signatures, inline implementations)
@@ -41,7 +41,7 @@ Import with: `import "stdlib/slice"`
 | `stdlib/retry` | Retry with backoff | New, Attempts, Delay, Sleep |
 | `stdlib/sandbox` | os.Root filesystem sandboxing | New, Read, Write, List, Exists, Delete |
 | `stdlib/shell` | Safe command execution | Run, Output, New/Dir/Env/Execute, Which, Getenv |
-| `stdlib/slice` | Slice operations | Filter, Map, GroupBy, GetOr, FirstOr, Find, Pop |
+| `stdlib/slice` | Slice operations (all generic) | Filter, Map, GroupBy, Get, Find, Unique, Contains, Pop, Shift |
 | `stdlib/string` | String utilities | Split, Join, Trim, Contains, Replace, ToUpper, ToLower |
 | `stdlib/template` | Text templating (plain + HTML-safe) | Execute, New, HTMLExecute, HTMLRenderSimple |
 | `stdlib/test` | Test assertion helpers (use in `*_test.kuki` only) | AssertEqual, AssertTrue, AssertFalse, AssertNoError, AssertError, AssertNotEmpty |
diff --git a/stdlib/CLAUDE.md b/stdlib/CLAUDE.md
index fae30e6..5f3ffd9 100644
--- a/stdlib/CLAUDE.md
+++ b/stdlib/CLAUDE.md
@@ -41,7 +41,7 @@ Import with: `import "stdlib/slice"`
 | `stdlib/retry` | Retry with backoff | New, Attempts, Delay, Sleep |
 | `stdlib/sandbox` | os.Root filesystem sandboxing | New, Read, Write, List, Exists, Delete |
 | `stdlib/shell` | Safe command execution | Run, Output, New/Dir/Env/Execute, Which, Getenv |
-| `stdlib/slice` | Slice operations | Filter, Map, GroupBy, GetOr, FirstOr, Find, Pop |
+| `stdlib/slice` | Slice operations (all generic) | Filter, Map, GroupBy, Get, Find, Unique, Contains, Pop, Shift |
 | `stdlib/string` | String utilities | Split, Join, Trim, Contains, Replace, ToUpper, ToLower |
 | `stdlib/template` | Text templating (plain + HTML-safe) | Execute, New, HTMLExecute, HTMLRenderSimple |
 | `stdlib/test` | Test assertion helpers (use in `*_test.kuki` only) | AssertEqual, AssertTrue, AssertFalse, AssertNoError, AssertError, AssertNotEmpty |
diff --git a/stdlib/cast/cast.go b/stdlib/cast/cast.go
index 5f8aa37..f6b20dd 100644
--- a/stdlib/cast/cast.go
+++ b/stdlib/cast/cast.go
@@ -87,13 +87,13 @@ func SmartFloat64(value any) (float64, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast.kuki:68
 		if v {
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast.kuki:69
-			return 1.000000, nil
+			return 1.0, nil
 		}
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast.kuki:70
-		return 0.000000, nil
+		return 0.0, nil
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast.kuki:71
-	return 0.000000, errors.New("cannot convert to float64")
+	return 0.0, errors.New("cannot convert to float64")
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast.kuki:75
@@ -108,7 +108,7 @@ func SmartBool(value any) (bool, error) {
 		return (v != 0), nil
 	case float64:
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast.kuki:82
-		return (v != 0.000000), nil
+		return (v != 0.0), nil
 	case string:
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast.kuki:84
 		b, err := strconv.ParseBool(v)
diff --git a/stdlib/cast/cast_test.go b/stdlib/cast/cast_test.go
index 88a19e2..5a8b6b7 100644
--- a/stdlib/cast/cast_test.go
+++ b/stdlib/cast/cast_test.go
@@ -30,7 +30,7 @@ func TestBasicParsers(t *testing.T) {
 		t.Fatalf("ParseFloat failed: %v", err2)
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast_test.kuki:20
-	if f == 0.000000 {
+	if f == 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast_test.kuki:21
 		t.Errorf("ParseFloat returned zero for valid input")
 	}
@@ -71,16 +71,16 @@ func TestSmartInt(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast_test.kuki:39
 func TestSmartFloat64(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast_test.kuki:40
-	val, err := cast.SmartFloat64(1.500000)
+	val, err := cast.SmartFloat64(1.5)
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast_test.kuki:41
-	if (err != nil) || (val != 1.500000) {
+	if (err != nil) || (val != 1.5) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast_test.kuki:42
 		t.Fatalf("SmartFloat64 failed for float64: %v", err)
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast_test.kuki:43
 	val2, err2 := cast.SmartFloat64("2.5")
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast_test.kuki:44
-	if (err2 != nil) || (val2 == 0.000000) {
+	if (err2 != nil) || (val2 == 0.0) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/cast/cast_test.kuki:45
 		t.Fatalf("SmartFloat64 failed for string: %v", err2)
 	}
diff --git a/stdlib/env/env.go b/stdlib/env/env.go
index 87c88c1..22188bc 100644
--- a/stdlib/env/env.go
+++ b/stdlib/env/env.go
@@ -149,14 +149,14 @@ func GetFloat(key string) (float64, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env.kuki:102
 	if value == "" {
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env.kuki:103
-		return 0.000000, errors.New(fmt.Sprintf("environment variable %v is not set", key))
+		return 0.0, errors.New(fmt.Sprintf("environment variable %v is not set", key))
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env.kuki:104
 	n, err := cast.ParseFloat(value, 64)
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env.kuki:105
 	if err != nil {
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env.kuki:106
-		return 0.000000, errors.New(fmt.Sprintf("environment variable %v is not a valid number: %v", key, value))
+		return 0.0, errors.New(fmt.Sprintf("environment variable %v is not a valid number: %v", key, value))
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env.kuki:107
 	return n, nil
@@ -176,7 +176,7 @@ func GetFloatOr(key string, defaultValue float64) (float64, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env.kuki:117
 	if err != nil {
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env.kuki:118
-		return 0.000000, errors.New(fmt.Sprintf("environment variable %v is not a valid number: %v", key, value))
+		return 0.0, errors.New(fmt.Sprintf("environment variable %v is not a valid number: %v", key, value))
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env.kuki:119
 	return n, nil
diff --git a/stdlib/env/env_test.go b/stdlib/env/env_test.go
index 564c5f3..e4f58c4 100644
--- a/stdlib/env/env_test.go
+++ b/stdlib/env/env_test.go
@@ -261,7 +261,7 @@ func TestGetFloat(t *testing.T) {
 		panic("get float failed")
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:157
-	test.AssertEqual(t, value, 3.140000)
+	test.AssertEqual(t, value, 3.14)
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:159
 	_, err := env.GetFloat("NONEXISTENT")
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:160
@@ -283,25 +283,25 @@ func TestGetFloatOr(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:170
 	defer cleanupTestEnv()
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:172
-	value, err_10 := env.GetFloatOr("TEST_FLOAT", 2.710000)
+	value, err_10 := env.GetFloatOr("TEST_FLOAT", 2.71)
 	if err_10 != nil {
 		panic("get float or failed")
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:173
-	test.AssertEqual(t, value, 3.140000)
+	test.AssertEqual(t, value, 3.14)
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:175
-	value2, err_11 := env.GetFloatOr("NONEXISTENT", 2.710000)
+	value2, err_11 := env.GetFloatOr("NONEXISTENT", 2.71)
 	if err_11 != nil {
 		panic("get float or failed")
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:176
-	test.AssertEqual(t, value2, 2.710000)
+	test.AssertEqual(t, value2, 2.71)
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:178
 	os.Setenv("TEST_INVALID_FLOAT", "not_a_number")
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:179
 	defer os.Unsetenv("TEST_INVALID_FLOAT")
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:180
-	_, err := env.GetFloatOr("TEST_INVALID_FLOAT", 2.710000)
+	_, err := env.GetFloatOr("TEST_INVALID_FLOAT", 2.71)
 //line /var/home/tluker/repos/go/kukicha/stdlib/env/env_test.kuki:181
 	test.AssertNotEmpty(t, err)
 }
diff --git a/stdlib/llm/llm.go b/stdlib/llm/llm.go
index 8610732..cd510a9 100644
--- a/stdlib/llm/llm.go
+++ b/stdlib/llm/llm.go
@@ -150,19 +150,19 @@ func New(model string) Client {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:248
 	c.tools = []Tool{}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:249
-	c.temperature = 0.000000
+	c.temperature = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:250
 	c.maxTokens = 0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:251
-	c.topP = 0.000000
+	c.topP = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:252
 	c.n = 0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:253
 	c.seed = 0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:254
-	c.presencePenalty = 0.000000
+	c.presencePenalty = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:255
-	c.frequencyPenalty = 0.000000
+	c.frequencyPenalty = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:258
 	if kukistring.Contains(model, ":") {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:259
@@ -621,7 +621,7 @@ func buildRequest(c Client) CompletionRequest {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:586
 	req.Messages = c.messages
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:588
-	if c.temperature != 0.000000 {
+	if c.temperature != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:589
 		req.Temperature = c.temperature
 	}
@@ -631,7 +631,7 @@ func buildRequest(c Client) CompletionRequest {
 		req.MaxTokens = c.maxTokens
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:592
-	if c.topP != 0.000000 {
+	if c.topP != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:593
 		req.TopP = c.topP
 	}
@@ -646,12 +646,12 @@ func buildRequest(c Client) CompletionRequest {
 		req.Seed = c.seed
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:598
-	if c.presencePenalty != 0.000000 {
+	if c.presencePenalty != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:599
 		req.PresencePenalty = c.presencePenalty
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:600
-	if c.frequencyPenalty != 0.000000 {
+	if c.frequencyPenalty != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:601
 		req.FrequencyPenalty = c.frequencyPenalty
 	}
@@ -998,15 +998,15 @@ func NewResponse(model string) ResponseClient {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:860
 	c.tools = []Tool{}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:861
-	c.temperature = 0.000000
+	c.temperature = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:862
-	c.topP = 0.000000
+	c.topP = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:863
 	c.maxOutputTokens = 0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:864
-	c.presencePenalty = 0.000000
+	c.presencePenalty = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:865
-	c.frequencyPenalty = 0.000000
+	c.frequencyPenalty = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:866
 	c.store = false
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:867
@@ -1573,12 +1573,12 @@ func rBuildRequest(c ResponseClient) ResponseRequest {
 		req.PreviousResponseID = c.previousResponseID
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1250
-	if c.temperature != 0.000000 {
+	if c.temperature != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1251
 		req.Temperature = c.temperature
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1252
-	if c.topP != 0.000000 {
+	if c.topP != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1253
 		req.TopP = c.topP
 	}
@@ -1588,12 +1588,12 @@ func rBuildRequest(c ResponseClient) ResponseRequest {
 		req.MaxOutputTokens = c.maxOutputTokens
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1256
-	if c.presencePenalty != 0.000000 {
+	if c.presencePenalty != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1257
 		req.PresencePenalty = c.presencePenalty
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1258
-	if c.frequencyPenalty != 0.000000 {
+	if c.frequencyPenalty != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1259
 		req.FrequencyPenalty = c.frequencyPenalty
 	}
@@ -1959,9 +1959,9 @@ func NewMessages(model string) MessagesClient {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1530
 	c.maxTokens = 1024
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1531
-	c.temperature = 0.000000
+	c.temperature = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1532
-	c.topP = 0.000000
+	c.topP = 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1533
 	c.topK = 0
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1534
@@ -2371,12 +2371,12 @@ func mBuildRequest(c MessagesClient) MessagesRequest {
 		req.System = c.system
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1844
-	if c.temperature != 0.000000 {
+	if c.temperature != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1845
 		req.Temperature = c.temperature
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1846
-	if c.topP != 0.000000 {
+	if c.topP != 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/llm/llm.kuki:1847
 		req.TopP = c.topP
 	}
diff --git a/stdlib/math/math_test.go b/stdlib/math/math_test.go
index 7443bbd..920b7cd 100644
--- a/stdlib/math/math_test.go
+++ b/stdlib/math/math_test.go
@@ -36,7 +36,7 @@ type ClampCase struct {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:31
 func TestAbs(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:37
-	cases := []FloatCase{FloatCase{name: "negative", val: -5.000000, want: 5.000000}, FloatCase{name: "positive", val: 5.000000, want: 5.000000}, FloatCase{name: "zero", val: 0.000000, want: 0.000000}, FloatCase{name: "small negative", val: -0.001000, want: 0.001000}}
+	cases := []FloatCase{FloatCase{name: "negative", val: -5.0, want: 5.0}, FloatCase{name: "positive", val: 5.0, want: 5.0}, FloatCase{name: "zero", val: 0.0, want: 0.0}, FloatCase{name: "small negative", val: -0.001, want: 0.001}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:38
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:39
@@ -52,7 +52,7 @@ func TestAbs(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:45
 func TestRound(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:52
-	cases := []FloatCase{FloatCase{name: "round up", val: 3.700000, want: 4.000000}, FloatCase{name: "round down", val: 3.200000, want: 3.000000}, FloatCase{name: "halfway up", val: 3.500000, want: 4.000000}, FloatCase{name: "negative halfway", val: -3.500000, want: -4.000000}, FloatCase{name: "zero", val: 0.000000, want: 0.000000}}
+	cases := []FloatCase{FloatCase{name: "round up", val: 3.7, want: 4.0}, FloatCase{name: "round down", val: 3.2, want: 3.0}, FloatCase{name: "halfway up", val: 3.5, want: 4.0}, FloatCase{name: "negative halfway", val: -3.5, want: -4.0}, FloatCase{name: "zero", val: 0.0, want: 0.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:53
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:54
@@ -68,7 +68,7 @@ func TestRound(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:60
 func TestFloor(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:66
-	cases := []FloatCase{FloatCase{name: "fractional", val: 3.900000, want: 3.000000}, FloatCase{name: "whole", val: 3.000000, want: 3.000000}, FloatCase{name: "negative fractional", val: -1.100000, want: -2.000000}, FloatCase{name: "negative whole", val: -1.000000, want: -1.000000}}
+	cases := []FloatCase{FloatCase{name: "fractional", val: 3.9, want: 3.0}, FloatCase{name: "whole", val: 3.0, want: 3.0}, FloatCase{name: "negative fractional", val: -1.1, want: -2.0}, FloatCase{name: "negative whole", val: -1.0, want: -1.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:67
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:68
@@ -84,7 +84,7 @@ func TestFloor(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:74
 func TestCeil(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:80
-	cases := []FloatCase{FloatCase{name: "fractional", val: 3.100000, want: 4.000000}, FloatCase{name: "whole", val: 3.000000, want: 3.000000}, FloatCase{name: "negative fractional", val: -1.900000, want: -1.000000}, FloatCase{name: "negative whole", val: -1.000000, want: -1.000000}}
+	cases := []FloatCase{FloatCase{name: "fractional", val: 3.1, want: 4.0}, FloatCase{name: "whole", val: 3.0, want: 3.0}, FloatCase{name: "negative fractional", val: -1.9, want: -1.0}, FloatCase{name: "negative whole", val: -1.0, want: -1.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:81
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:82
@@ -100,7 +100,7 @@ func TestCeil(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:88
 func TestSqrt(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:94
-	cases := []FloatCase{FloatCase{name: "nine", val: 9.000000, want: 3.000000}, FloatCase{name: "zero", val: 0.000000, want: 0.000000}, FloatCase{name: "one", val: 1.000000, want: 1.000000}, FloatCase{name: "four", val: 4.000000, want: 2.000000}}
+	cases := []FloatCase{FloatCase{name: "nine", val: 9.0, want: 3.0}, FloatCase{name: "zero", val: 0.0, want: 0.0}, FloatCase{name: "one", val: 1.0, want: 1.0}, FloatCase{name: "four", val: 4.0, want: 2.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:95
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:96
@@ -114,9 +114,9 @@ func TestSqrt(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:101
 	t.Run("sqrt 2 approx", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:102
-		result := math.Sqrt(2.000000)
+		result := math.Sqrt(2.0)
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:103
-		if (result < 1.410000) || (result > 1.420000) {
+		if (result < 1.41) || (result > 1.42) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:104
 			t.Errorf("Expected Sqrt(2.0) ≈ 1.41421, got %v", result)
 		}
@@ -126,7 +126,7 @@ func TestSqrt(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:108
 func TestMinMax(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:113
-	cases := []FloatPairCase{FloatPairCase{name: "min smaller first", a: 3.000000, b: 7.000000, want: 3.000000}, FloatPairCase{name: "min larger first", a: 7.000000, b: 3.000000, want: 3.000000}, FloatPairCase{name: "min equal", a: 5.000000, b: 5.000000, want: 5.000000}}
+	cases := []FloatPairCase{FloatPairCase{name: "min smaller first", a: 3.0, b: 7.0, want: 3.0}, FloatPairCase{name: "min larger first", a: 7.0, b: 3.0, want: 3.0}, FloatPairCase{name: "min equal", a: 5.0, b: 5.0, want: 5.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:114
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:115
@@ -138,7 +138,7 @@ func TestMinMax(t *testing.T) {
 		})
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:124
-	maxCases := []FloatPairCase{FloatPairCase{name: "max smaller first", a: 3.000000, b: 7.000000, want: 7.000000}, FloatPairCase{name: "max larger first", a: 7.000000, b: 3.000000, want: 7.000000}, FloatPairCase{name: "max equal", a: 5.000000, b: 5.000000, want: 5.000000}}
+	maxCases := []FloatPairCase{FloatPairCase{name: "max smaller first", a: 3.0, b: 7.0, want: 7.0}, FloatPairCase{name: "max larger first", a: 7.0, b: 3.0, want: 7.0}, FloatPairCase{name: "max equal", a: 5.0, b: 5.0, want: 5.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:125
 	for _, tc := range maxCases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:126
@@ -154,7 +154,7 @@ func TestMinMax(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:132
 func TestPow(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:138
-	cases := []FloatPairCase{FloatPairCase{name: "2^8", a: 2.000000, b: 8.000000, want: 256.000000}, FloatPairCase{name: "3^3", a: 3.000000, b: 3.000000, want: 27.000000}, FloatPairCase{name: "5^0", a: 5.000000, b: 0.000000, want: 1.000000}, FloatPairCase{name: "1^100", a: 1.000000, b: 100.000000, want: 1.000000}}
+	cases := []FloatPairCase{FloatPairCase{name: "2^8", a: 2.0, b: 8.0, want: 256.0}, FloatPairCase{name: "3^3", a: 3.0, b: 3.0, want: 27.0}, FloatPairCase{name: "5^0", a: 5.0, b: 0.0, want: 1.0}, FloatPairCase{name: "1^100", a: 1.0, b: 100.0, want: 1.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:139
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:140
@@ -172,7 +172,7 @@ func TestLog(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:147
 	t.Run("log 1 equals 0", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:148
-		test.AssertEqual(t, math.Log(1.000000), 0.000000)
+		test.AssertEqual(t, math.Log(1.0), 0.0)
 	})
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:150
 	t.Run("log E approx 1", func(t *testing.T) {
@@ -181,7 +181,7 @@ func TestLog(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:152
 		result := math.Log(e)
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:153
-		if (result < 0.990000) || (result > 1.010000) {
+		if (result < 0.99) || (result > 1.01) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:154
 			t.Errorf("Expected Log(E) ≈ 1.0, got %v", result)
 		}
@@ -191,7 +191,7 @@ func TestLog(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:158
 func TestLog2(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:163
-	cases := []FloatCase{FloatCase{name: "log2(1)", val: 1.000000, want: 0.000000}, FloatCase{name: "log2(2)", val: 2.000000, want: 1.000000}, FloatCase{name: "log2(8)", val: 8.000000, want: 3.000000}}
+	cases := []FloatCase{FloatCase{name: "log2(1)", val: 1.0, want: 0.0}, FloatCase{name: "log2(2)", val: 2.0, want: 1.0}, FloatCase{name: "log2(8)", val: 8.0, want: 3.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:164
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:165
@@ -207,7 +207,7 @@ func TestLog2(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:171
 func TestLog10(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:176
-	cases := []FloatCase{FloatCase{name: "log10(1)", val: 1.000000, want: 0.000000}, FloatCase{name: "log10(10)", val: 10.000000, want: 1.000000}, FloatCase{name: "log10(1000)", val: 1000.000000, want: 3.000000}}
+	cases := []FloatCase{FloatCase{name: "log10(1)", val: 1.0, want: 0.0}, FloatCase{name: "log10(10)", val: 10.0, want: 1.0}, FloatCase{name: "log10(1000)", val: 1000.0, want: 3.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:177
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:178
@@ -227,7 +227,7 @@ func TestConstants(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:186
 		pi := math.Pi()
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:187
-		if (pi < 3.140000) || (pi > 3.150000) {
+		if (pi < 3.14) || (pi > 3.15) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:188
 			t.Errorf("Expected Pi ≈ 3.14159, got %v", pi)
 		}
@@ -237,7 +237,7 @@ func TestConstants(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:191
 		e := math.E()
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:192
-		if (e < 2.710000) || (e > 2.720000) {
+		if (e < 2.71) || (e > 2.72) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:193
 			t.Errorf("Expected E ≈ 2.71828, got %v", e)
 		}
@@ -259,7 +259,7 @@ func TestConstants(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:203
 func TestClamp(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:212
-	cases := []ClampCase{ClampCase{name: "within range", val: 5.000000, lo: 0.000000, hi: 10.000000, want: 5.000000}, ClampCase{name: "below min", val: -5.000000, lo: 0.000000, hi: 10.000000, want: 0.000000}, ClampCase{name: "above max", val: 15.000000, lo: 0.000000, hi: 10.000000, want: 10.000000}, ClampCase{name: "at lower boundary", val: 0.000000, lo: 0.000000, hi: 10.000000, want: 0.000000}, ClampCase{name: "at upper boundary", val: 10.000000, lo: 0.000000, hi: 10.000000, want: 10.000000}, ClampCase{name: "negative range clamped high", val: 0.000000, lo: -10.000000, hi: -1.000000, want: -1.000000}, ClampCase{name: "negative range clamped low", val: -20.000000, lo: -10.000000, hi: -1.000000, want: -10.000000}}
+	cases := []ClampCase{ClampCase{name: "within range", val: 5.0, lo: 0.0, hi: 10.0, want: 5.0}, ClampCase{name: "below min", val: -5.0, lo: 0.0, hi: 10.0, want: 0.0}, ClampCase{name: "above max", val: 15.0, lo: 0.0, hi: 10.0, want: 10.0}, ClampCase{name: "at lower boundary", val: 0.0, lo: 0.0, hi: 10.0, want: 0.0}, ClampCase{name: "at upper boundary", val: 10.0, lo: 0.0, hi: 10.0, want: 10.0}, ClampCase{name: "negative range clamped high", val: 0.0, lo: -10.0, hi: -1.0, want: -1.0}, ClampCase{name: "negative range clamped low", val: -20.0, lo: -10.0, hi: -1.0, want: -10.0}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:213
 	for _, tc := range cases {
 //line /var/home/tluker/repos/go/kukicha/stdlib/math/math_test.kuki:214
diff --git a/stdlib/pg/pg.go b/stdlib/pg/pg.go
index 905b993..25bd897 100644
--- a/stdlib/pg/pg.go
+++ b/stdlib/pg/pg.go
@@ -316,13 +316,13 @@ func ScanFloat64(r Row) (float64, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/pg/pg.kuki:208
 	row := r.scanFn.(pgx.Row)
 //line /var/home/tluker/repos/go/kukicha/stdlib/pg/pg.kuki:209
-	v := 0.000000
+	v := 0.0
 //line /var/home/tluker/repos/go/kukicha/stdlib/pg/pg.kuki:210
 	err := row.Scan(&v)
 //line /var/home/tluker/repos/go/kukicha/stdlib/pg/pg.kuki:211
 	if err != nil {
 //line /var/home/tluker/repos/go/kukicha/stdlib/pg/pg.kuki:212
-		return 0.000000, kukierrors.Wrap(err, "pg scan float64")
+		return 0.0, kukierrors.Wrap(err, "pg scan float64")
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/pg/pg.kuki:213
 	return v, nil
diff --git a/stdlib/slice/slice.go b/stdlib/slice/slice.go
index 9c9ff78..a152c3c 100644
--- a/stdlib/slice/slice.go
+++ b/stdlib/slice/slice.go
@@ -87,16 +87,16 @@ func Reverse[T any](items []T) []T {
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:56
-func Unique(items []any) []any {
+func Unique[K comparable](items []K) []K {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:57
 	if len(items) == 0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:58
 		return items
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:60
-	seen := make(map[any]bool)
+	seen := make(map[K]bool)
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:61
-	result := make([]any, 0)
+	result := make([]K, 0)
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:63
 	for _, item := range items {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:64
@@ -140,13 +140,13 @@ func Chunk[T any](items []T, size int) [][]T {
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:90
-func Contains(items []any, value any) bool {
+func Contains[K comparable](items []K, value K) bool {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:91
 	return slices.Contains(items, value)
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:96
-func IndexOf(items []any, value any) int {
+func IndexOf[K comparable](items []K, value K) int {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:97
 	return slices.Index(items, value)
 }
@@ -219,13 +219,13 @@ func GroupBy[T any, K comparable](items []T, keyFunc func(T) K) map[K][]T {
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:150
-func Get(items []any, index int) (any, error) {
+func Get[T any](items []T, index int) (T, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:151
 	length := len(items)
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:152
 	if length == 0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:153
-		return nil, errors.New("slice is empty")
+		return *new(T), errors.New("slice is empty")
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:156
 	actualIndex := index
@@ -237,7 +237,7 @@ func Get(items []any, index int) (any, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:160
 	if (actualIndex < 0) || (actualIndex >= length) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:161
-		return nil, errors.New(fmt.Sprintf("index %v out of bounds for slice of length %v", index, length))
+		return *new(T), errors.New(fmt.Sprintf("index %v out of bounds for slice of length %v", index, length))
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:163
 	return items[actualIndex], nil
@@ -269,11 +269,11 @@ func GetOr[T any](items []T, index int, defaultValue T) T {
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:186
-func FirstOne(items []any) (any, error) {
+func FirstOne[T any](items []T) (T, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:187
 	if len(items) == 0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:188
-		return nil, errors.New("slice is empty")
+		return *new(T), errors.New("slice is empty")
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:189
 	return items[0], nil
@@ -291,11 +291,11 @@ func FirstOr[T any](items []T, defaultValue T) T {
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:201
-func LastOne(items []any) (any, error) {
+func LastOne[T any](items []T) (T, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:202
 	if len(items) == 0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:203
-		return nil, errors.New("slice is empty")
+		return *new(T), errors.New("slice is empty")
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:204
 	return items[(len(items) - 1)], nil
@@ -313,7 +313,7 @@ func LastOr[T any](items []T, defaultValue T) T {
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:216
-func Find(items []any, predicate func(any) bool) (any, error) {
+func Find[T any](items []T, predicate func(T) bool) (T, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:217
 	for _, item := range items {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:218
@@ -323,7 +323,7 @@ func Find(items []any, predicate func(any) bool) (any, error) {
 		}
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:220
-	return nil, errors.New("no matching element found")
+	return *new(T), errors.New("no matching element found")
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:225
@@ -355,7 +355,7 @@ func FindIndex[T any](items []T, predicate func(T) bool) int {
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:242
-func FindLast(items []any, predicate func(any) bool) (any, error) {
+func FindLast[T any](items []T, predicate func(T) bool) (T, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:243
 	for i := (len(items) - 1); i <= 0; i++ {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:244
@@ -365,7 +365,7 @@ func FindLast(items []any, predicate func(any) bool) (any, error) {
 		}
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:246
-	return nil, errors.New("no matching element found")
+	return *new(T), errors.New("no matching element found")
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:250
@@ -395,22 +395,22 @@ func IsNotEmpty[T any](items []T) bool {
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:269
-func Pop(items []any) (any, []any, error) {
+func Pop[T any](items []T) (T, []T, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:270
 	if len(items) == 0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:271
-		return nil, items, errors.New("cannot pop from empty slice")
+		return *new(T), items, errors.New("cannot pop from empty slice")
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:272
 	return items[(len(items) - 1)], items[:(len(items) - 1)], nil
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:277
-func Shift(items []any) (any, []any, error) {
+func Shift[T any](items []T) (T, []T, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:278
 	if len(items) == 0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:279
-		return nil, items, errors.New("cannot shift from empty slice")
+		return *new(T), items, errors.New("cannot shift from empty slice")
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice.kuki:280
 	return items[0], items[1:], nil
diff --git a/stdlib/slice/slice.kuki b/stdlib/slice/slice.kuki
index 6672dd2..1a34d43 100644
--- a/stdlib/slice/slice.kuki
+++ b/stdlib/slice/slice.kuki
@@ -53,12 +53,12 @@ func Reverse(items list of any) list of any
 # Unique returns a new slice with duplicate elements removed
 # Preserves the order of first occurrence
 # Note: Elements must be comparable
-func Unique(items list of any) list of any
+func Unique(items list of any2) list of any2
     if len(items) == 0
         return items
 
-    seen := make(map of any to bool)
-    result := make(list of any, 0)
+    seen := make(map of any2 to bool)
+    result := make(list of any2, 0)
 
     for item in items
         if not seen[item]
@@ -87,13 +87,13 @@ func Chunk(items list of any, size int) list of list of any
 
 # Contains checks if a slice contains the specified value
 # Wraps Go's slices.Contains for convenience
-func Contains(items list of any, value any) bool
+func Contains(items list of any2, value any2) bool
     return slices.Contains(items, value)
 
 # IndexOf returns the index of the first occurrence of value in the slice
 # Returns -1 if the value is not found
 # Wraps Go's slices.Index for convenience
-func IndexOf(items list of any, value any) int
+func IndexOf(items list of any2, value any2) int
     return slices.Index(items, value)
 
 # Concat concatenates multiple slices into a single slice
diff --git a/stdlib/slice/slice_test.go b/stdlib/slice/slice_test.go
index 12be2ce..93fc5e4 100644
--- a/stdlib/slice/slice_test.go
+++ b/stdlib/slice/slice_test.go
@@ -149,7 +149,7 @@ func TestReverse(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:107
 func TestUnique(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:108
-	items := []any{"a", "b", "a", "c", "b", "d"}
+	items := []string{"a", "b", "a", "c", "b", "d"}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:109
 	result := slice.Unique(items)
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:111
@@ -173,14 +173,14 @@ func TestUnique(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:122
 type ContainsCase struct {
 	name   string
-	needle any
+	needle string
 	want   bool
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:128
 func TestContains(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:129
-	items := []any{"apple", "banana", "cherry"}
+	items := []string{"apple", "banana", "cherry"}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:133
 	cases := []ContainsCase{ContainsCase{name: "banana present", needle: "banana", want: true}, ContainsCase{name: "grape absent", needle: "grape", want: false}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:134
@@ -196,14 +196,14 @@ func TestContains(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:140
 type IndexOfCase struct {
 	name   string
-	needle any
+	needle string
 	want   int
 }
 
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:146
 func TestIndexOf(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:147
-	items := []any{"a", "b", "c"}
+	items := []string{"a", "b", "c"}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:152
 	cases := []IndexOfCase{IndexOfCase{name: "b at 1", needle: "b", want: 1}, IndexOfCase{name: "a at 0", needle: "a", want: 0}, IndexOfCase{name: "z not found", needle: "z", want: -1}}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:153
@@ -247,7 +247,7 @@ func TestIsEmptyIsNotEmpty(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:177
 func TestGet(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:178
-	items := []any{"a", "b", "c"}
+	items := []string{"a", "b", "c"}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:180
 	t.Run("valid index", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:181
@@ -276,7 +276,7 @@ func TestGet(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:194
 	t.Run("empty slice returns error", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:195
-		emptySlice := []any{}
+		emptySlice := []string{}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:196
 		_, emptyErr := slice.Get(emptySlice, 0)
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:197
@@ -343,9 +343,9 @@ func TestFirstOrLastOr(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:237
 func TestFirstOneLastOne(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:238
-	items := []any{"x", "y", "z"}
+	items := []string{"x", "y", "z"}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:239
-	emptySlice := []any{}
+	emptySlice := []string{}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:241
 	t.Run("FirstOne/non-empty", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:242
@@ -445,11 +445,11 @@ func TestFindIndex(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:301
 func TestFind(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:302
-	items := []any{"apple", "banana", "cherry"}
+	items := []string{"apple", "banana", "cherry"}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:304
 	t.Run("found element", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:305
-		val, err := slice.Find(items, func(v any) bool { return (v == "banana") })
+		val, err := slice.Find(items, func(v string) bool { return (v == "banana") })
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:306
 		test.AssertNoError(t, err)
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:307
@@ -458,7 +458,7 @@ func TestFind(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:309
 	t.Run("not found returns error", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:310
-		_, err := slice.Find(items, func(v any) bool { return (v == "grape") })
+		_, err := slice.Find(items, func(v string) bool { return (v == "grape") })
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:311
 		test.AssertError(t, err)
 	})
@@ -487,7 +487,7 @@ func TestFindOr(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:328
 func TestPop(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:329
-	items := []any{"a", "b", "c"}
+	items := []string{"a", "b", "c"}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:331
 	t.Run("pops last element", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:332
@@ -504,7 +504,7 @@ func TestPop(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:338
 	t.Run("empty slice returns error", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:339
-		emptySlice := []any{}
+		emptySlice := []string{}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:340
 		_, _, err := slice.Pop(emptySlice)
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:341
@@ -515,7 +515,7 @@ func TestPop(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:345
 func TestShift(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:346
-	items := []any{"a", "b", "c"}
+	items := []string{"a", "b", "c"}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:348
 	t.Run("shifts first element", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:349
@@ -532,7 +532,7 @@ func TestShift(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:355
 	t.Run("empty slice returns error", func(t *testing.T) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:356
-		emptySlice := []any{}
+		emptySlice := []string{}
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:357
 		_, _, err := slice.Shift(emptySlice)
 //line /var/home/tluker/repos/go/kukicha/stdlib/slice/slice_test.kuki:358
diff --git a/stdlib/slice/slice_test.kuki b/stdlib/slice/slice_test.kuki
index 3b2428f..03ea2ce 100644
--- a/stdlib/slice/slice_test.kuki
+++ b/stdlib/slice/slice_test.kuki
@@ -105,7 +105,7 @@ func TestReverse(t reference testing.T)
 
 # --- TestUnique ---
 func TestUnique(t reference testing.T)
-    items := list of any{"a", "b", "a", "c", "b", "d"}
+    items := list of string{"a", "b", "a", "c", "b", "d"}
     result := slice.Unique(items)
 
     t.Run("removes duplicates", (t reference testing.T) =>
@@ -121,12 +121,12 @@ func TestUnique(t reference testing.T)
 # --- ContainsCase ---
 type ContainsCase
     name   string
-    needle any
+    needle string
     want   bool
 
 # --- TestContains ---
 func TestContains(t reference testing.T)
-    items := list of any{"apple", "banana", "cherry"}
+    items := list of string{"apple", "banana", "cherry"}
     cases := list of ContainsCase{
         ContainsCase{name: "banana present", needle: "banana", want: true},
         ContainsCase{name: "grape absent", needle: "grape", want: false},
@@ -139,12 +139,12 @@ func TestContains(t reference testing.T)
 # --- IndexOfCase ---
 type IndexOfCase
     name   string
-    needle any
+    needle string
     want   int
 
 # --- TestIndexOf ---
 func TestIndexOf(t reference testing.T)
-    items := list of any{"a", "b", "c"}
+    items := list of string{"a", "b", "c"}
     cases := list of IndexOfCase{
         IndexOfCase{name: "b at 1", needle: "b", want: 1},
         IndexOfCase{name: "a at 0", needle: "a", want: 0},
@@ -175,7 +175,7 @@ func TestIsEmptyIsNotEmpty(t reference testing.T)
 
 # --- TestGet ---
 func TestGet(t reference testing.T)
-    items := list of any{"a", "b", "c"}
+    items := list of string{"a", "b", "c"}
 
     t.Run("valid index", (t reference testing.T) =>
         val, err := slice.Get(items, 1)
@@ -192,7 +192,7 @@ func TestGet(t reference testing.T)
         test.AssertError(t, outErr)
     )
     t.Run("empty slice returns error", (t reference testing.T) =>
-        emptySlice := list of any{}
+        emptySlice := list of string{}
         _, emptyErr := slice.Get(emptySlice, 0)
         test.AssertError(t, emptyErr)
     )
@@ -235,8 +235,8 @@ func TestFirstOrLastOr(t reference testing.T)
 
 # --- TestFirstOneLastOne ---
 func TestFirstOneLastOne(t reference testing.T)
-    items := list of any{"x", "y", "z"}
-    emptySlice := list of any{}
+    items := list of string{"x", "y", "z"}
+    emptySlice := list of string{}
 
     t.Run("FirstOne/non-empty", (t reference testing.T) =>
         first, err := slice.FirstOne(items)
@@ -299,15 +299,15 @@ func TestFindIndex(t reference testing.T)
 
 # --- TestFind ---
 func TestFind(t reference testing.T)
-    items := list of any{"apple", "banana", "cherry"}
+    items := list of string{"apple", "banana", "cherry"}
 
     t.Run("found element", (t reference testing.T) =>
-        val, err := slice.Find(items, (v any) => v == "banana")
+        val, err := slice.Find(items, (v string) => v == "banana")
         test.AssertNoError(t, err)
         test.AssertEqual(t, val, "banana")
     )
     t.Run("not found returns error", (t reference testing.T) =>
-        _, err := slice.Find(items, (v any) => v == "grape")
+        _, err := slice.Find(items, (v string) => v == "grape")
         test.AssertError(t, err)
     )
 
@@ -326,7 +326,7 @@ func TestFindOr(t reference testing.T)
 
 # --- TestPop ---
 func TestPop(t reference testing.T)
-    items := list of any{"a", "b", "c"}
+    items := list of string{"a", "b", "c"}
 
     t.Run("pops last element", (t reference testing.T) =>
         last, rest, err := slice.Pop(items)
@@ -336,14 +336,14 @@ func TestPop(t reference testing.T)
         test.AssertEqual(t, rest[0], "a")
     )
     t.Run("empty slice returns error", (t reference testing.T) =>
-        emptySlice := list of any{}
+        emptySlice := list of string{}
         _, _, err := slice.Pop(emptySlice)
         test.AssertError(t, err)
     )
 
 # --- TestShift ---
 func TestShift(t reference testing.T)
-    items := list of any{"a", "b", "c"}
+    items := list of string{"a", "b", "c"}
 
     t.Run("shifts first element", (t reference testing.T) =>
         first, rest, err := slice.Shift(items)
@@ -353,7 +353,7 @@ func TestShift(t reference testing.T)
         test.AssertEqual(t, rest[0], "b")
     )
     t.Run("empty slice returns error", (t reference testing.T) =>
-        emptySlice := list of any{}
+        emptySlice := list of string{}
         _, _, err := slice.Shift(emptySlice)
         test.AssertError(t, err)
     )
diff --git a/stdlib/validate/validate.go b/stdlib/validate/validate.go
index 2e49e27..bd49fb8 100644
--- a/stdlib/validate/validate.go
+++ b/stdlib/validate/validate.go
@@ -301,7 +301,7 @@ func Max(n int, max int) (int, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/validate/validate.kuki:199
 func PositiveFloat(n float64) (float64, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/validate/validate.kuki:200
-	if n <= 0.000000 {
+	if n <= 0.0 {
 //line /var/home/tluker/repos/go/kukicha/stdlib/validate/validate.kuki:201
 		return n, errors.New("value must be positive")
 	}
@@ -358,7 +358,7 @@ func ParseFloat(s string) (float64, error) {
 //line /var/home/tluker/repos/go/kukicha/stdlib/validate/validate.kuki:235
 	if err != nil {
 //line /var/home/tluker/repos/go/kukicha/stdlib/validate/validate.kuki:236
-		return 0.000000, errors.New(fmt.Sprintf("invalid number: %v", s))
+		return 0.0, errors.New(fmt.Sprintf("invalid number: %v", s))
 	}
 //line /var/home/tluker/repos/go/kukicha/stdlib/validate/validate.kuki:237
 	return n, nil
