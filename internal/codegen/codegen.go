package codegen

import (
	"fmt"
	"regexp"
	"sort"
	"strings"

	"github.com/duber000/kukicha/internal/ast"
	"github.com/duber000/kukicha/internal/version"
)

// TypeParameter represents a type parameter for stdlib special transpilation
// This is internal to codegen and separate from the removed ast.TypeParameter
type TypeParameter struct {
	Name        string // Generated name: T, U, V, etc.
	Placeholder string // Original placeholder: "any", "any2", etc.
	Constraint  string // "any", "comparable", "cmp.Ordered"
}

// Generator generates Go code from an AST.
//
// ARCHITECTURE NOTE: Kukicha uses placeholders like "any" and "any2" in stdlib
// function signatures to represent generic type parameters. When generating Go code,
// we detect these placeholders and emit proper Go generics (e.g., [T any, K comparable]).
// This allows Kukicha users to write simple code while getting type-safe Go generics.
//
// The isStdlibIter and placeholderMap fields work together:
//   - isStdlibIter is true when generating stdlib/iterator or stdlib/slice code
//   - placeholderMap maps Kukicha placeholders ("any", "any2") to Go type params ("T", "K")
//   - During type annotation generation, we substitute placeholders with type params
//
// This design keeps Kukicha's "beginner-friendly" goal: users don't write generic syntax,
// but the generated Go code is fully type-safe with proper generic constraints.
// FuncDefaults stores information about a function's default parameter values
type FuncDefaults struct {
	ParamNames    []string         // Parameter names in order
	DefaultValues []ast.Expression // Default values (nil if no default)
	HasVariadic   bool             // Whether the last parameter is variadic
}

type Generator struct {
	program              *ast.Program
	output               strings.Builder
	indent               int
	placeholderMap       map[string]string        // Maps placeholder names to type param names (e.g., "any" -> "T", "any2" -> "K")
	autoImports          map[string]bool          // Tracks auto-imports needed (e.g., "cmp" for generic constraints)
	pkgAliases           map[string]string        // Maps original package name -> alias when collision detected (e.g., "json" -> "kukijson")
	funcDefaults         map[string]*FuncDefaults // Maps function names to their default parameter info
	isStdlibIter         bool                     // True if generating stdlib/iterator or stdlib/slice code (enables generic transpilation)
	sourceFile           string                   // Source file path for detecting stdlib
	currentFuncName      string                   // Current function being generated (for context-aware decisions)
	currentReturnTypes   []ast.TypeAnnotation     // Return types of current function (for type coercion in returns)
	processingReturnType bool                     // Whether we are currently generating return types
	tempCounter          int                      // Counter for generating unique temporary variable names
	exprReturnCounts     map[ast.Expression]int   // Semantic return counts passed from analyzer
	mcpTarget            bool                     // True if targeting MCP (Model Context Protocol)
}

// New creates a new code generator
func New(program *ast.Program) *Generator {
	return &Generator{
		program:      program,
		indent:       0,
		autoImports:  make(map[string]bool),
		pkgAliases:   make(map[string]string),
		funcDefaults: make(map[string]*FuncDefaults),
	}
}

// SetSourceFile sets the source file path and detects if special transpilation is needed
func (g *Generator) SetSourceFile(path string) {
	g.sourceFile = path
	// Enable special transpilation for stdlib/iterator files
	g.isStdlibIter = strings.Contains(path, "stdlib/iterator/") || strings.Contains(path, "stdlib\\iterator\\")
	// Note: stdlib/slice uses a different approach - type parameters are detected per-function
}

// SetExprReturnCounts passes semantic analysis return counts to the generator.
func (g *Generator) SetExprReturnCounts(counts map[ast.Expression]int) {
	g.exprReturnCounts = counts
}

// SetMCPTarget enables special codegen for MCP servers (e.g., print to stderr)
func (g *Generator) SetMCPTarget(v bool) {
	g.mcpTarget = v
}

// addImport adds an auto-import
func (g *Generator) addImport(path string) {
	g.autoImports[path] = true
}

// Generate generates Go code from the AST
func (g *Generator) Generate() (string, error) {
	g.output.Reset()

	// Generate comment about Go 1.26+ optimization options
	g.writeLine(fmt.Sprintf("// Generated by Kukicha v%s (requires Go 1.26+)", version.Version))
	g.writeLine("//")
	g.writeLine("// Performance: GOEXPERIMENT=jsonv2 enables faster JSON parsing (2-10x improvement)")
	g.writeLine("")

	// Generate package declaration
	g.generatePackage()

	// Pre-scan for auto-imports (e.g. net/http for fetch wrappers)
	g.scanForAutoImports()

	// Pre-scan for function defaults (needed for named arguments and default parameter values)
	g.scanForFunctionDefaults()

	// Generate imports (including auto-imports like fmt for string interpolation and print builtin)
	needsFmt := g.needsStringInterpolation() || g.needsPrintBuiltin()
	if len(g.program.Imports) > 0 || needsFmt || len(g.autoImports) > 0 {
		g.writeLine("")
		g.generateImports()
	}

	// Generate declarations
	for _, decl := range g.program.Declarations {
		g.writeLine("")
		g.generateDeclaration(decl)
	}

	return g.output.String(), nil
}

func (g *Generator) generatePackage() {
	packageName := "main"
	if g.program.PetioleDecl != nil {
		packageName = g.program.PetioleDecl.Name.Value
	}
	g.writeLine(fmt.Sprintf("package %s", packageName))
}

func (g *Generator) generateImports() {
	// Collect all imports
	imports := make(map[string]string) // path -> alias

	for _, imp := range g.program.Imports {
		path := imp.Path.Value
		alias := ""
		if imp.Alias != nil {
			alias = imp.Alias.Value
		}

		// Rewrite stdlib imports to full module path
		path = g.rewriteStdlibImport(path)

		imports[path] = alias
	}

	// Check if we need fmt for string interpolation or print builtin
	needsFmt := g.needsStringInterpolation() || g.needsPrintBuiltin()
	if needsFmt {
		imports["fmt"] = ""
	}

	// Check if we need os for MCP target (printbuiltin uses os.Stderr)
	if g.mcpTarget && g.needsPrintBuiltin() {
		imports["os"] = ""
	}

	// Check if we need errors for error expressions
	needsErrors := g.needsErrorsPackage()
	if needsErrors {
		imports["errors"] = ""
	}

	// Add auto-imports (e.g., cmp for generic constraints)
	for path := range g.autoImports {
		if _, exists := imports[path]; !exists {
			imports[path] = ""
		}
	}

	// Detect package name collisions between Kukicha stdlib imports and Go imports.
	// If two imports resolve to the same Go package name (e.g., stdlib/json and encoding/json
	// both resolve to "json"), auto-alias the Kukicha stdlib import to prevent Go compile errors.
	pkgNameToPath := make(map[string][]string)
	for path, alias := range imports {
		effectiveName := alias
		if effectiveName == "" {
			effectiveName = extractPkgName(path)
		}
		pkgNameToPath[effectiveName] = append(pkgNameToPath[effectiveName], path)
	}
	kukichaStdlibPrefix := "github.com/duber000/kukicha/stdlib/"
	for pkgName, paths := range pkgNameToPath {
		if len(paths) <= 1 {
			continue
		}
		for _, path := range paths {
			if strings.HasPrefix(path, kukichaStdlibPrefix) && imports[path] == "" {
				aliased := "kuki" + pkgName
				imports[path] = aliased
				g.pkgAliases[pkgName] = aliased
			}
		}
	}

	// Auto-alias imports that collide with Go built-in types or keywords.
	// e.g., stdlib/string -> kukistring (because "string" is a Go built-in type)
	goBuiltins := map[string]bool{
		"string": true, "int": true, "int8": true, "int16": true, "int32": true, "int64": true,
		"uint": true, "uint8": true, "uint16": true, "uint32": true, "uint64": true,
		"float32": true, "float64": true, "complex64": true, "complex128": true,
		"bool": true, "byte": true, "rune": true, "error": true, "any": true,
	}
	for path, alias := range imports {
		if alias != "" {
			continue // Already aliased
		}
		pkgName := extractPkgName(path)
		if goBuiltins[pkgName] {
			aliased := "kuki" + pkgName
			imports[path] = aliased
			g.pkgAliases[pkgName] = aliased
		}
	}

	// Auto-alias imports ending with version suffixes like /v2, /v3.
	// Go uses the last path segment as the package name, so "encoding/json/v2"
	// would be imported as "v2" without an alias. We need to alias it to "json".
	for path, alias := range imports {
		if alias != "" {
			continue // Already has an explicit alias
		}
		parts := strings.Split(path, "/")
		if len(parts) < 2 {
			continue
		}
		lastSegment := parts[len(parts)-1]
		// Check if last segment is a version like v2, v3, etc.
		if len(lastSegment) >= 2 && lastSegment[0] == 'v' && lastSegment[1] >= '0' && lastSegment[1] <= '9' {
			// Use the second-to-last segment as the alias
			pkgName := parts[len(parts)-2]
			// Handle .v suffix in the package name (e.g., yaml.v3)
			if idx := strings.Index(pkgName, ".v"); idx != -1 {
				pkgName = pkgName[:idx]
			}
			imports[path] = pkgName
		}
	}

	// Generate import block
	specs := make([]importSpec, 0, len(imports))
	for path, alias := range imports {
		specs = append(specs, importSpec{path: path, alias: alias})
	}

	sort.Slice(specs, func(i, j int) bool {
		if specs[i].path == specs[j].path {
			return specs[i].alias < specs[j].alias
		}
		return specs[i].path < specs[j].path
	})

	if len(specs) == 1 {
		spec := specs[0]
		if spec.alias != "" {
			g.writeLine(fmt.Sprintf("import %s \"%s\"", spec.alias, spec.path))
		} else {
			g.writeLine(fmt.Sprintf("import \"%s\"", spec.path))
		}
		return
	}

	g.writeLine("import (")
	g.indent++
	for _, spec := range specs {
		if spec.alias != "" {
			g.writeLine(fmt.Sprintf("%s \"%s\"", spec.alias, spec.path))
		} else {
			g.writeLine(fmt.Sprintf("\"%s\"", spec.path))
		}
	}
	g.indent--
	g.writeLine(")")
}

type importSpec struct {
	path  string
	alias string
}

// extractPkgName returns the Go package name from an import path.
// e.g., "encoding/json" -> "json", "net/http" -> "http",
// "github.com/duber000/kukicha/stdlib/json" -> "json",
// "gopkg.in/yaml.v3" -> "yaml"
func extractPkgName(importPath string) string {
	parts := strings.Split(importPath, "/")
	name := parts[len(parts)-1]

	// Handle version suffixes: gopkg.in/yaml.v3 -> yaml
	if idx := strings.Index(name, ".v"); idx != -1 {
		name = name[:idx]
	}

	// Handle Go module major version directories: encoding/json/v2 -> json
	if len(parts) >= 2 && len(name) >= 2 && name[0] == 'v' && name[1] >= '0' && name[1] <= '9' {
		name = parts[len(parts)-2]
		if idx := strings.Index(name, ".v"); idx != -1 {
			name = name[:idx]
		}
	}

	return name
}

// rewriteStdlibImport rewrites stdlib/ import paths to full module paths
// e.g., "stdlib/json" → "github.com/duber000/kukicha/stdlib/json"
// Note: Returns path without quotes (quotes are added by generateImports)
func (g *Generator) rewriteStdlibImport(path string) string {
	// Remove quotes to check the path
	cleanPath := strings.Trim(path, "\"")

	// Rewrite stdlib/ prefix to full module path
	if strings.HasPrefix(cleanPath, "stdlib/") {
		return "github.com/duber000/kukicha/" + cleanPath
	}

	return cleanPath
}

func (g *Generator) generateDeclaration(decl ast.Declaration) {
	g.emitLineDirective(decl.Pos())
	switch d := decl.(type) {
	case *ast.TypeDecl:
		g.generateTypeDecl(d)
	case *ast.InterfaceDecl:
		g.generateInterfaceDecl(d)
	case *ast.FunctionDecl:
		g.generateFunctionDecl(d)
	case *ast.VarDeclStmt:
		g.generateGlobalVarDecl(d)
	}
}

func (g *Generator) generateTypeDecl(decl *ast.TypeDecl) {
	g.write(fmt.Sprintf("type %s struct {", decl.Name.Value))
	g.writeLine("")
	g.indent++

	for _, field := range decl.Fields {
		fieldType := g.generateTypeAnnotation(field.Type)
		line := fmt.Sprintf("%s %s", field.Name.Value, fieldType)
		if field.Tag != "" {
			line += fmt.Sprintf(" `%s`", field.Tag)
		}
		g.writeLine(line)
	}

	g.indent--
	g.writeLine("}")
}

func (g *Generator) generateInterfaceDecl(decl *ast.InterfaceDecl) {
	g.write(fmt.Sprintf("type %s interface {", decl.Name.Value))
	g.writeLine("")
	g.indent++

	for _, method := range decl.Methods {
		// Generate method signature
		params := g.generateParameters(method.Parameters)
		returns := g.generateReturnTypes(method.Returns)

		if returns != "" {
			g.writeLine(fmt.Sprintf("%s(%s) %s", method.Name.Value, params, returns))
		} else {
			g.writeLine(fmt.Sprintf("%s(%s)", method.Name.Value, params))
		}
	}

	g.indent--
	g.writeLine("}")
}

func (g *Generator) generateGlobalVarDecl(stmt *ast.VarDeclStmt) {
	if len(stmt.Names) == 0 {
		return
	}

	// Build comma-separated list of names
	names := make([]string, len(stmt.Names))
	for i, n := range stmt.Names {
		names[i] = n.Value
	}
	namesStr := strings.Join(names, ", ")

	// Generate type if present
	if stmt.Type != nil {
		varType := g.generateTypeAnnotation(stmt.Type)
		if len(stmt.Values) > 0 {
			// With initializer
			values := make([]string, len(stmt.Values))
			for i, v := range stmt.Values {
				values[i] = g.exprToString(v)
			}
			valuesStr := strings.Join(values, ", ")
			g.writeLine(fmt.Sprintf("var %s %s = %s", namesStr, varType, valuesStr))
		} else {
			// Without initializer
			g.writeLine(fmt.Sprintf("var %s %s", namesStr, varType))
		}
	} else if len(stmt.Values) > 0 {
		// No explicit type, but with initializer
		values := make([]string, len(stmt.Values))
		for i, v := range stmt.Values {
			values[i] = g.exprToString(v)
		}
		valuesStr := strings.Join(values, ", ")
		g.writeLine(fmt.Sprintf("var %s = %s", namesStr, valuesStr))
	} else {
		// No type, no initializer - this is unusual for a global variable
		// but we'll generate it anyway (will be zero-valued)
		g.writeLine(fmt.Sprintf("var %s interface{}", namesStr))
	}
}

// generateFunctionDecl generates a Go function from a Kukicha function declaration.
//
// ARCHITECTURE NOTE: For stdlib/iterator and stdlib/slice packages, this function
// performs "generic inference" - it scans the function's parameter and return types
// for placeholder types ("any", "any2") and generates proper Go type parameters.
//
// Example: A Kukicha function like:
//
//	func Filter(items list of any, predicate func(any) bool) list of any
//
// Becomes Go code like:
//
//	func Filter[T any](items []T, predicate func(T) bool) []T
//
// This happens automatically for stdlib packages. User code doesn't need this
// because users import the stdlib and call its generic functions; the Go compiler
// handles type inference for callers.
func (g *Generator) generateFunctionDecl(decl *ast.FunctionDecl) {
	// Set up placeholder mapping for this function
	g.placeholderMap = make(map[string]string)

	g.currentFuncName = decl.Name.Value

	// Check if this is a stdlib function that needs special transpilation
	// (generic type parameter inference from placeholder types)
	var typeParams []*TypeParameter
	if g.isStdlibIter {
		// Generate type parameters from function signature for iter
		typeParams = g.inferStdlibTypeParameters(decl)
		for _, tp := range typeParams {
			g.placeholderMap[tp.Placeholder] = tp.Name
		}
	} else if g.isStdlibSlice() {
		// Generate type parameters from function signature for slice
		typeParams = g.inferSliceTypeParameters(decl)
		for _, tp := range typeParams {
			g.placeholderMap[tp.Placeholder] = tp.Name
		}
	}

	// Generate function signature
	signature := "func "

	// Add receiver for methods
	if decl.Receiver != nil {
		receiverType := g.generateTypeAnnotation(decl.Receiver.Type)
		receiverName := decl.Receiver.Name.Value
		signature += fmt.Sprintf("(%s %s) ", receiverName, receiverType)
	}

	// Add function name
	signature += decl.Name.Value

	// Add type parameters if present
	if len(typeParams) > 0 {
		signature += g.generateTypeParameters(typeParams)
	}

	// Add parameters
	params := g.generateFunctionParameters(decl.Parameters)
	signature += fmt.Sprintf("(%s)", params)

	// Add return types
	g.processingReturnType = true
	returns := g.generateReturnTypes(decl.Returns)
	g.processingReturnType = false

	if returns != "" {
		signature += " " + returns
	}

	g.write(signature + " {")
	g.writeLine("")

	// Set return types for type coercion in return statements
	g.currentReturnTypes = decl.Returns

	// Generate body
	if decl.Body != nil {
		g.indent++
		g.generateBlock(decl.Body)
		g.indent--
	}

	g.writeLine("}")

	// Clear function context
	g.placeholderMap = nil
	g.currentFuncName = ""
	g.currentReturnTypes = nil
}

func (g *Generator) generateFunctionLiteral(lit *ast.FunctionLiteral) string {
	// Save current placeholder map and create new one for this literal
	oldPlaceholderMap := g.placeholderMap
	g.placeholderMap = make(map[string]string)

	// Inherit placeholders from parent scope
	for k, v := range oldPlaceholderMap {
		g.placeholderMap[k] = v
	}

	// Check if this is a stdlib/iterator function literal that needs special transpilation
	var typeParams []*TypeParameter
	if g.isStdlibIter {
		// Create a temporary function decl to reuse the inference logic
		tempDecl := &ast.FunctionDecl{
			Name:       &ast.Identifier{Value: ""}, // dummy name for inference
			Parameters: lit.Parameters,
			Returns:    lit.Returns,
		}
		typeParams = g.inferStdlibTypeParameters(tempDecl)
		for _, tp := range typeParams {
			g.placeholderMap[tp.Placeholder] = tp.Name
		}
	}

	// Generate function signature
	signature := "func"

	// Add type parameters if present
	if len(typeParams) > 0 {
		signature += g.generateTypeParameters(typeParams)
	}

	// Add parameters
	params := g.generateFunctionParameters(lit.Parameters)
	signature += fmt.Sprintf("(%s)", params)

	// Add return types
	returns := g.generateReturnTypes(lit.Returns)
	if returns != "" {
		signature += " " + returns
	}

	// Generate body inline - create temporary generator to capture output
	tempGen := &Generator{
		program:        g.program,
		output:         strings.Builder{},
		indent:         g.indent + 1,
		placeholderMap: g.placeholderMap,
		autoImports:    g.autoImports,
		isStdlibIter:   g.isStdlibIter,
		sourceFile:     g.sourceFile,
	}

	result := signature + " {\n"

	if lit.Body != nil {
		// Generate body statements using temporary generator
		for _, stmt := range lit.Body.Statements {
			tempGen.generateStatement(stmt)
		}
		result += tempGen.output.String()
	}

	// Add proper indentation for closing brace
	for i := 0; i < g.indent; i++ {
		result += "\t"
	}
	result += "}"

	// Restore placeholder mapping
	g.placeholderMap = oldPlaceholderMap

	return result
}

// generateArrowLambda transpiles an arrow lambda to a Go anonymous function.
// Expression form: (r Repo) => r.Stars > 100  →  func(r Repo) bool { return r.Stars > 100 }
// Block form:      (r Repo) => BLOCK           →  func(r Repo) ReturnType { BLOCK }
func (g *Generator) generateArrowLambda(lambda *ast.ArrowLambda) string {
	// Build parameter string
	var paramParts []string
	for _, param := range lambda.Parameters {
		if param.Type != nil {
			paramParts = append(paramParts, param.Name.Value+" "+g.generateTypeAnnotation(param.Type))
		} else {
			// Untyped parameter — type must be inferred from context.
			// For now, we emit as-is; the Go compiler will catch type errors.
			// Full contextual inference is a semantic analysis extension.
			paramParts = append(paramParts, param.Name.Value)
		}
	}
	params := strings.Join(paramParts, ", ")

	if lambda.Body != nil {
		// Expression lambda: auto-return the expression
		bodyStr := g.exprToString(lambda.Body)

		// Infer return type from the expression for the Go func signature.
		// For typed params, we can determine the return type.
		// For the common case, we omit the return type and let Go infer it
		// from the context (e.g., when passed to a generic function).
		returnType := g.inferExprReturnType(lambda.Body)

		if returnType != "" {
			return fmt.Sprintf("func(%s) %s { return %s }", params, returnType, bodyStr)
		}
		return fmt.Sprintf("func(%s) { return %s }", params, bodyStr)
	}

	if lambda.Block != nil {
		// Block lambda: generate as multi-line anonymous function
		returnType := g.inferBlockReturnType(lambda.Block)

		// Create temporary generator to capture body output
		tempGen := &Generator{
			program:        g.program,
			output:         strings.Builder{},
			indent:         g.indent + 1,
			placeholderMap: g.placeholderMap,
			autoImports:    g.autoImports,
			isStdlibIter:   g.isStdlibIter,
			sourceFile:     g.sourceFile,
		}

		for _, stmt := range lambda.Block.Statements {
			tempGen.generateStatement(stmt)
		}

		var result string
		if returnType != "" {
			result = fmt.Sprintf("func(%s) %s {\n", params, returnType)
		} else {
			result = fmt.Sprintf("func(%s) {\n", params)
		}
		result += tempGen.output.String()
		for i := 0; i < g.indent; i++ {
			result += "\t"
		}
		result += "}"
		return result
	}

	// Shouldn't happen — at least one of Body or Block must be set
	return fmt.Sprintf("func(%s) {}", params)
}

// inferExprReturnType tries to infer the return type of an expression lambda body.
// Returns empty string if it can't determine the type.
func (g *Generator) inferExprReturnType(expr ast.Expression) string {
	switch e := expr.(type) {
	case *ast.BinaryExpr:
		switch e.Operator {
		case "==", "!=", "<", ">", "<=", ">=", "equals", "not equals",
			"and", "or", "&&", "||", "in", "not in":
			return "bool"
		case "+", "-", "*", "/", "%":
			// Arithmetic — try to infer from operands
			leftType := g.inferExprReturnType(e.Left)
			if leftType != "" {
				return leftType
			}
			return g.inferExprReturnType(e.Right)
		}
	case *ast.UnaryExpr:
		if e.Operator == "not" || e.Operator == "!" {
			return "bool"
		}
	case *ast.BooleanLiteral:
		return "bool"
	case *ast.IntegerLiteral:
		return "int"
	case *ast.FloatLiteral:
		return "float64"
	case *ast.StringLiteral:
		return "string"
	case *ast.CallExpr:
		// Can't easily determine return type of arbitrary call
		return ""
	}
	// For field access, method calls, etc. — can't determine without full type info
	return ""
}

// inferBlockReturnType scans a block's return statements to infer return type.
func (g *Generator) inferBlockReturnType(block *ast.BlockStmt) string {
	for _, stmt := range block.Statements {
		if ret, ok := stmt.(*ast.ReturnStmt); ok {
			if len(ret.Values) == 1 {
				return g.inferExprReturnType(ret.Values[0])
			}
		}
	}
	return ""
}

// inferStdlibTypeParameters infers type parameters for stdlib/iterator functions
// This enables special transpilation where iter.Seq → iter.Seq[T]
func (g *Generator) inferStdlibTypeParameters(decl *ast.FunctionDecl) []*TypeParameter {
	var typeParams []*TypeParameter
	usesIterSeq := false
	needsTwoTypes := false

	// Check if function uses iter.Seq and scan for any2 placeholder
	for _, param := range decl.Parameters {
		if g.isIterSeqType(param.Type) {
			usesIterSeq = true
		}
		if g.typeContainsPlaceholder(param.Type, "any2") {
			needsTwoTypes = true
		}
	}

	for _, ret := range decl.Returns {
		if g.isIterSeqType(ret) {
			usesIterSeq = true
		}
		if g.typeContainsPlaceholder(ret, "any2") {
			needsTwoTypes = true
		}
	}

	// Generate type parameters
	if usesIterSeq {
		typeParams = append(typeParams, &TypeParameter{
			Name:        "T",
			Placeholder: "any",
			Constraint:  "any",
		})

		if needsTwoTypes {
			typeParams = append(typeParams, &TypeParameter{
				Name:        "U",
				Placeholder: "any2",
				Constraint:  "any",
			})
		}
	}

	return typeParams
}

// isStdlibSlice checks if we're generating code in stdlib/slice
func (g *Generator) isStdlibSlice() bool {
	return strings.Contains(g.sourceFile, "stdlib/slice/") || strings.Contains(g.sourceFile, "stdlib\\slice\\")
}

// inferSliceTypeParameters infers type parameters for stdlib/slice functions like GroupBy
// GroupBy needs two type parameters: T (element type) and K (key type, must be comparable)
func (g *Generator) inferSliceTypeParameters(decl *ast.FunctionDecl) []*TypeParameter {
	var typeParams []*TypeParameter

	// Special handling for GroupBy: func GroupBy(items list of any, keyFunc func(any) any2) map of any2 to list of any
	if decl.Name.Value == "GroupBy" {
		// GroupBy returns map[K][]T where K is the key type and T is the element type
		// The function signature uses placeholders: "any" for T, "any2" for K
		typeParams = append(typeParams, &TypeParameter{
			Name:        "T",
			Placeholder: "any",
			Constraint:  "any",
		})
		typeParams = append(typeParams, &TypeParameter{
			Name:        "K",
			Placeholder: "any2",
			Constraint:  "comparable",
		})
	}

	return typeParams
}

// isIterSeqType checks if a type is iter.Seq (to be made generic)
func (g *Generator) isIterSeqType(typeAnn ast.TypeAnnotation) bool {
	if namedType, ok := typeAnn.(*ast.NamedType); ok {
		// Check for "iter.Seq" or just "Seq" in iter context
		return namedType.Name == "iter.Seq" ||
			(g.isStdlibIter && namedType.Name == "Seq")
	}
	return false
}

// typeContainsPlaceholder recursively checks if a type annotation tree
// contains the given placeholder name (e.g., "any2")
func (g *Generator) typeContainsPlaceholder(typeAnn ast.TypeAnnotation, placeholder string) bool {
	if typeAnn == nil {
		return false
	}
	switch t := typeAnn.(type) {
	case *ast.PrimitiveType:
		return t.Name == placeholder
	case *ast.NamedType:
		return t.Name == placeholder
	case *ast.ListType:
		return g.typeContainsPlaceholder(t.ElementType, placeholder)
	case *ast.MapType:
		return g.typeContainsPlaceholder(t.KeyType, placeholder) || g.typeContainsPlaceholder(t.ValueType, placeholder)
	case *ast.ChannelType:
		return g.typeContainsPlaceholder(t.ElementType, placeholder)
	case *ast.ReferenceType:
		return g.typeContainsPlaceholder(t.ElementType, placeholder)
	case *ast.FunctionType:
		for _, param := range t.Parameters {
			if g.typeContainsPlaceholder(param, placeholder) {
				return true
			}
		}
		for _, ret := range t.Returns {
			if g.typeContainsPlaceholder(ret, placeholder) {
				return true
			}
		}
	}
	return false
}

// isLikelyInterfaceType checks if a Go type name is likely an interface type.
// Used to determine whether empty Type should generate nil (interface) vs Type{} (struct).
func (g *Generator) isLikelyInterfaceType(typeName string) bool {
	// "error" is always an interface
	if typeName == "error" {
		return true
	}

	// Check current program's declarations for interface types
	for _, decl := range g.program.Declarations {
		if iface, ok := decl.(*ast.InterfaceDecl); ok {
			if iface.Name.Value == typeName {
				return true
			}
		}
	}

	// Common standard library interfaces
	knownInterfaces := map[string]bool{
		"io.Reader":           true,
		"io.Writer":           true,
		"io.Closer":           true,
		"io.ReadCloser":       true,
		"io.WriteCloser":      true,
		"io.ReadWriter":       true,
		"io.ReadWriteCloser":  true,
		"io.ReaderFrom":       true,
		"io.WriterTo":         true,
		"io.Seeker":           true,
		"io.ReadSeeker":       true,
		"io.ReadWriteSeeker":  true,
		"fmt.Stringer":        true,
		"fmt.Scanner":         true,
		"http.Handler":        true,
		"http.ResponseWriter": true,
		"context.Context":     true,
		"sort.Interface":      true,
		"net.Conn":            true,
		"net.Listener":        true,
		"net.Error":           true,
	}

	return knownInterfaces[typeName]
}

// zeroValueForType returns a Go expression for the zero value of a type annotation.
func (g *Generator) zeroValueForType(typeAnn ast.TypeAnnotation) string {
	switch t := typeAnn.(type) {
	case *ast.PrimitiveType:
		switch t.Name {
		case "string":
			return "\"\""
		case "bool":
			return "false"
		default:
			return "0"
		}
	case *ast.ListType:
		return g.generateTypeAnnotation(t) + "{}"
	case *ast.MapType:
		return g.generateTypeAnnotation(typeAnn) + "{}"
	case *ast.ReferenceType, *ast.ChannelType, *ast.FunctionType:
		return "nil"
	case *ast.NamedType:
		typeName := g.generateTypeAnnotation(t)
		if g.isLikelyInterfaceType(typeName) {
			return "nil"
		}
		return fmt.Sprintf("*new(%s)", typeName)
	default:
		return "nil"
	}
}

func (g *Generator) errorValueExpr(expr ast.Expression, errVar string) string {
	// Defensive guard: the parser lexes `error` as TOKEN_ERROR, not TOKEN_IDENTIFIER,
	// so this branch is currently unreachable. Kept as documentation of intent.
	if id, ok := expr.(*ast.Identifier); ok && id.Value == "error" {
		return errVar
	}
	if strLit, ok := expr.(*ast.StringLiteral); ok {
		msg := strLit.Value
		if strings.Contains(msg, "{error}") {
			msg = strings.ReplaceAll(msg, "{error}", fmt.Sprintf("{%s}", errVar))
		}
		return fmt.Sprintf("errors.New(%s)", g.generateStringInterpolation(msg))
	}
	return fmt.Sprintf("errors.New(%s)", g.exprToString(expr))
}

func (g *Generator) inferReturnCount(expr ast.Expression) (int, bool) {
	if g.exprReturnCounts != nil {
		if count, ok := g.exprReturnCounts[expr]; ok {
			return count, true
		}
	}
	switch e := expr.(type) {
	case *ast.PipeExpr:
		return g.inferReturnCount(e.Right)
	case *ast.CallExpr:
		if id, ok := e.Function.(*ast.Identifier); ok {
			return g.returnCountForFunctionName(id.Value)
		}
	case *ast.MethodCallExpr:
		// Method return counts require type info; skip for now.
		return 0, false
	}
	return 0, false
}

func (g *Generator) returnCountForFunctionName(name string) (int, bool) {
	for _, decl := range g.program.Declarations {
		if fn, ok := decl.(*ast.FunctionDecl); ok {
			if fn.Receiver == nil && fn.Name.Value == name {
				return len(fn.Returns), true
			}
		}
	}
	return 0, false
}

// generateTypeParameters generates Go generic type parameter list
func (g *Generator) generateTypeParameters(typeParams []*TypeParameter) string {
	if len(typeParams) == 0 {
		return ""
	}

	parts := make([]string, len(typeParams))
	for i, tp := range typeParams {
		constraint := tp.Constraint
		if constraint == "cmp.Ordered" {
			g.addImport("cmp")
		}
		parts[i] = fmt.Sprintf("%s %s", tp.Name, constraint)
	}

	return "[" + strings.Join(parts, ", ") + "]"
}

func (g *Generator) generateFunctionParameters(params []*ast.Parameter) string {
	if len(params) == 0 {
		return ""
	}

	parts := make([]string, len(params))
	for i, param := range params {
		paramType := g.generateTypeAnnotation(param.Type)
		if param.Variadic {
			// Variadic parameter: use ...Type syntax
			parts[i] = fmt.Sprintf("%s ...%s", param.Name.Value, paramType)
		} else {
			parts[i] = fmt.Sprintf("%s %s", param.Name.Value, paramType)
		}
	}

	return strings.Join(parts, ", ")
}

func (g *Generator) generateParameters(params []*ast.Parameter) string {
	return g.generateFunctionParameters(params)
}

func (g *Generator) generateReturnTypes(returns []ast.TypeAnnotation) string {
	if len(returns) == 0 {
		return ""
	}

	if len(returns) == 1 {
		return g.generateTypeAnnotation(returns[0])
	}

	// Multiple return types
	parts := make([]string, len(returns))
	for i, ret := range returns {
		parts[i] = g.generateTypeAnnotation(ret)
	}

	return "(" + strings.Join(parts, ", ") + ")"
}

func (g *Generator) generateTypeAnnotation(typeAnn ast.TypeAnnotation) string {
	if typeAnn == nil {
		return ""
	}

	switch t := typeAnn.(type) {
	case *ast.PrimitiveType:
		if g.placeholderMap != nil {
			if typeParam, ok := g.placeholderMap[t.Name]; ok {
				return typeParam
			}
		}
		return t.Name
	case *ast.NamedType:
		if g.placeholderMap != nil {
			if typeParam, ok := g.placeholderMap[t.Name]; ok {
				return typeParam
			}
		}
		// Rewrite package-qualified type names if the package was auto-aliased
		if dotIdx := strings.Index(t.Name, "."); dotIdx > 0 {
			pkgPart := t.Name[:dotIdx]
			typePart := t.Name[dotIdx:]
			if alias, ok := g.pkgAliases[pkgPart]; ok {
				return alias + typePart
			}
		}
		// Special handling for iter.Seq in stdlib mode
		if g.isStdlibIter && g.placeholderMap != nil {
			if g.isIterSeqType(t) {
				// Transform iter.Seq → iter.Seq[T]
				if _, ok := g.placeholderMap["any"]; ok {
					typeParam := "T"
					// If this is a return type and U is declared, use U
					if g.processingReturnType {
						if _, hasU := g.placeholderMap["any2"]; hasU {
							typeParam = "U"
						}
					}
					return "iter.Seq[" + typeParam + "]"
				}
			}

			// iter.SeqU → iter.Seq[U]
			if t.Name == "iter.SeqU" {
				return "iter.Seq[U]"
			}

			// iter.Seq2 → iter.Seq2[T, U] or iter.Seq2[int, T] (for Enumerate) or iter.Seq2[T, T]
			if t.Name == "iter.Seq2" {
				if g.currentFuncName == "Enumerate" {
					return "iter.Seq2[int, T]"
				}
				// Only use U if it's actually declared as a type parameter
				if _, hasU := g.placeholderMap["any2"]; hasU {
					return "iter.Seq2[T, U]"
				}
				return "iter.Seq2[T, T]"
			}

			// iter.SeqSlice → iter.Seq[[]T] (for Chunk)
			if t.Name == "iter.SeqSlice" {
				return "iter.Seq[[]T]"
			}
		}
		return t.Name
	case *ast.ReferenceType:
		return "*" + g.generateTypeAnnotation(t.ElementType)
	case *ast.ListType:
		return "[]" + g.generateTypeAnnotation(t.ElementType)
	case *ast.MapType:
		keyType := g.generateTypeAnnotation(t.KeyType)
		valueType := g.generateTypeAnnotation(t.ValueType)
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
		// Note: keyType and valueType already have placeholders substituted via recursion
	case *ast.ChannelType:
		return "chan " + g.generateTypeAnnotation(t.ElementType)
	case *ast.FunctionType:
		// Generate Go function type: func(params) returns
		var paramTypes []string
		for _, param := range t.Parameters {
			paramTypes = append(paramTypes, g.generateTypeAnnotation(param))
		}

		result := "func(" + strings.Join(paramTypes, ", ") + ")"

		if len(t.Returns) == 1 {
			result += " " + g.generateTypeAnnotation(t.Returns[0])
		} else if len(t.Returns) > 1 {
			var returnTypes []string
			for _, ret := range t.Returns {
				returnTypes = append(returnTypes, g.generateTypeAnnotation(ret))
			}
			result += " (" + strings.Join(returnTypes, ", ") + ")"
		}

		return result
	default:
		return "interface{}"
	}
}

func (g *Generator) generateBlock(block *ast.BlockStmt) {
	for _, stmt := range block.Statements {
		g.generateStatement(stmt)
	}
}

func (g *Generator) generateStatement(stmt ast.Statement) {
	g.emitLineDirective(stmt.Pos())
	switch s := stmt.(type) {
	case *ast.VarDeclStmt:
		g.generateVarDeclStmt(s)
	case *ast.AssignStmt:
		g.generateAssignStmt(s)
	case *ast.IncDecStmt:
		g.generateIncDecStmt(s)
	case *ast.ReturnStmt:
		g.generateReturnStmt(s)
	case *ast.IfStmt:
		g.generateIfStmt(s)
	case *ast.SwitchStmt:
		g.generateSwitchStmt(s)
	case *ast.ForRangeStmt:
		g.generateForRangeStmt(s)
	case *ast.ForNumericStmt:
		g.generateForNumericStmt(s)
	case *ast.ForConditionStmt:
		g.generateForConditionStmt(s)
	case *ast.DeferStmt:
		g.writeLine("defer " + g.exprToString(s.Call))
	case *ast.GoStmt:
		if s.Block != nil {
			// Block form: go NEWLINE INDENT ... DEDENT
			// Generates: go func() { ... }()
			g.write(g.indentStr() + "go func() {\n")
			g.indent++
			for _, stmt := range s.Block.Statements {
				g.generateStatement(stmt)
			}
			g.indent--
			g.write(g.indentStr() + "}()\n")
		} else {
			g.writeLine("go " + g.exprToString(s.Call))
		}
	case *ast.SendStmt:
		channel := g.exprToString(s.Channel)
		value := g.exprToString(s.Value)
		g.writeLine(fmt.Sprintf("%s <- %s", channel, value))
	case *ast.ContinueStmt:
		g.writeLine("continue")
	case *ast.BreakStmt:
		g.writeLine("break")
	case *ast.ExpressionStmt:
		if s.OnErr != nil {
			g.generateOnErrStmt(s.Expression, s.OnErr)
		} else {
			g.writeLine(g.exprToString(s.Expression))
		}
	}
}

func (g *Generator) generateVarDeclStmt(stmt *ast.VarDeclStmt) {
	// Check for onerr clause on the statement
	if stmt.OnErr != nil {
		g.generateOnErrVarDecl(stmt.Names, stmt.Values, stmt.OnErr)
		return
	}

	// Special case: typed empty with interface type needs var declaration
	// e.g., x := empty io.Reader → var x io.Reader (nil by default)
	if len(stmt.Names) == 1 && len(stmt.Values) == 1 {
		if emptyExpr, ok := stmt.Values[0].(*ast.EmptyExpr); ok {
			if emptyExpr.Type != nil {
				targetType := g.generateTypeAnnotation(emptyExpr.Type)
				if g.isLikelyInterfaceType(targetType) {
					g.writeLine(fmt.Sprintf("var %s %s", stmt.Names[0].Value, targetType))
					return
				}
			} else {
				// Untyped empty → var x interface{}
				g.writeLine(fmt.Sprintf("var %s interface{}", stmt.Names[0].Value))
				return
			}
		}
	}

	// Build comma-separated list of names
	names := make([]string, len(stmt.Names))
	for i, n := range stmt.Names {
		names[i] = n.Value
	}
	namesStr := strings.Join(names, ", ")

	// Build comma-separated list of values
	values := make([]string, len(stmt.Values))
	for i, v := range stmt.Values {
		// Special case: multi-value declaration with TypeCastExpr should use assertion syntax
		// e.g., val, ok := x as Type -> val, ok := x.(Type)
		if len(stmt.Names) == 2 && len(stmt.Values) == 1 {
			if typeCast, ok := v.(*ast.TypeCastExpr); ok {
				targetType := g.generateTypeAnnotation(typeCast.TargetType)
				expr := g.exprToString(typeCast.Expression)
				values[i] = fmt.Sprintf("%s.(%s)", expr, targetType)
				continue
			}
		}
		values[i] = g.exprToString(v)
	}
	valuesStr := strings.Join(values, ", ")

	if stmt.Type != nil {
		// Explicit type declaration
		varType := g.generateTypeAnnotation(stmt.Type)
		g.writeLine(fmt.Sprintf("var %s %s = %s", namesStr, varType, valuesStr))
	} else {
		// Type inference with :=
		g.writeLine(fmt.Sprintf("%s := %s", namesStr, valuesStr))
	}
}

// generateOnErrVarDecl handles variable declarations with onerr
// e.g., val := foo() onerr panic "error" → val, err := foo(); if err != nil { panic("error") }
// e.g., port := getPort() onerr "8080" → port, err := getPort(); if err != nil { port = "8080" }
func (g *Generator) generateOnErrVarDecl(names []*ast.Identifier, values []ast.Expression, clause *ast.OnErrClause) {
	// Build the value expression string (typically a single call expression)
	valuesStr := make([]string, len(values))
	for i, v := range values {
		valuesStr[i] = g.exprToString(v)
	}
	valueExpr := strings.Join(valuesStr, ", ")

	// Check for discard case first - we can skip error handling entirely
	if _, isDiscard := clause.Handler.(*ast.DiscardExpr); isDiscard {
		// For discard with multi-value returns (where last value is error), just use the names as-is
		// (the error variable is already one of the names, and we don't need separate error handling)
		if len(names) > 1 && len(values) == 1 {
			var lhsParts []string
			for _, name := range names {
				lhsParts = append(lhsParts, name.Value)
			}
			g.writeLine(fmt.Sprintf("%s := %s", strings.Join(lhsParts, ", "), valueExpr))
			return
		}

		// For single-value assignments, ignore the error by using _
		var lhsParts []string
		for _, name := range names {
			lhsParts = append(lhsParts, name.Value)
		}
		lhsParts = append(lhsParts, "_")
		g.writeLine(fmt.Sprintf("%s := %s", strings.Join(lhsParts, ", "), valueExpr))
		return
	}

	// Special case: if we have multiple names (e.g., x, err) and a single value expression,
	// the single expression likely returns multiple values including an error.
	// In this case, use the names as-is without adding an extra error variable.
	// This handles cases like: x, err := Parse() onerr handler
	// where Parse() returns (int, error) and names are [x, err]
	if len(names) > 1 && len(values) == 1 {
		var lhsParts []string
		for _, name := range names {
			lhsParts = append(lhsParts, name.Value)
		}
		g.writeLine(fmt.Sprintf("%s := %s", strings.Join(lhsParts, ", "), valueExpr))

		// The last name is assumed to be the error variable
		errVar := names[len(names)-1].Value
		g.writeLine(fmt.Sprintf("if %s != nil {", errVar))
		g.indent++
		g.generateOnErrHandler(names[:len(names)-1], clause.Handler, errVar)
		g.indent--
		g.writeLine("}")
		return
	}

	// Generate unique error variable name to prevent shadowing
	errVar := g.uniqueId("err")

	// Build the LHS: user variables + error variable
	var lhsParts []string
	for _, name := range names {
		lhsParts = append(lhsParts, name.Value)
	}
	lhsParts = append(lhsParts, errVar)

	// Generate: names..., err := expression
	g.writeLine(fmt.Sprintf("%s := %s", strings.Join(lhsParts, ", "), valueExpr))

	// Generate error check block
	g.writeLine(fmt.Sprintf("if %s != nil {", errVar))
	g.indent++
	g.generateOnErrHandler(names, clause.Handler, errVar)
	g.indent--
	g.writeLine("}")
}

// generateOnErrHandler generates code for the onerr handler expression
func (g *Generator) generateOnErrHandler(names []*ast.Identifier, handler ast.Expression, errVar string) {
	switch h := handler.(type) {
	case *ast.PanicExpr:
		// onerr panic "message"
		// If message contains {error}, replace it with the actual error variable
		msg := ""
		if strLit, ok := h.Message.(*ast.StringLiteral); ok {
			msg = strLit.Value
		} else {
			msg = g.exprToString(h.Message)
		}

		if strings.Contains(msg, "{error}") {
			msg = strings.ReplaceAll(msg, "{error}", fmt.Sprintf("{%s}", errVar))
		}
		g.writeLine(fmt.Sprintf("panic(%s)", g.generateStringInterpolation(msg)))
	case *ast.ErrorExpr:
		// onerr return empty, error - generate return with error
		// This assumes the function returns (T, error)
		errExpr := g.errorValueExpr(h.Message, errVar)
		if len(names) > 0 {
			// Return the first value and the error
			g.writeLine(fmt.Sprintf("return %s, %s", names[0].Value, errExpr))
		} else {
			g.writeLine(fmt.Sprintf("return %s", errExpr))
		}
	case *ast.ReturnExpr:
		// onerr return empty, error
		// If any value is identifier "error", replace with errVar
		values := make([]string, len(h.Values))
		for i, v := range h.Values {
			if id, ok := v.(*ast.Identifier); ok && id.Value == "error" {
				values[i] = errVar
			} else {
				values[i] = g.exprToString(v)
			}
		}
		g.writeLine(fmt.Sprintf("return %s", strings.Join(values, ", ")))
	case *ast.EmptyExpr:
		// onerr return empty - generate bare return (for named return values)
		g.writeLine("return")
	default:
		// onerr expression (default value case)
		// e.g., port := getPort() onerr "8080"
		// Assign the default value to the first variable
		if len(names) > 0 {
			g.writeLine(fmt.Sprintf("%s = %s", names[0].Value, g.exprToString(handler)))
		}
	}
}

// generateOnErrStmt handles statement-level onerr
// e.g., todo |> json.MarshalWrite(w, _) onerr panic("failed")
// Generates: if err := json.MarshalWrite(w, todo); err != nil { panic("failed") }
func (g *Generator) generateOnErrStmt(expr ast.Expression, clause *ast.OnErrClause) {
	// Check for discard case - just execute and ignore error
	if _, isDiscard := clause.Handler.(*ast.DiscardExpr); isDiscard {
		if count, ok := g.inferReturnCount(expr); ok {
			switch count {
			case 0:
				g.writeLine(g.exprToString(expr))
			case 1:
				g.writeLine(fmt.Sprintf("_ = %s", g.exprToString(expr)))
			default:
				blanks := make([]string, count)
				for i := range blanks {
					blanks[i] = "_"
				}
				g.writeLine(fmt.Sprintf("%s = %s", strings.Join(blanks, ", "), g.exprToString(expr)))
			}
		} else {
			// Fallback: when return count inference fails (e.g. external multi-return
			// functions not yet modeled), default to a single blank assignment.
			g.writeLine(fmt.Sprintf("_ = %s", g.exprToString(expr)))
		}
		return
	}

	// Generate unique error variable name
	errVar := g.uniqueId("err")

	// Generate: if err := expression; err != nil { handler }
	g.writeLine(fmt.Sprintf("if %s := %s; %s != nil {", errVar, g.exprToString(expr), errVar))
	g.indent++

	// Generate the error handler (no variable names for statement-level)
	g.generateOnErrHandler([]*ast.Identifier{}, clause.Handler, errVar)

	g.indent--
	g.writeLine("}")
}

func (g *Generator) generateAssignStmt(stmt *ast.AssignStmt) {
	// Check for onerr clause on assignment
	if stmt.OnErr != nil {
		g.generateOnErrAssign(stmt)
		return
	}

	// Build comma-separated list of targets
	targets := make([]string, len(stmt.Targets))
	for i, t := range stmt.Targets {
		targets[i] = g.exprToString(t)
	}
	targetsStr := strings.Join(targets, ", ")

	// Build comma-separated list of values
	values := make([]string, len(stmt.Values))
	for i, v := range stmt.Values {
		// Special case: multi-value assignment with TypeCastExpr should use assertion syntax
		// e.g., val, ok := x as Type -> val, ok := x.(Type)
		if len(stmt.Targets) == 2 && len(stmt.Values) == 1 {
			if typeCast, ok := v.(*ast.TypeCastExpr); ok {
				targetType := g.generateTypeAnnotation(typeCast.TargetType)
				expr := g.exprToString(typeCast.Expression)
				values[i] = fmt.Sprintf("%s.(%s)", expr, targetType)
				continue
			}
		}
		values[i] = g.exprToString(v)
	}
	valuesStr := strings.Join(values, ", ")

	g.writeLine(fmt.Sprintf("%s = %s", targetsStr, valuesStr))
}

// generateOnErrAssign handles assignment statements with onerr
// e.g., x = foo() onerr panic "error" → x, err = foo(); if err != nil { panic("error") }
func (g *Generator) generateOnErrAssign(stmt *ast.AssignStmt) {
	clause := stmt.OnErr

	// Build value expression
	valuesStr := make([]string, len(stmt.Values))
	for i, v := range stmt.Values {
		valuesStr[i] = g.exprToString(v)
	}
	valueExpr := strings.Join(valuesStr, ", ")

	// Build target names for handler (convert targets to identifiers where possible)
	var names []*ast.Identifier
	for _, t := range stmt.Targets {
		if ident, ok := t.(*ast.Identifier); ok {
			names = append(names, ident)
		}
	}

	// Check for discard case
	if _, isDiscard := clause.Handler.(*ast.DiscardExpr); isDiscard {
		// For discard with multi-value returns (where last value is error), just use the targets as-is
		// (the error variable is already one of the targets, and we don't need separate error handling)
		if len(stmt.Targets) > 1 && len(stmt.Values) == 1 {
			var lhsParts []string
			for _, t := range stmt.Targets {
				lhsParts = append(lhsParts, g.exprToString(t))
			}
			g.writeLine(fmt.Sprintf("%s = %s", strings.Join(lhsParts, ", "), valueExpr))
			return
		}

		// For single-value assignments, ignore the error by using _
		var lhsParts []string
		for _, t := range stmt.Targets {
			lhsParts = append(lhsParts, g.exprToString(t))
		}
		lhsParts = append(lhsParts, "_")
		g.writeLine(fmt.Sprintf("%s = %s", strings.Join(lhsParts, ", "), valueExpr))
		return
	}

	// Special case: if we have multiple targets (e.g., x, err) and a single value expression,
	// the single expression likely returns multiple values including an error.
	// In this case, use the targets as-is without adding an extra error variable.
	// This handles cases like: x, err = data |> Parse() onerr handler
	// where Parse() returns (int, error) and targets are [x, err]
	if len(stmt.Targets) > 1 && len(stmt.Values) == 1 {
		var lhsParts []string
		for _, t := range stmt.Targets {
			lhsParts = append(lhsParts, g.exprToString(t))
		}
		g.writeLine(fmt.Sprintf("%s = %s", strings.Join(lhsParts, ", "), valueExpr))

		// The last target is assumed to be the error variable
		if len(names) > 0 {
			errVar := g.exprToString(stmt.Targets[len(stmt.Targets)-1])
			g.writeLine(fmt.Sprintf("if %s != nil {", errVar))
			g.indent++
			g.generateOnErrHandler(names[:len(names)-1], clause.Handler, errVar)
			g.indent--
			g.writeLine("}")
		}
		return
	}

	// Generate unique error variable name for single-return-value cases
	errVar := g.uniqueId("err")

	// Declare the error variable before assignment (since = requires prior declaration)
	g.writeLine(fmt.Sprintf("var %s error", errVar))

	// Build the LHS: targets + error variable
	var lhsParts []string
	for _, t := range stmt.Targets {
		lhsParts = append(lhsParts, g.exprToString(t))
	}
	lhsParts = append(lhsParts, errVar)

	// Generate: targets..., err = expression
	g.writeLine(fmt.Sprintf("%s = %s", strings.Join(lhsParts, ", "), valueExpr))

	// Generate error check block
	g.writeLine(fmt.Sprintf("if %s != nil {", errVar))
	g.indent++
	g.generateOnErrHandler(names, clause.Handler, errVar)
	g.indent--
	g.writeLine("}")
}

func (g *Generator) generateIncDecStmt(stmt *ast.IncDecStmt) {
	variable := g.exprToString(stmt.Variable)
	g.writeLine(fmt.Sprintf("%s%s", variable, stmt.Operator))
}

func (g *Generator) generateReturnStmt(stmt *ast.ReturnStmt) {
	if len(stmt.Values) == 0 {
		g.writeLine("return")
		return
	}

	values := make([]string, len(stmt.Values))
	for i, val := range stmt.Values {
		valStr := g.exprToString(val)

		// Apply type coercion if we have matching return types
		// This handles cases like: return n * 1000 -> return time.Duration(n * 1000)
		if i < len(g.currentReturnTypes) {
			valStr = g.coerceReturnValue(valStr, val, g.currentReturnTypes[i])
		}

		values[i] = valStr
	}

	g.writeLine(fmt.Sprintf("return %s", strings.Join(values, ", ")))
}

// coerceReturnValue wraps a return value in a type conversion if needed
// This handles cases where Go requires explicit conversion to named types
func (g *Generator) coerceReturnValue(valStr string, val ast.Expression, returnType ast.TypeAnnotation) string {
	// Only coerce for named types (like time.Duration)
	namedType, ok := returnType.(*ast.NamedType)
	if !ok {
		return valStr
	}

	typeName := g.generateTypeAnnotation(returnType)

	// Don't wrap if it's already a type cast to this type
	if cast, ok := val.(*ast.TypeCastExpr); ok {
		castType := g.generateTypeAnnotation(cast.TargetType)
		if castType == typeName {
			return valStr
		}
	}

	// Don't wrap if it's a function call that likely returns the right type
	// (the function's return type should match)
	if _, ok := val.(*ast.CallExpr); ok {
		return valStr
	}
	if _, ok := val.(*ast.MethodCallExpr); ok {
		return valStr
	}

	// Don't wrap identifiers - they might already be the right type
	if _, ok := val.(*ast.Identifier); ok {
		return valStr
	}

	// Don't wrap if it's an empty expression (like time.Time{})
	if _, ok := val.(*ast.EmptyExpr); ok {
		return valStr
	}

	// For arithmetic expressions on numeric types returning a named numeric type,
	// wrap in the type conversion (e.g., time.Duration)
	if _, ok := val.(*ast.BinaryExpr); ok {
		// Check if this is a stdlib named type that needs wrapping
		if strings.Contains(namedType.Name, ".") {
			return fmt.Sprintf("%s(%s)", typeName, valStr)
		}
	}

	return valStr
}

func (g *Generator) generateIfStmt(stmt *ast.IfStmt) {
	if stmt.Init != nil {
		g.write("if ")
		// Use a separate generator to avoid adding newline to main output
		tempGen := New(g.program)
		tempGen.indent = 0
		tempGen.generateStatement(stmt.Init)
		initStr := strings.TrimSpace(tempGen.output.String())
		g.write(initStr)
		g.write("; ")
		g.write(g.exprToString(stmt.Condition))
		g.writeLine(" {")
	} else {
		condition := g.exprToString(stmt.Condition)
		g.writeLine(fmt.Sprintf("if %s {", condition))
	}

	g.indent++
	g.generateBlock(stmt.Consequence)
	g.indent--

	if stmt.Alternative != nil {
		switch alt := stmt.Alternative.(type) {
		case *ast.ElseStmt:
			g.writeLine("} else {")
			g.indent++
			g.generateBlock(alt.Body)
			g.indent--
			g.writeLine("}")
		case *ast.IfStmt:
			g.write(g.indentStr() + "} else ")
			g.generateIfStmtContinued(alt)
			return // Don't write closing brace, it's handled recursively
		}
	} else {
		g.writeLine("}")
	}
}

func (g *Generator) generateIfStmtContinued(stmt *ast.IfStmt) {
	condition := g.exprToString(stmt.Condition)
	g.output.WriteString(fmt.Sprintf("if %s {\n", condition))

	g.indent++
	g.generateBlock(stmt.Consequence)
	g.indent--

	if stmt.Alternative != nil {
		switch alt := stmt.Alternative.(type) {
		case *ast.ElseStmt:
			g.writeLine("} else {")
			g.indent++
			g.generateBlock(alt.Body)
			g.indent--
			g.writeLine("}")
		case *ast.IfStmt:
			g.write(g.indentStr() + "} else ")
			g.generateIfStmtContinued(alt)
			return
		}
	} else {
		g.writeLine("}")
	}
}

func (g *Generator) generateSwitchStmt(stmt *ast.SwitchStmt) {
	if stmt.Expression != nil {
		g.writeLine(fmt.Sprintf("switch %s {", g.exprToString(stmt.Expression)))
	} else {
		g.writeLine("switch {")
	}

	g.indent++
	for _, c := range stmt.Cases {
		caseValues := make([]string, len(c.Values))
		for i, value := range c.Values {
			caseValues[i] = g.exprToString(value)
		}
		g.writeLine(fmt.Sprintf("case %s:", strings.Join(caseValues, ", ")))

		g.indent++
		g.generateBlock(c.Body)
		g.indent--
	}

	if stmt.Otherwise != nil {
		g.writeLine("default:")
		g.indent++
		g.generateBlock(stmt.Otherwise.Body)
		g.indent--
	}
	g.indent--
	g.writeLine("}")
}

func (g *Generator) generateForRangeStmt(stmt *ast.ForRangeStmt) {
	collection := g.exprToString(stmt.Collection)

	if stmt.Index != nil {
		g.writeLine(fmt.Sprintf("for %s, %s := range %s {", stmt.Index.Value, stmt.Variable.Value, collection))
	} else {
		// In stdlib/iter, all range loops are over iter.Seq which yields one value
		if g.isStdlibIter {
			g.writeLine(fmt.Sprintf("for %s := range %s {", stmt.Variable.Value, collection))
		} else {
			g.writeLine(fmt.Sprintf("for _, %s := range %s {", stmt.Variable.Value, collection))
		}
	}

	g.indent++
	g.generateBlock(stmt.Body)
	g.indent--

	g.writeLine("}")
}

func (g *Generator) generateForNumericStmt(stmt *ast.ForNumericStmt) {
	varName := stmt.Variable.Value
	start := g.exprToString(stmt.Start)
	end := g.exprToString(stmt.End)

	var condition string
	if stmt.Through {
		condition = fmt.Sprintf("%s <= %s", varName, end)
	} else {
		condition = fmt.Sprintf("%s < %s", varName, end)
	}

	g.writeLine(fmt.Sprintf("for %s := %s; %s; %s++ {", varName, start, condition, varName))

	g.indent++
	g.generateBlock(stmt.Body)
	g.indent--

	g.writeLine("}")
}

func (g *Generator) generateForConditionStmt(stmt *ast.ForConditionStmt) {
	condition := g.exprToString(stmt.Condition)
	if condition == "true" {
		g.writeLine("for {")
	} else {
		g.writeLine(fmt.Sprintf("for %s {", condition))
	}

	g.indent++
	g.generateBlock(stmt.Body)
	g.indent--

	g.writeLine("}")
}

func (g *Generator) exprToString(expr ast.Expression) string {
	if expr == nil {
		return ""
	}

	switch e := expr.(type) {
	case *ast.Identifier:
		return e.Value
	case *ast.IntegerLiteral:
		// Preserve original representation for octal (0...), hex (0x...), binary (0b...)
		lexeme := e.Token.Lexeme
		if len(lexeme) > 1 && lexeme[0] == '0' {
			return lexeme // Keep original format
		}
		return fmt.Sprintf("%d", e.Value)
	case *ast.FloatLiteral:
		return fmt.Sprintf("%f", e.Value)
	case *ast.RuneLiteral:
		return fmt.Sprintf("'%s'", g.escapeRune(e.Value))
	case *ast.StringLiteral:
		return g.generateStringLiteral(e)
	case *ast.BooleanLiteral:
		if e.Value {
			return "true"
		}
		return "false"
	case *ast.BinaryExpr:
		return g.generateBinaryExpr(e)
	case *ast.UnaryExpr:
		return g.generateUnaryExpr(e)
	case *ast.PipeExpr:
		return g.generatePipeExpr(e)
	case *ast.CallExpr:
		return g.generateCallExpr(e)
	case *ast.MethodCallExpr:
		return g.generateMethodCallExpr(e)
	case *ast.IndexExpr:
		left := g.exprToString(e.Left)
		index := g.exprToString(e.Index)
		return fmt.Sprintf("%s[%s]", left, index)
	case *ast.SliceExpr:
		return g.generateSliceExpr(e)
	case *ast.StructLiteralExpr:
		return g.generateStructLiteral(e)
	case *ast.ListLiteralExpr:
		return g.generateListLiteral(e)
	case *ast.MapLiteralExpr:
		return g.generateMapLiteral(e)
	case *ast.ReceiveExpr:
		channel := g.exprToString(e.Channel)
		return fmt.Sprintf("<-%s", channel)
	case *ast.TypeCastExpr:
		targetType := g.generateTypeAnnotation(e.TargetType)
		expr := g.exprToString(e.Expression)
		// Use type assertion syntax for interface types (contains a dot like http.Handler)
		// or when likely asserting from any/interface
		// Exception: iter.Seq types are functions, so use conversion
		if strings.Contains(targetType, ".") && !strings.Contains(targetType, "iter.Seq") {
			return fmt.Sprintf("%s.(%s)", expr, targetType)
		}
		return fmt.Sprintf("%s(%s)", targetType, expr)
	case *ast.EmptyExpr:
		if e.Type != nil {
			targetType := g.generateTypeAnnotation(e.Type)
			// Check if targetType is a generic type parameter (T, U, K)
			if g.isStdlibIter && g.placeholderMap != nil {
				for _, typeParam := range g.placeholderMap {
					if targetType == typeParam {
						return fmt.Sprintf("*new(%s)", targetType)
					}
				}
			}
			return g.zeroValueForType(e.Type)
		}
		// In generic stdlib/iter context, use *new(T) for zero value instead of nil
		if g.isStdlibIter && g.placeholderMap != nil {
			if _, hasT := g.placeholderMap["any"]; hasT {
				return "*new(T)"
			}
		}
		return "nil"
	case *ast.DiscardExpr:
		return "_"
	case *ast.ErrorExpr:
		message := g.exprToString(e.Message)
		return fmt.Sprintf("errors.New(%s)", message)
	case *ast.ReturnExpr:
		return g.generateReturnExpr(e)
	case *ast.MakeExpr:
		return g.generateMakeExpr(e)
	case *ast.CloseExpr:
		channel := g.exprToString(e.Channel)
		return fmt.Sprintf("close(%s)", channel)
	case *ast.PanicExpr:
		message := g.exprToString(e.Message)
		return fmt.Sprintf("panic(%s)", message)
	case *ast.RecoverExpr:
		return "recover()"
	case *ast.FunctionLiteral:
		return g.generateFunctionLiteral(e)
	case *ast.ArrowLambda:
		return g.generateArrowLambda(e)
	case *ast.AddressOfExpr:
		return g.generateAddressOfExpr(e)
	case *ast.DerefExpr:
		return g.generateDerefExpr(e)
	case *ast.TypeAssertionExpr:
		targetType := g.generateTypeAnnotation(e.TargetType)
		expr := g.exprToString(e.Expression)
		return fmt.Sprintf("%s.(%s)", expr, targetType)
	default:
		return ""
	}
}

// escapeRune returns the Go escape sequence for a rune
func (g *Generator) escapeRune(r rune) string {
	switch r {
	case '\n':
		return "\\n"
	case '\t':
		return "\\t"
	case '\r':
		return "\\r"
	case '\\':
		return "\\\\"
	case '\'':
		return "\\'"
	case '\x00':
		return "\\x00"
	default:
		return string(r)
	}
}

// escapeString returns a string with special characters escaped for Go string literals
func (g *Generator) escapeString(s string) string {
	var result strings.Builder
	for _, r := range s {
		switch r {
		case '\n':
			result.WriteString("\\n")
		case '\t':
			result.WriteString("\\t")
		case '\r':
			result.WriteString("\\r")
		case '\\':
			result.WriteString("\\\\")
		case '"':
			result.WriteString("\\\"")
		case '\x00':
			result.WriteString("\\x00")
		default:
			result.WriteRune(r)
		}
	}
	return result.String()
}

func (g *Generator) generateStringLiteral(lit *ast.StringLiteral) string {
	if !lit.Interpolated {
		return fmt.Sprintf("\"%s\"", g.escapeString(lit.Value))
	}

	// Parse string interpolation
	return g.generateStringInterpolation(lit.Value)
}

func (g *Generator) generateStringInterpolation(str string) string {
	format, args := g.parseStringInterpolation(str)
	if len(args) == 0 {
		return fmt.Sprintf("\"%s\"", format)
	}
	argsStr := strings.Join(args, ", ")
	return fmt.Sprintf("fmt.Sprintf(\"%s\", %s)", format, argsStr)
}

// parseStringInterpolation extracts the format string and arguments from
// a Kukicha string with {expr} interpolation patterns.
// Returns the format string (with %v placeholders) and the list of argument expressions.
func (g *Generator) parseStringInterpolation(str string) (string, []string) {
	// Find all {expr} patterns where expr starts with an identifier character.
	// This avoids matching regex quantifiers like {2,} or {3,5}.
	re := regexp.MustCompile(`\{([a-zA-Z_][^}]*)\}`)
	matches := re.FindAllStringSubmatchIndex(str, -1)

	if len(matches) == 0 {
		return g.escapeString(str), nil
	}

	// Build format string and args
	var format strings.Builder
	args := []string{}
	lastIndex := 0

	for _, match := range matches {
		// Add literal part before the interpolation (escaped)
		if match[0] > lastIndex {
			format.WriteString(g.escapeString(str[lastIndex:match[0]]))
		}

		// Add format specifier
		format.WriteString("%v")

		// Extract expression and transform Kukicha syntax to Go
		expr := str[match[2]:match[3]]
		expr = g.transformInterpolatedExpr(expr)
		args = append(args, expr)

		lastIndex = match[1]
	}

	// Add remaining literal part (escaped)
	if lastIndex < len(str) {
		format.WriteString(g.escapeString(str[lastIndex:]))
	}

	return format.String(), args
}

// transformInterpolatedExpr converts Kukicha expression syntax in string
// interpolation to valid Go syntax.
func (g *Generator) transformInterpolatedExpr(expr string) string {
	// Handle "X as Type" -> "Type(X)" for type conversions
	// This is a simple string-based transformation for common cases
	asRe := regexp.MustCompile(`^(.+)\s+as\s+(\w+)$`)
	if matches := asRe.FindStringSubmatch(strings.TrimSpace(expr)); matches != nil {
		value := strings.TrimSpace(matches[1])
		targetType := matches[2]
		return fmt.Sprintf("%s(%s)", targetType, value)
	}
	return expr
}

func (g *Generator) generateBinaryExpr(expr *ast.BinaryExpr) string {
	left := g.exprToString(expr.Left)
	right := g.exprToString(expr.Right)

	// Map Kukicha operators to Go operators
	op := expr.Operator
	switch op {
	case "and":
		op = "&&"
	case "or":
		op = "||"
	case "equals":
		op = "=="
	case "not equals":
		op = "!="
	}

	return fmt.Sprintf("(%s %s %s)", left, op, right)
}

func (g *Generator) generateUnaryExpr(expr *ast.UnaryExpr) string {
	right := g.exprToString(expr.Right)

	op := expr.Operator
	if op == "not" {
		op = "!"
	}

	return fmt.Sprintf("%s%s", op, right)
}

func (g *Generator) generateAddressOfExpr(expr *ast.AddressOfExpr) string {
	operand := g.exprToString(expr.Operand)
	if isNonAddressable(expr.Operand) {
		return fmt.Sprintf("new(%s)", operand)
	}
	return fmt.Sprintf("&%s", operand)
}

// isNonAddressable returns true for expressions whose results cannot be
// addressed with & in Go (e.g. function/method call return values).
// Go 1.26's new(expr) syntax handles these cases.
func isNonAddressable(expr ast.Expression) bool {
	switch expr.(type) {
	case *ast.CallExpr, *ast.MethodCallExpr:
		return true
	default:
		return false
	}
}

func (g *Generator) generateDerefExpr(expr *ast.DerefExpr) string {
	operand := g.exprToString(expr.Operand)
	return fmt.Sprintf("*%s", operand)
}

func (g *Generator) isContextExpr(expr ast.Expression) bool {
	// Simple type detection for Context
	// 1. Literal 'ctx' identifier
	if id, ok := expr.(*ast.Identifier); ok {
		return id.Value == "ctx"
	}
	// 2. Call to context package (e.g., context.Background(), context.WithTimeout())
	if call, ok := expr.(*ast.CallExpr); ok {
		if id, ok := call.Function.(*ast.Identifier); ok {
			return strings.HasPrefix(id.Value, "context.")
		}
	}
	return false
}

func (g *Generator) getMultiReturnType(expr ast.Expression) (string, bool) {
	// List of known stdlib/fetch functions that return multiple values
	// Maps function name to its primary return type
	multiReturnFuncs := map[string]string{
		"fetch.Get":         "*http.Response",
		"fetch.Post":        "*http.Response",
		"fetch.Do":          "*http.Response",
		"fetch.CheckStatus": "*http.Response",
		"fetch.Text":        "string",
		"fetch.Bytes":       "[]byte",
	}

	var funcName string
	if call, ok := expr.(*ast.CallExpr); ok {
		if id, ok := call.Function.(*ast.Identifier); ok {
			funcName = id.Value
		}
	} else if methodCall, ok := expr.(*ast.MethodCallExpr); ok {
		// Handle package.Function() calls which are parsed as MethodCallExpr
		if obj, ok := methodCall.Object.(*ast.Identifier); ok {
			funcName = obj.Value + "." + methodCall.Method.Value
		}
	} else if pipe, ok := expr.(*ast.PipeExpr); ok {
		// For pipe expression, check the right-most function
		return g.getMultiReturnType(pipe.Right)
	}

	if typeName, ok := multiReturnFuncs[funcName]; ok {
		// Add auto-import if needed
		if strings.Contains(typeName, "http.") {
			g.addImport("net/http")
		}
		return typeName, true
	}

	return "", false
}

// generatePipeExpr transforms pipe expressions into function calls.
//
// ARCHITECTURE NOTE: Kukicha's pipe operator (|>) supports three strategies
// to determine where the piped value is inserted:
//
//	Strategy A (Placeholder): User explicitly marks position with "_"
//	  data |> json.MarshalWrite(w, _)  →  json.MarshalWrite(w, data)
//
//	Strategy B (Data-First): Default - piped value becomes first argument
//	  users |> slice.Filter(fn)  →  slice.Filter(users, fn)
//
//	Strategy C (Context-First): If piped value is a context.Context, special handling
//	  ctx |> db.Query(sql)  →  db.Query(ctx, sql)
//
// The placeholder strategy (A) takes precedence. This design lets users handle
// APIs where the "data" isn't the first parameter, without requiring Kukicha
// to know every function signature in the ecosystem.
func (g *Generator) generatePipeExpr(expr *ast.PipeExpr) string {
	// Transform a |> b() into b(a)
	// Supports placeholder strategy: a |> b(x, _) becomes b(x, a)
	// Supports context-first strategy: ctx |> b(x) becomes b(ctx, x)

	// Calculate Left expression first, handling multi-return values if needed
	leftExpr := g.exprToString(expr.Left)
	if retType, isMulti := g.getMultiReturnType(expr.Left); isMulti {
		// Wrap in a function call to only take the first return value
		// e.g., func() *http.Response { val, _ := fetch.Get(...); return val }()
		leftExpr = fmt.Sprintf("func() %s { val, _ := %s; return val }()", retType, leftExpr)
	}

	// Right side can be a CallExpr or MethodCallExpr
	var funcName string
	var arguments []ast.Expression
	var isVariadic bool

	if call, ok := expr.Right.(*ast.CallExpr); ok {
		funcName = g.exprToString(call.Function)
		// Check if this is a print() builtin - transpile to fmt.Println() or fmt.Fprintln(os.Stderr)
		if id, ok := call.Function.(*ast.Identifier); ok && id.Value == "print" {
			if g.mcpTarget {
				funcName = "fmt.Fprintln"
			} else {
				funcName = "fmt.Println"
			}
		}
		arguments = call.Arguments
		isVariadic = call.Variadic
	} else if method, ok := expr.Right.(*ast.MethodCallExpr); ok {
		objStr := g.exprToString(method.Object)
		if alias, ok := g.pkgAliases[objStr]; ok {
			objStr = alias
		}
		funcName = objStr + "." + method.Method.Value
		if method.Object == nil {
			// Shorthand: .Method() or .Field
			// We will prepend expr.Left as the object
			funcName = leftExpr + "." + method.Method.Value

			if !method.IsCall {
				// Field access: obj.Field
				return funcName
			}

			// Method call: obj.Method(args)
			arguments = method.Arguments
			isVariadic = method.Variadic

			args := make([]string, len(arguments))
			for i, arg := range arguments {
				args[i] = g.exprToString(arg)
			}
			if isVariadic {
				return fmt.Sprintf("%s(%s...)", funcName, strings.Join(args, ", "))
			}
			return fmt.Sprintf("%s(%s)", funcName, strings.Join(args, ", "))
		}
		// Normal method call (already has object)
		if !method.IsCall {
			return funcName
		}
		arguments = method.Arguments
		isVariadic = method.Variadic
	} else {
		// Fallback: If piping into something that isn't a call
		return leftExpr + " |> " + g.exprToString(expr.Right)
	}

	// Scan arguments for the placeholder "_" (either Identifier or DiscardExpr)
	placeholderIndex := -1
	for i, arg := range arguments {
		if ident, isIdent := arg.(*ast.Identifier); isIdent && ident.Value == "_" {
			placeholderIndex = i
			break
		}
		if _, isDiscard := arg.(*ast.DiscardExpr); isDiscard {
			placeholderIndex = i
			break
		}
	}

	// Build the argument list
	var args []string

	if g.mcpTarget && funcName == "fmt.Fprintln" {
		args = append(args, "os.Stderr")
	}

	if placeholderIndex != -1 {
		// STRATEGY A: Explicit placeholder found (e.g., json.MarshalWrite(w, _))
		// Replace "_" with the piped expression
		for i, arg := range arguments {
			if i == placeholderIndex {
				args = append(args, leftExpr)
			} else {
				args = append(args, g.exprToString(arg))
			}
		}
	} else if g.isContextExpr(expr.Left) {
		// STRATEGY C: Context-First Pipe
		// If Left is a Context, it ALWAYS goes to the first argument position
		args = append(args, leftExpr)
		for _, arg := range arguments {
			args = append(args, g.exprToString(arg))
		}
	} else {
		// STRATEGY B: No placeholder -> Default "Data First" pipe
		// Inject piped expr as the VERY FIRST argument
		args = append(args, leftExpr)
		for _, arg := range arguments {
			args = append(args, g.exprToString(arg))
		}
	}

	if isVariadic {
		return fmt.Sprintf("%s(%s...)", funcName, strings.Join(args, ", "))
	}

	// If the piped expression (Left) is a call that returns multiple values,
	// we only want the first one for the next call in the chain.
	// We use a temporary variable if it's a multi-value return.
	// Since we are in exprToString which returns a string, we can't easily
	// inject statements here.
	// However, we can use a helper function or a more complex expression.
	// For now, let's keep it simple - this is a known limitation of the current expr-based codegen.

	return fmt.Sprintf("%s(%s)", funcName, strings.Join(args, ", "))
}

func (g *Generator) generateCallExpr(expr *ast.CallExpr) string {
	funcName := g.exprToString(expr.Function)

	// Check if this is a print() builtin - transpile to fmt.Println() or fmt.Fprintln(os.Stderr)
	if id, ok := expr.Function.(*ast.Identifier); ok {
		if id.Value == "print" {
			if g.mcpTarget {
				funcName = "fmt.Fprintln"
			} else {
				funcName = "fmt.Println"
			}
		}
	}

	// If there are no named arguments and no defaults need filling, use the simple path
	if len(expr.NamedArguments) == 0 {
		needsDefaults := false
		if id, ok := expr.Function.(*ast.Identifier); ok {
			if fd := g.funcDefaults[id.Value]; fd != nil && len(expr.Arguments) < len(fd.ParamNames) {
				needsDefaults = true
			}
		}

		if !needsDefaults {
			args := make([]string, 0, len(expr.Arguments)+1)
			if g.mcpTarget && g.isPrintBuiltin(expr.Function) {
				args = append(args, "os.Stderr")
			}
			for _, arg := range expr.Arguments {
				args = append(args, g.exprToString(arg))
			}

			if expr.Variadic {
				return fmt.Sprintf("%s(%s...)", funcName, strings.Join(args, ", "))
			}
			return fmt.Sprintf("%s(%s)", funcName, strings.Join(args, ", "))
		}
	}

	// Handle named arguments - reorder based on function parameter order
	// Look up function defaults to get parameter names
	var funcDef *FuncDefaults
	if id, ok := expr.Function.(*ast.Identifier); ok {
		funcDef = g.funcDefaults[id.Value]
	}

	if funcDef == nil {
		// Can't resolve function - emit named arguments in order they appear
		args := make([]string, 0, len(expr.Arguments)+len(expr.NamedArguments))
		for _, arg := range expr.Arguments {
			args = append(args, g.exprToString(arg))
		}
		for _, namedArg := range expr.NamedArguments {
			args = append(args, g.exprToString(namedArg.Value))
		}
		if expr.Variadic {
			return fmt.Sprintf("%s(%s...)", funcName, strings.Join(args, ", "))
		}
		return fmt.Sprintf("%s(%s)", funcName, strings.Join(args, ", "))
	}

	// Build argument map from named arguments
	namedArgMap := make(map[string]ast.Expression)
	for _, namedArg := range expr.NamedArguments {
		namedArgMap[namedArg.Name.Value] = namedArg.Value
	}

	// Build final argument list in parameter order
	args := make([]string, len(funcDef.ParamNames))
	positionalIdx := 0

	for i, paramName := range funcDef.ParamNames {
		if positionalIdx < len(expr.Arguments) {
			// Use positional argument
			args[i] = g.exprToString(expr.Arguments[positionalIdx])
			positionalIdx++
		} else if namedVal, ok := namedArgMap[paramName]; ok {
			// Use named argument
			args[i] = g.exprToString(namedVal)
		} else if funcDef.DefaultValues[i] != nil {
			// Use default value
			args[i] = g.exprToString(funcDef.DefaultValues[i])
		} else if i == len(funcDef.ParamNames)-1 && funcDef.HasVariadic {
			// Last parameter is variadic with no args provided - omit it
			args = args[:i]
			break
		} else {
			// Missing argument - this should be caught by semantic analysis
			// For safety, use empty placeholder
			args[i] = "/* missing argument */"
		}
	}

	if expr.Variadic {
		return fmt.Sprintf("%s(%s...)", funcName, strings.Join(args, ", "))
	}
	return fmt.Sprintf("%s(%s)", funcName, strings.Join(args, ", "))
}

func (g *Generator) generateMethodCallExpr(expr *ast.MethodCallExpr) string {
	object := g.exprToString(expr.Object)
	method := expr.Method.Value

	// Rewrite package name if it was auto-aliased due to collision
	if alias, ok := g.pkgAliases[object]; ok {
		object = alias
	}

	// If no parentheses were used, it's field access
	if !expr.IsCall {
		return fmt.Sprintf("%s.%s", object, method)
	}

	// Check if this is a printf-style method (Errorf, Fatalf, Logf, Skipf, Printf, etc.)
	// These methods require a constant format string in Go 1.26+
	if g.isPrintfStyleMethod(method) && len(expr.Arguments) > 0 {
		if strLit, ok := expr.Arguments[0].(*ast.StringLiteral); ok {
			format, formatArgs := g.parseStringInterpolation(strLit.Value)
			if len(formatArgs) > 0 {
				// Generate: t.Errorf("format %v", args...) instead of t.Errorf(fmt.Sprintf(...))
				allArgs := make([]string, 0, len(formatArgs)+len(expr.Arguments)-1)
				allArgs = append(allArgs, formatArgs...)
				// Add remaining arguments after the format string
				for i := 1; i < len(expr.Arguments); i++ {
					allArgs = append(allArgs, g.exprToString(expr.Arguments[i]))
				}
				if expr.Variadic {
					return fmt.Sprintf("%s.%s(\"%s\", %s...)", object, method, format, strings.Join(allArgs, ", "))
				}
				return fmt.Sprintf("%s.%s(\"%s\", %s)", object, method, format, strings.Join(allArgs, ", "))
			}
		}
	}

	// Collect all arguments: positional first, then named (in their declaration order)
	args := make([]string, 0, len(expr.Arguments)+len(expr.NamedArguments))

	// Add positional arguments
	for _, arg := range expr.Arguments {
		args = append(args, g.exprToString(arg))
	}

	// Add named argument values (in the order they appear)
	for _, namedArg := range expr.NamedArguments {
		args = append(args, g.exprToString(namedArg.Value))
	}

	if expr.Variadic {
		return fmt.Sprintf("%s.%s(%s...)", object, method, strings.Join(args, ", "))
	}
	return fmt.Sprintf("%s.%s(%s)", object, method, strings.Join(args, ", "))
}

// isPrintfStyleMethod returns true if the method name is a printf-style method
// that expects a format string as its first argument.
func (g *Generator) isPrintfStyleMethod(method string) bool {
	// Common printf-style methods from testing, fmt, and log packages
	printfMethods := map[string]bool{
		"Errorf":  true,
		"Fatalf":  true,
		"Logf":    true,
		"Skipf":   true,
		"Printf":  true,
		"Sprintf": true,
		"Fprintf": true,
		"Panicf":  true,
		"Warnf":   true,
		"Infof":   true,
		"Debugf":  true,
	}
	return printfMethods[method]
}

func (g *Generator) generateSliceExpr(expr *ast.SliceExpr) string {
	left := g.exprToString(expr.Left)

	var start, end string
	if expr.Start != nil {
		start = g.exprToString(expr.Start)
	}
	if expr.End != nil {
		end = g.exprToString(expr.End)
	}

	return fmt.Sprintf("%s[%s:%s]", left, start, end)
}

func (g *Generator) generateStructLiteral(expr *ast.StructLiteralExpr) string {
	typeName := g.generateTypeAnnotation(expr.Type)

	if len(expr.Fields) == 0 {
		return fmt.Sprintf("%s{}", typeName)
	}

	fields := make([]string, len(expr.Fields))
	for i, field := range expr.Fields {
		value := g.exprToString(field.Value)
		fields[i] = fmt.Sprintf("%s: %s", field.Name.Value, value)
	}

	return fmt.Sprintf("%s{%s}", typeName, strings.Join(fields, ", "))
}

func (g *Generator) generateListLiteral(expr *ast.ListLiteralExpr) string {
	if len(expr.Elements) == 0 {
		if expr.Type != nil {
			elemType := g.generateTypeAnnotation(expr.Type)
			return fmt.Sprintf("[]%s{}", elemType)
		}
		return "[]interface{}{}"
	}

	elements := make([]string, len(expr.Elements))
	for i, elem := range expr.Elements {
		elements[i] = g.exprToString(elem)
	}

	typePrefix := ""
	if expr.Type != nil {
		elemType := g.generateTypeAnnotation(expr.Type)
		typePrefix = fmt.Sprintf("[]%s", elemType)
	} else {
		typePrefix = "[]interface{}"
	}

	return fmt.Sprintf("%s{%s}", typePrefix, strings.Join(elements, ", "))
}

func (g *Generator) generateMapLiteral(expr *ast.MapLiteralExpr) string {
	keyType := g.generateTypeAnnotation(expr.KeyType)
	valType := g.generateTypeAnnotation(expr.ValType)

	if len(expr.Pairs) == 0 {
		return fmt.Sprintf("map[%s]%s{}", keyType, valType)
	}

	pairs := make([]string, len(expr.Pairs))
	for i, pair := range expr.Pairs {
		key := g.exprToString(pair.Key)
		value := g.exprToString(pair.Value)
		pairs[i] = fmt.Sprintf("%s: %s", key, value)
	}

	return fmt.Sprintf("map[%s]%s{%s}", keyType, valType, strings.Join(pairs, ", "))
}

func (g *Generator) generateMakeExpr(expr *ast.MakeExpr) string {
	targetType := g.generateTypeAnnotation(expr.Type)

	if len(expr.Args) == 0 {
		// Slices require a size argument, maps and channels don't
		if strings.HasPrefix(targetType, "[]") {
			return fmt.Sprintf("make(%s, 0)", targetType)
		}
		return fmt.Sprintf("make(%s)", targetType)
	}

	args := make([]string, len(expr.Args))
	for i, arg := range expr.Args {
		args[i] = g.exprToString(arg)
	}

	return fmt.Sprintf("make(%s, %s)", targetType, strings.Join(args, ", "))
}

// Helper methods

func (g *Generator) write(s string) {
	g.output.WriteString(s)
}

func (g *Generator) writeLine(s string) {
	if s != "" {
		g.output.WriteString(g.indentStr() + s)
	}
	g.output.WriteString("\n")
}

func (g *Generator) indentStr() string {
	return strings.Repeat("\t", g.indent)
}

// emitLineDirective writes a //line directive that maps the generated Go code
// back to the original .kuki source file. The Go compiler and runtime honor
// these directives, so compile errors, panics, and stack traces will reference
// the .kuki file instead of the generated .go file.
func (g *Generator) emitLineDirective(pos ast.Position) {
	if pos.Line > 0 && pos.File != "" {
		g.output.WriteString(fmt.Sprintf("//line %s:%d\n", pos.File, pos.Line))
	}
}

// uniqueId generates unique identifiers to prevent variable shadowing
func (g *Generator) uniqueId(prefix string) string {
	g.tempCounter++
	return fmt.Sprintf("%s_%d", prefix, g.tempCounter)
}

func (g *Generator) needsStringInterpolation() bool {
	// Check if any string literals have interpolation
	return g.checkProgramForInterpolation(g.program)
}

func (g *Generator) checkProgramForInterpolation(program *ast.Program) bool {
	for _, decl := range program.Declarations {
		if fn, ok := decl.(*ast.FunctionDecl); ok {
			if fn.Body != nil && g.checkBlockForInterpolation(fn.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) checkBlockForInterpolation(block *ast.BlockStmt) bool {
	for _, stmt := range block.Statements {
		if g.checkStmtForInterpolation(stmt) {
			return true
		}
	}
	return false
}

func (g *Generator) checkStmtForInterpolation(stmt ast.Statement) bool {
	switch s := stmt.(type) {
	case *ast.VarDeclStmt:
		for _, val := range s.Values {
			if g.checkExprForInterpolation(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForInterpolation(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.AssignStmt:
		for _, val := range s.Values {
			if g.checkExprForInterpolation(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForInterpolation(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.ReturnStmt:
		for _, val := range s.Values {
			if g.checkExprForInterpolation(val) {
				return true
			}
		}
	case *ast.IfStmt:
		if g.checkExprForInterpolation(s.Condition) {
			return true
		}
		if s.Consequence != nil && g.checkBlockForInterpolation(s.Consequence) {
			return true
		}
		if s.Alternative != nil {
			return g.checkStmtForInterpolation(s.Alternative)
		}
	case *ast.SwitchStmt:
		if s.Expression != nil && g.checkExprForInterpolation(s.Expression) {
			return true
		}
		for _, c := range s.Cases {
			for _, v := range c.Values {
				if g.checkExprForInterpolation(v) {
					return true
				}
			}
			if c.Body != nil && g.checkBlockForInterpolation(c.Body) {
				return true
			}
		}
		if s.Otherwise != nil && s.Otherwise.Body != nil {
			return g.checkBlockForInterpolation(s.Otherwise.Body)
		}
	case *ast.ForRangeStmt:
		if s.Body != nil {
			return g.checkBlockForInterpolation(s.Body)
		}
	case *ast.ForNumericStmt:
		if s.Body != nil {
			return g.checkBlockForInterpolation(s.Body)
		}
	case *ast.ForConditionStmt:
		if s.Body != nil {
			return g.checkBlockForInterpolation(s.Body)
		}
	case *ast.ExpressionStmt:
		if g.checkExprForInterpolation(s.Expression) {
			return true
		}
		if s.OnErr != nil && g.checkExprForInterpolation(s.OnErr.Handler) {
			return true
		}
	}
	return false
}

func (g *Generator) checkExprForInterpolation(expr ast.Expression) bool {
	if expr == nil {
		return false
	}

	switch e := expr.(type) {
	case *ast.StringLiteral:
		return e.Interpolated
	case *ast.BinaryExpr:
		return g.checkExprForInterpolation(e.Left) || g.checkExprForInterpolation(e.Right)
	case *ast.UnaryExpr:
		return g.checkExprForInterpolation(e.Right)
	case *ast.CallExpr:
		for _, arg := range e.Arguments {
			if g.checkExprForInterpolation(arg) {
				return true
			}
		}
	case *ast.MethodCallExpr:
		// For printf-style methods, skip the first argument (format string)
		// since it's handled inline without fmt.Sprintf
		startIdx := 0
		if g.isPrintfStyleMethod(e.Method.Value) && len(e.Arguments) > 0 {
			startIdx = 1
		}
		for i := startIdx; i < len(e.Arguments); i++ {
			if g.checkExprForInterpolation(e.Arguments[i]) {
				return true
			}
		}
	}

	return false
}

func (g *Generator) needsPrintBuiltin() bool {
	// Check if any calls use the print() builtin
	return g.checkProgramForPrint(g.program)
}

func (g *Generator) checkProgramForPrint(program *ast.Program) bool {
	for _, decl := range program.Declarations {
		if fn, ok := decl.(*ast.FunctionDecl); ok {
			if fn.Body != nil && g.checkBlockForPrint(fn.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) checkBlockForPrint(block *ast.BlockStmt) bool {
	for _, stmt := range block.Statements {
		if g.checkStmtForPrint(stmt) {
			return true
		}
	}
	return false
}

func (g *Generator) checkStmtForPrint(stmt ast.Statement) bool {
	switch s := stmt.(type) {
	case *ast.VarDeclStmt:
		for _, val := range s.Values {
			if g.checkExprForPrint(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForPrint(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.AssignStmt:
		for _, val := range s.Values {
			if g.checkExprForPrint(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForPrint(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.ReturnStmt:
		for _, val := range s.Values {
			if g.checkExprForPrint(val) {
				return true
			}
		}
	case *ast.IfStmt:
		if g.checkExprForPrint(s.Condition) {
			return true
		}
		if s.Consequence != nil && g.checkBlockForPrint(s.Consequence) {
			return true
		}
		if s.Alternative != nil {
			return g.checkStmtForPrint(s.Alternative)
		}
	case *ast.SwitchStmt:
		if s.Expression != nil && g.checkExprForPrint(s.Expression) {
			return true
		}
		for _, c := range s.Cases {
			for _, v := range c.Values {
				if g.checkExprForPrint(v) {
					return true
				}
			}
			if c.Body != nil && g.checkBlockForPrint(c.Body) {
				return true
			}
		}
		if s.Otherwise != nil && s.Otherwise.Body != nil {
			return g.checkBlockForPrint(s.Otherwise.Body)
		}
	case *ast.ForRangeStmt:
		if s.Body != nil {
			return g.checkBlockForPrint(s.Body)
		}
	case *ast.ForNumericStmt:
		if s.Body != nil {
			return g.checkBlockForPrint(s.Body)
		}
	case *ast.ForConditionStmt:
		if s.Body != nil {
			return g.checkBlockForPrint(s.Body)
		}
	case *ast.ExpressionStmt:
		if g.checkExprForPrint(s.Expression) {
			return true
		}
		if s.OnErr != nil && g.checkExprForPrint(s.OnErr.Handler) {
			return true
		}
	case *ast.DeferStmt:
		if s.Call != nil {
			return g.checkExprForPrint(s.Call)
		}
	case *ast.GoStmt:
		if s.Call != nil {
			return g.checkExprForPrint(s.Call)
		}
		if s.Block != nil {
			return g.checkBlockForPrint(s.Block)
		}
	}
	return false
}

func (g *Generator) checkExprForPrint(expr ast.Expression) bool {
	if expr == nil {
		return false
	}

	switch e := expr.(type) {
	case *ast.CallExpr:
		// Check if this is a print() call
		if id, ok := e.Function.(*ast.Identifier); ok {
			if id.Value == "print" {
				return true
			}
		}
		// Also check arguments recursively
		for _, arg := range e.Arguments {
			if g.checkExprForPrint(arg) {
				return true
			}
		}
	case *ast.BinaryExpr:
		return g.checkExprForPrint(e.Left) || g.checkExprForPrint(e.Right)
	case *ast.UnaryExpr:
		return g.checkExprForPrint(e.Right)
	case *ast.MethodCallExpr:
		for _, arg := range e.Arguments {
			if g.checkExprForPrint(arg) {
				return true
			}
		}
	case *ast.PipeExpr:
		return g.checkExprForPrint(e.Left) || g.checkExprForPrint(e.Right)
	case *ast.FunctionLiteral:
		if e.Body != nil {
			return g.checkBlockForPrint(e.Body)
		}
	case *ast.ArrowLambda:
		if e.Body != nil {
			return g.checkExprForPrint(e.Body)
		}
		if e.Block != nil {
			return g.checkBlockForPrint(e.Block)
		}
	}

	return false
}

func (g *Generator) isPrintBuiltin(expr ast.Expression) bool {
	if id, ok := expr.(*ast.Identifier); ok {
		return id.Value == "print"
	}
	return false
}

func (g *Generator) scanForAutoImports() {
	for _, decl := range g.program.Declarations {
		if fn, ok := decl.(*ast.FunctionDecl); ok {
			if fn.Body != nil {
				g.scanBlockForAutoImports(fn.Body)
			}
		}
	}
}

// scanForFunctionDefaults collects function parameter names and default values
// This information is used when generating function calls with named arguments
// or when arguments are omitted (relying on default values)
func (g *Generator) scanForFunctionDefaults() {
	for _, decl := range g.program.Declarations {
		if fn, ok := decl.(*ast.FunctionDecl); ok {
			defaults := &FuncDefaults{
				ParamNames:    make([]string, len(fn.Parameters)),
				DefaultValues: make([]ast.Expression, len(fn.Parameters)),
				HasVariadic:   len(fn.Parameters) > 0 && fn.Parameters[len(fn.Parameters)-1].Variadic,
			}

			for i, param := range fn.Parameters {
				defaults.ParamNames[i] = param.Name.Value
				defaults.DefaultValues[i] = param.DefaultValue // may be nil
			}

			g.funcDefaults[fn.Name.Value] = defaults
		}
	}
}

func (g *Generator) scanBlockForAutoImports(block *ast.BlockStmt) {
	for _, stmt := range block.Statements {
		g.scanStmtForAutoImports(stmt)
	}
}

func (g *Generator) scanStmtForAutoImports(stmt ast.Statement) {
	switch s := stmt.(type) {
	case *ast.VarDeclStmt:
		for _, val := range s.Values {
			g.scanExprForAutoImports(val)
		}
		if s.OnErr != nil {
			g.scanExprForAutoImports(s.OnErr.Handler)
		}
	case *ast.AssignStmt:
		for _, val := range s.Values {
			g.scanExprForAutoImports(val)
		}
		if s.OnErr != nil {
			g.scanExprForAutoImports(s.OnErr.Handler)
		}
	case *ast.ReturnStmt:
		for _, val := range s.Values {
			g.scanExprForAutoImports(val)
		}
	case *ast.IfStmt:
		if s.Init != nil {
			g.scanStmtForAutoImports(s.Init)
		}
		g.scanExprForAutoImports(s.Condition)
		if s.Consequence != nil {
			g.scanBlockForAutoImports(s.Consequence)
		}
		if s.Alternative != nil {
			g.scanStmtForAutoImports(s.Alternative)
		}
	case *ast.SwitchStmt:
		if s.Expression != nil {
			g.scanExprForAutoImports(s.Expression)
		}
		for _, c := range s.Cases {
			for _, v := range c.Values {
				g.scanExprForAutoImports(v)
			}
			if c.Body != nil {
				g.scanBlockForAutoImports(c.Body)
			}
		}
		if s.Otherwise != nil && s.Otherwise.Body != nil {
			g.scanBlockForAutoImports(s.Otherwise.Body)
		}
	case *ast.ForRangeStmt:
		g.scanExprForAutoImports(s.Collection)
		if s.Body != nil {
			g.scanBlockForAutoImports(s.Body)
		}
	case *ast.ForNumericStmt:
		g.scanExprForAutoImports(s.Start)
		g.scanExprForAutoImports(s.End)
		if s.Body != nil {
			g.scanBlockForAutoImports(s.Body)
		}
	case *ast.ForConditionStmt:
		g.scanExprForAutoImports(s.Condition)
		if s.Body != nil {
			g.scanBlockForAutoImports(s.Body)
		}
	case *ast.ExpressionStmt:
		g.scanExprForAutoImports(s.Expression)
		if s.OnErr != nil {
			g.scanExprForAutoImports(s.OnErr.Handler)
		}
	case *ast.DeferStmt:
		g.scanExprForAutoImports(s.Call)
	case *ast.GoStmt:
		if s.Call != nil {
			g.scanExprForAutoImports(s.Call)
		}
		if s.Block != nil {
			g.scanBlockForAutoImports(s.Block)
		}
	case *ast.SendStmt:
		g.scanExprForAutoImports(s.Value)
		g.scanExprForAutoImports(s.Channel)
	case *ast.ElseStmt:
		if s.Body != nil {
			g.scanBlockForAutoImports(s.Body)
		}
	}
}

func (g *Generator) scanExprForAutoImports(expr ast.Expression) {
	if expr == nil {
		return
	}

	switch e := expr.(type) {
	case *ast.BinaryExpr:
		g.scanExprForAutoImports(e.Left)
		g.scanExprForAutoImports(e.Right)
	case *ast.UnaryExpr:
		g.scanExprForAutoImports(e.Right)
	case *ast.PipeExpr:
		// Pipe chains involving fetch.* multi-return functions generate
		// *http.Response wrappers, so we need net/http imported early.
		g.scanPipeForHTTPImport(e)
		g.scanExprForAutoImports(e.Left)
		g.scanExprForAutoImports(e.Right)
	case *ast.CallExpr:
		g.scanExprForAutoImports(e.Function)
		for _, arg := range e.Arguments {
			g.scanExprForAutoImports(arg)
		}
	case *ast.MethodCallExpr:
		g.scanExprForAutoImports(e.Object)
		for _, arg := range e.Arguments {
			g.scanExprForAutoImports(arg)
		}
	case *ast.IndexExpr:
		g.scanExprForAutoImports(e.Left)
		g.scanExprForAutoImports(e.Index)
	case *ast.SliceExpr:
		g.scanExprForAutoImports(e.Left)
		if e.Start != nil {
			g.scanExprForAutoImports(e.Start)
		}
		if e.End != nil {
			g.scanExprForAutoImports(e.End)
		}
	case *ast.FunctionLiteral:
		if e.Body != nil {
			g.scanBlockForAutoImports(e.Body)
		}
	case *ast.ArrowLambda:
		if e.Body != nil {
			g.scanExprForAutoImports(e.Body)
		}
		if e.Block != nil {
			g.scanBlockForAutoImports(e.Block)
		}
	case *ast.StructLiteralExpr:
		for _, f := range e.Fields {
			g.scanExprForAutoImports(f.Value)
		}
	case *ast.ListLiteralExpr:
		for _, el := range e.Elements {
			g.scanExprForAutoImports(el)
		}
	case *ast.MapLiteralExpr:
		for _, p := range e.Pairs {
			g.scanExprForAutoImports(p.Key)
			g.scanExprForAutoImports(p.Value)
		}
	}
}

// scanPipeForHTTPImport checks whether a pipe chain contains fetch.* calls
// that return *http.Response. When piped, these generate wrapper closures that
// reference http.Response explicitly, so net/http must be imported.
func (g *Generator) scanPipeForHTTPImport(pipe *ast.PipeExpr) {
	httpFuncs := map[string]bool{
		"fetch.Get":         true,
		"fetch.Post":        true,
		"fetch.Do":          true,
		"fetch.CheckStatus": true,
	}

	var walkPipe func(expr ast.Expression)
	walkPipe = func(expr ast.Expression) {
		switch e := expr.(type) {
		case *ast.PipeExpr:
			walkPipe(e.Left)
			walkPipe(e.Right)
		case *ast.MethodCallExpr:
			if obj, ok := e.Object.(*ast.Identifier); ok {
				if httpFuncs[obj.Value+"."+e.Method.Value] {
					g.addImport("net/http")
				}
			}
		case *ast.CallExpr:
			if id, ok := e.Function.(*ast.Identifier); ok {
				if httpFuncs[id.Value] {
					g.addImport("net/http")
				}
			}
		}
	}
	walkPipe(pipe)
}

func (g *Generator) needsErrorsPackage() bool {
	// Check if any error expressions are used
	return g.checkProgramForErrors(g.program)
}

func (g *Generator) checkProgramForErrors(program *ast.Program) bool {
	for _, decl := range program.Declarations {
		if fn, ok := decl.(*ast.FunctionDecl); ok {
			if fn.Body != nil && g.checkBlockForErrors(fn.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) checkBlockForErrors(block *ast.BlockStmt) bool {
	for _, stmt := range block.Statements {
		if g.checkStmtForErrors(stmt) {
			return true
		}
	}
	return false
}

func (g *Generator) checkStmtForErrors(stmt ast.Statement) bool {
	switch s := stmt.(type) {
	case *ast.VarDeclStmt:
		for _, val := range s.Values {
			if g.checkExprForErrors(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForErrors(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.AssignStmt:
		for _, val := range s.Values {
			if g.checkExprForErrors(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForErrors(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.ReturnStmt:
		for _, val := range s.Values {
			if g.checkExprForErrors(val) {
				return true
			}
		}
	case *ast.IfStmt:
		if g.checkExprForErrors(s.Condition) {
			return true
		}
		if s.Consequence != nil && g.checkBlockForErrors(s.Consequence) {
			return true
		}
		if s.Alternative != nil {
			return g.checkStmtForErrors(s.Alternative)
		}
	case *ast.SwitchStmt:
		if s.Expression != nil && g.checkExprForErrors(s.Expression) {
			return true
		}
		for _, c := range s.Cases {
			for _, v := range c.Values {
				if g.checkExprForErrors(v) {
					return true
				}
			}
			if c.Body != nil && g.checkBlockForErrors(c.Body) {
				return true
			}
		}
		if s.Otherwise != nil && s.Otherwise.Body != nil {
			return g.checkBlockForErrors(s.Otherwise.Body)
		}
	case *ast.ForRangeStmt:
		if s.Body != nil {
			return g.checkBlockForErrors(s.Body)
		}
	case *ast.ForNumericStmt:
		if s.Body != nil {
			return g.checkBlockForErrors(s.Body)
		}
	case *ast.ForConditionStmt:
		if s.Body != nil {
			return g.checkBlockForErrors(s.Body)
		}
	case *ast.GoStmt:
		if s.Call != nil && g.checkExprForErrors(s.Call) {
			return true
		}
		if s.Block != nil && g.checkBlockForErrors(s.Block) {
			return true
		}
	case *ast.ExpressionStmt:
		if g.checkExprForErrors(s.Expression) {
			return true
		}
		if s.OnErr != nil && g.checkExprForErrors(s.OnErr.Handler) {
			return true
		}
	}
	return false
}

func (g *Generator) checkExprForErrors(expr ast.Expression) bool {
	if expr == nil {
		return false
	}

	switch e := expr.(type) {
	case *ast.ErrorExpr:
		_ = e // Silence unused variable warning
		return true
	case *ast.Identifier:
		return false
	case *ast.BinaryExpr:
		return g.checkExprForErrors(e.Left) || g.checkExprForErrors(e.Right)
	case *ast.UnaryExpr:
		return g.checkExprForErrors(e.Right)
	case *ast.CallExpr:
		for _, arg := range e.Arguments {
			if g.checkExprForErrors(arg) {
				return true
			}
		}
	case *ast.MethodCallExpr:
		for _, arg := range e.Arguments {
			if g.checkExprForErrors(arg) {
				return true
			}
		}
	case *ast.PipeExpr:
		return g.checkExprForErrors(e.Left) || g.checkExprForErrors(e.Right)
	case *ast.FunctionLiteral:
		if e.Body != nil {
			return g.checkBlockForErrors(e.Body)
		}
	case *ast.ArrowLambda:
		if e.Body != nil {
			return g.checkExprForErrors(e.Body)
		}
		if e.Block != nil {
			return g.checkBlockForErrors(e.Block)
		}
	}

	return false
}
func (g *Generator) generateReturnExpr(expr *ast.ReturnExpr) string {
	values := make([]string, len(expr.Values))
	for i, v := range expr.Values {
		values[i] = g.exprToString(v)
	}
	return "return " + strings.Join(values, ", ")
}
