package codegen

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/duber000/kukicha/internal/ast"
)

// TypeParameter represents a type parameter for stdlib special transpilation
// This is internal to codegen and separate from the removed ast.TypeParameter
type TypeParameter struct {
	Name        string // Generated name: T, U, V, etc.
	Placeholder string // Original placeholder: "any", "any2", etc.
	Constraint  string // "any", "comparable", "cmp.Ordered"
}

// Generator generates Go code from an AST
type Generator struct {
	program              *ast.Program
	output               strings.Builder
	indent               int
	placeholderMap       map[string]string // Maps placeholder names to type param names (e.g., "element" -> "T")
	autoImports          map[string]bool   // Tracks auto-imports needed (e.g., "cmp" for generic constraints)
	isStdlibIter         bool              // True if generating stdlib/iter code (enables special transpilation)
	sourceFile           string            // Source file path for detecting stdlib
	currentFuncName      string            // Current function being generated (for context-aware decisions)
	processingReturnType bool              // Whether we are currently generating return types
	tempCounter          int               // Counter for generating unique temporary variable names
}

// New creates a new code generator
func New(program *ast.Program) *Generator {
	return &Generator{
		program:     program,
		indent:      0,
		autoImports: make(map[string]bool),
	}
}

// SetSourceFile sets the source file path and detects if special transpilation is needed
func (g *Generator) SetSourceFile(path string) {
	g.sourceFile = path
	// Enable special transpilation for stdlib/iter files
	g.isStdlibIter = strings.Contains(path, "stdlib/iter/") || strings.Contains(path, "stdlib\\iter\\")
	// Note: stdlib/slice uses a different approach - type parameters are detected per-function
}

// addImport adds an auto-import
func (g *Generator) addImport(path string) {
	g.autoImports[path] = true
}

// Generate generates Go code from the AST
func (g *Generator) Generate() (string, error) {
	g.output.Reset()

	// Generate comment about Go 1.25+ optimization options
	// Users can enable experimental features for better performance
	g.writeLine("// Generated by Kukicha v1.0.0 (requires Go 1.25+)")
	g.writeLine("//")
	g.writeLine("// Performance options:")
	g.writeLine("//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)")
	g.writeLine("//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)")
	g.writeLine("")

	// Generate package declaration
	g.generatePackage()

	// Generate imports (including auto-imports like fmt for string interpolation and print builtin)
	needsFmt := g.needsStringInterpolation() || g.needsPrintBuiltin()
	if len(g.program.Imports) > 0 || needsFmt || len(g.autoImports) > 0 {
		g.writeLine("")
		g.generateImports()
	}

	// Generate declarations
	for _, decl := range g.program.Declarations {
		g.writeLine("")
		g.generateDeclaration(decl)
	}

	return g.output.String(), nil
}

func (g *Generator) generatePackage() {
	packageName := "main"
	if g.program.PetioleDecl != nil {
		packageName = g.program.PetioleDecl.Name.Value
	}
	g.writeLine(fmt.Sprintf("package %s", packageName))
}

func (g *Generator) generateImports() {
	// Collect all imports
	imports := make(map[string]string) // path -> alias

	for _, imp := range g.program.Imports {
		path := imp.Path.Value
		alias := ""
		if imp.Alias != nil {
			alias = imp.Alias.Value
		}

		// Rewrite stdlib imports to full module path
		path = g.rewriteStdlibImport(path)

		imports[path] = alias
	}

	// Check if we need fmt for string interpolation or print builtin
	needsFmt := g.needsStringInterpolation() || g.needsPrintBuiltin()
	if needsFmt {
		imports["fmt"] = ""
	}

	// Check if we need errors for error expressions
	needsErrors := g.needsErrorsPackage()
	if needsErrors {
		imports["errors"] = ""
	}

	// Add auto-imports (e.g., cmp for generic constraints)
	for path := range g.autoImports {
		if _, exists := imports[path]; !exists {
			imports[path] = ""
		}
	}

	// Generate import block
	if len(imports) == 1 {
		for path, alias := range imports {
			if alias != "" {
				g.writeLine(fmt.Sprintf("import %s \"%s\"", alias, path))
			} else {
				g.writeLine(fmt.Sprintf("import \"%s\"", path))
			}
		}
	} else {
		g.writeLine("import (")
		g.indent++
		for path, alias := range imports {
			if alias != "" {
				g.writeLine(fmt.Sprintf("%s \"%s\"", alias, path))
			} else {
				g.writeLine(fmt.Sprintf("\"%s\"", path))
			}
		}
		g.indent--
		g.writeLine(")")
	}
}

// rewriteStdlibImport rewrites stdlib/ import paths to full module paths
// e.g., "stdlib/json" → "github.com/duber000/kukicha/stdlib/json"
// Note: Returns path without quotes (quotes are added by generateImports)
func (g *Generator) rewriteStdlibImport(path string) string {
	// Remove quotes to check the path
	cleanPath := strings.Trim(path, "\"")

	// Rewrite stdlib/ prefix to full module path
	if strings.HasPrefix(cleanPath, "stdlib/") {
		return "github.com/duber000/kukicha/" + cleanPath
	}

	return cleanPath
}

func (g *Generator) generateDeclaration(decl ast.Declaration) {
	switch d := decl.(type) {
	case *ast.TypeDecl:
		g.generateTypeDecl(d)
	case *ast.InterfaceDecl:
		g.generateInterfaceDecl(d)
	case *ast.FunctionDecl:
		g.generateFunctionDecl(d)
	}
}

func (g *Generator) generateTypeDecl(decl *ast.TypeDecl) {
	g.write(fmt.Sprintf("type %s struct {", decl.Name.Value))
	g.writeLine("")
	g.indent++

	for _, field := range decl.Fields {
		fieldType := g.generateTypeAnnotation(field.Type)
		line := fmt.Sprintf("%s %s", field.Name.Value, fieldType)
		if field.Tag != "" {
			line += fmt.Sprintf(" `%s`", field.Tag)
		}
		g.writeLine(line)
	}

	g.indent--
	g.writeLine("}")
}

func (g *Generator) generateInterfaceDecl(decl *ast.InterfaceDecl) {
	g.write(fmt.Sprintf("type %s interface {", decl.Name.Value))
	g.writeLine("")
	g.indent++

	for _, method := range decl.Methods {
		// Generate method signature
		params := g.generateParameters(method.Parameters)
		returns := g.generateReturnTypes(method.Returns)

		if returns != "" {
			g.writeLine(fmt.Sprintf("%s(%s) %s", method.Name.Value, params, returns))
		} else {
			g.writeLine(fmt.Sprintf("%s(%s)", method.Name.Value, params))
		}
	}

	g.indent--
	g.writeLine("}")
}

func (g *Generator) generateFunctionDecl(decl *ast.FunctionDecl) {
	// Set up placeholder mapping for this function
	g.placeholderMap = make(map[string]string)

	g.currentFuncName = decl.Name.Value

	// Check if this is a stdlib function that needs special transpilation
	var typeParams []*TypeParameter
	if g.isStdlibIter {
		// Generate type parameters from function signature for iter
		typeParams = g.inferStdlibTypeParameters(decl)
		for _, tp := range typeParams {
			g.placeholderMap[tp.Placeholder] = tp.Name
		}
	} else if g.isStdlibSlice() {
		// Generate type parameters from function signature for slice
		typeParams = g.inferSliceTypeParameters(decl)
		for _, tp := range typeParams {
			g.placeholderMap[tp.Placeholder] = tp.Name
		}
	}

	// Generate function signature
	signature := "func "

	// Add receiver for methods
	if decl.Receiver != nil {
		receiverType := g.generateTypeAnnotation(decl.Receiver.Type)
		receiverName := decl.Receiver.Name.Value
		signature += fmt.Sprintf("(%s %s) ", receiverName, receiverType)
	}

	// Add function name
	signature += decl.Name.Value

	// Add type parameters if present
	if len(typeParams) > 0 {
		signature += g.generateTypeParameters(typeParams)
	}

	// Add parameters
	params := g.generateFunctionParameters(decl.Parameters)
	signature += fmt.Sprintf("(%s)", params)

	// Add return types
	g.processingReturnType = true
	returns := g.generateReturnTypes(decl.Returns)
	g.processingReturnType = false

	if returns != "" {
		signature += " " + returns
	}

	g.write(signature + " {")
	g.writeLine("")

	// Generate body
	if decl.Body != nil {
		g.indent++
		g.generateBlock(decl.Body)
		g.indent--
	}

	g.writeLine("}")

	// Clear placeholder mapping
	g.placeholderMap = nil
	g.currentFuncName = ""
}

func (g *Generator) generateFunctionLiteral(lit *ast.FunctionLiteral) string {
	// Save current placeholder map and create new one for this literal
	oldPlaceholderMap := g.placeholderMap
	g.placeholderMap = make(map[string]string)

	// Inherit placeholders from parent scope
	for k, v := range oldPlaceholderMap {
		g.placeholderMap[k] = v
	}

	// Check if this is a stdlib/iter function literal that needs special transpilation
	var typeParams []*TypeParameter
	if g.isStdlibIter {
		// Create a temporary function decl to reuse the inference logic
		tempDecl := &ast.FunctionDecl{
			Name:       &ast.Identifier{Value: ""}, // dummy name for inference
			Parameters: lit.Parameters,
			Returns:    lit.Returns,
		}
		typeParams = g.inferStdlibTypeParameters(tempDecl)
		for _, tp := range typeParams {
			g.placeholderMap[tp.Placeholder] = tp.Name
		}
	}

	// Generate function signature
	signature := "func"

	// Add type parameters if present
	if len(typeParams) > 0 {
		signature += g.generateTypeParameters(typeParams)
	}

	// Add parameters
	params := g.generateFunctionParameters(lit.Parameters)
	signature += fmt.Sprintf("(%s)", params)

	// Add return types
	returns := g.generateReturnTypes(lit.Returns)
	if returns != "" {
		signature += " " + returns
	}

	// Generate body inline - create temporary generator to capture output
	tempGen := &Generator{
		program:        g.program,
		output:         strings.Builder{},
		indent:         g.indent + 1,
		placeholderMap: g.placeholderMap,
		autoImports:    g.autoImports,
		isStdlibIter:   g.isStdlibIter,
		sourceFile:     g.sourceFile,
	}

	result := signature + " {\n"

	if lit.Body != nil {
		// Generate body statements using temporary generator
		for _, stmt := range lit.Body.Statements {
			tempGen.generateStatement(stmt)
		}
		result += tempGen.output.String()
	}

	// Add proper indentation for closing brace
	for i := 0; i < g.indent; i++ {
		result += "\t"
	}
	result += "}"

	// Restore placeholder mapping
	g.placeholderMap = oldPlaceholderMap

	return result
}

// inferStdlibTypeParameters infers type parameters for stdlib/iter functions
// This enables special transpilation where iter.Seq → iter.Seq[T]
func (g *Generator) inferStdlibTypeParameters(decl *ast.FunctionDecl) []*TypeParameter {
	var typeParams []*TypeParameter
	usesIterSeq := false
	needsTwoTypes := false

	// Check if function uses iter.Seq
	for _, param := range decl.Parameters {
		if g.isIterSeqType(param.Type) {
			usesIterSeq = true
			break
		}
	}

	for _, ret := range decl.Returns {
		if g.isIterSeqType(ret) {
			usesIterSeq = true
			break
		}
	}

	// Check if function transforms types (like Map: T → U)
	if decl.Name.Value == "Map" || decl.Name.Value == "FlatMap" {
		needsTwoTypes = true
	}

	// Generate type parameters
	if usesIterSeq {
		typeParams = append(typeParams, &TypeParameter{
			Name:        "T",
			Placeholder: "any",
			Constraint:  "any",
		})

		if needsTwoTypes {
			typeParams = append(typeParams, &TypeParameter{
				Name:        "U",
				Placeholder: "any2",
				Constraint:  "any",
			})
		}
	}

	return typeParams
}

// isStdlibSlice checks if we're generating code in stdlib/slice
func (g *Generator) isStdlibSlice() bool {
	return strings.Contains(g.sourceFile, "stdlib/slice/") || strings.Contains(g.sourceFile, "stdlib\\slice\\")
}

// inferSliceTypeParameters infers type parameters for stdlib/slice functions like GroupBy
// GroupBy needs two type parameters: T (element type) and K (key type, must be comparable)
func (g *Generator) inferSliceTypeParameters(decl *ast.FunctionDecl) []*TypeParameter {
	var typeParams []*TypeParameter

	// Special handling for GroupBy: func GroupBy(items list of any, keyFunc func(any) any2) map of any2 to list of any
	if decl.Name.Value == "GroupBy" {
		// GroupBy returns map[K][]T where K is the key type and T is the element type
		// The function signature uses placeholders: "any" for T, "any2" for K
		typeParams = append(typeParams, &TypeParameter{
			Name:        "T",
			Placeholder: "any",
			Constraint:  "any",
		})
		typeParams = append(typeParams, &TypeParameter{
			Name:        "K",
			Placeholder: "any2",
			Constraint:  "comparable",
		})
	}

	return typeParams
}

// isIterSeqType checks if a type is iter.Seq (to be made generic)
func (g *Generator) isIterSeqType(typeAnn ast.TypeAnnotation) bool {
	if namedType, ok := typeAnn.(*ast.NamedType); ok {
		// Check for "iter.Seq" or just "Seq" in iter context
		return namedType.Name == "iter.Seq" ||
			(g.isStdlibIter && namedType.Name == "Seq")
	}
	return false
}

// generateTypeParameters generates Go generic type parameter list
func (g *Generator) generateTypeParameters(typeParams []*TypeParameter) string {
	if len(typeParams) == 0 {
		return ""
	}

	parts := make([]string, len(typeParams))
	for i, tp := range typeParams {
		constraint := tp.Constraint
		if constraint == "cmp.Ordered" {
			g.addImport("cmp")
		}
		parts[i] = fmt.Sprintf("%s %s", tp.Name, constraint)
	}

	return "[" + strings.Join(parts, ", ") + "]"
}

func (g *Generator) generateFunctionParameters(params []*ast.Parameter) string {
	if len(params) == 0 {
		return ""
	}

	parts := make([]string, len(params))
	for i, param := range params {
		paramType := g.generateTypeAnnotation(param.Type)
		if param.Variadic {
			// Variadic parameter: use ...Type syntax
			parts[i] = fmt.Sprintf("%s ...%s", param.Name.Value, paramType)
		} else {
			parts[i] = fmt.Sprintf("%s %s", param.Name.Value, paramType)
		}
	}

	return strings.Join(parts, ", ")
}

func (g *Generator) generateParameters(params []*ast.Parameter) string {
	return g.generateFunctionParameters(params)
}

func (g *Generator) generateReturnTypes(returns []ast.TypeAnnotation) string {
	if len(returns) == 0 {
		return ""
	}

	if len(returns) == 1 {
		return g.generateTypeAnnotation(returns[0])
	}

	// Multiple return types
	parts := make([]string, len(returns))
	for i, ret := range returns {
		parts[i] = g.generateTypeAnnotation(ret)
	}

	return "(" + strings.Join(parts, ", ") + ")"
}

func (g *Generator) generateTypeAnnotation(typeAnn ast.TypeAnnotation) string {
	if typeAnn == nil {
		return ""
	}

	switch t := typeAnn.(type) {
	case *ast.PrimitiveType:
		if g.placeholderMap != nil {
			if typeParam, ok := g.placeholderMap[t.Name]; ok {
				return typeParam
			}
		}
		return t.Name
	case *ast.NamedType:
		if g.placeholderMap != nil {
			if typeParam, ok := g.placeholderMap[t.Name]; ok {
				return typeParam
			}
		}
		// Special handling for iter.Seq in stdlib mode
		if g.isStdlibIter && g.placeholderMap != nil {
			if g.isIterSeqType(t) {
				// Transform iter.Seq → iter.Seq[T]
				if _, ok := g.placeholderMap["any"]; ok {
					typeParam := "T"
					// If this is a return type for a transforming function, use U
					if g.processingReturnType && (g.currentFuncName == "Map" || g.currentFuncName == "FlatMap") {
						if _, hasU := g.placeholderMap["any2"]; hasU {
							typeParam = "U"
						}
					}
					return "iter.Seq[" + typeParam + "]"
				}
			}

			// iter.SeqU → iter.Seq[U]
			if t.Name == "iter.SeqU" {
				return "iter.Seq[U]"
			}

			// iter.Seq2 → iter.Seq2[T, U] or iter.Seq2[int, T] (for Enumerate)
			if t.Name == "iter.Seq2" {
				if g.currentFuncName == "Enumerate" {
					return "iter.Seq2[int, T]"
				}
				return "iter.Seq2[T, U]"
			}

			// iter.SeqSlice → iter.Seq[[]T] (for Chunk)
			if t.Name == "iter.SeqSlice" {
				return "iter.Seq[[]T]"
			}
		}
		return t.Name
	case *ast.ReferenceType:
		return "*" + g.generateTypeAnnotation(t.ElementType)
	case *ast.ListType:
		return "[]" + g.generateTypeAnnotation(t.ElementType)
	case *ast.MapType:
		keyType := g.generateTypeAnnotation(t.KeyType)
		valueType := g.generateTypeAnnotation(t.ValueType)
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
		// Note: keyType and valueType already have placeholders substituted via recursion
	case *ast.ChannelType:
		return "chan " + g.generateTypeAnnotation(t.ElementType)
	case *ast.FunctionType:
		// Generate Go function type: func(params) returns
		var paramTypes []string
		for _, param := range t.Parameters {
			paramTypes = append(paramTypes, g.generateTypeAnnotation(param))
		}

		result := "func(" + strings.Join(paramTypes, ", ") + ")"

		if len(t.Returns) == 1 {
			result += " " + g.generateTypeAnnotation(t.Returns[0])
		} else if len(t.Returns) > 1 {
			var returnTypes []string
			for _, ret := range t.Returns {
				returnTypes = append(returnTypes, g.generateTypeAnnotation(ret))
			}
			result += " (" + strings.Join(returnTypes, ", ") + ")"
		}

		return result
	default:
		return "interface{}"
	}
}

func (g *Generator) generateBlock(block *ast.BlockStmt) {
	for _, stmt := range block.Statements {
		g.generateStatement(stmt)
	}
}

func (g *Generator) generateStatement(stmt ast.Statement) {
	switch s := stmt.(type) {
	case *ast.VarDeclStmt:
		g.generateVarDeclStmt(s)
	case *ast.AssignStmt:
		g.generateAssignStmt(s)
	case *ast.IncDecStmt:
		g.generateIncDecStmt(s)
	case *ast.ReturnStmt:
		g.generateReturnStmt(s)
	case *ast.IfStmt:
		g.generateIfStmt(s)
	case *ast.ForRangeStmt:
		g.generateForRangeStmt(s)
	case *ast.ForNumericStmt:
		g.generateForNumericStmt(s)
	case *ast.ForConditionStmt:
		g.generateForConditionStmt(s)
	case *ast.DeferStmt:
		g.writeLine("defer " + g.exprToString(s.Call))
	case *ast.GoStmt:
		g.writeLine("go " + g.exprToString(s.Call))
	case *ast.SendStmt:
		channel := g.exprToString(s.Channel)
		value := g.exprToString(s.Value)
		g.writeLine(fmt.Sprintf("%s <- %s", channel, value))
	case *ast.ContinueStmt:
		g.writeLine("continue")
	case *ast.BreakStmt:
		g.writeLine("break")
	case *ast.ExpressionStmt:
		if s.OnErr != nil {
			g.generateOnErrStmt(s.Expression, s.OnErr)
		} else {
			g.writeLine(g.exprToString(s.Expression))
		}
	}
}

func (g *Generator) generateVarDeclStmt(stmt *ast.VarDeclStmt) {
	// Check for onerr clause on the statement
	if stmt.OnErr != nil {
		g.generateOnErrVarDecl(stmt.Names, stmt.Values, stmt.OnErr)
		return
	}

	// Build comma-separated list of names
	names := make([]string, len(stmt.Names))
	for i, n := range stmt.Names {
		names[i] = n.Value
	}
	namesStr := strings.Join(names, ", ")

	// Build comma-separated list of values
	values := make([]string, len(stmt.Values))
	for i, v := range stmt.Values {
		// Special case: multi-value declaration with TypeCastExpr should use assertion syntax
		// e.g., val, ok := x as Type -> val, ok := x.(Type)
		if len(stmt.Names) == 2 && len(stmt.Values) == 1 {
			if typeCast, ok := v.(*ast.TypeCastExpr); ok {
				targetType := g.generateTypeAnnotation(typeCast.TargetType)
				expr := g.exprToString(typeCast.Expression)
				values[i] = fmt.Sprintf("%s.(%s)", expr, targetType)
				continue
			}
		}
		values[i] = g.exprToString(v)
	}
	valuesStr := strings.Join(values, ", ")

	if stmt.Type != nil {
		// Explicit type declaration
		varType := g.generateTypeAnnotation(stmt.Type)
		g.writeLine(fmt.Sprintf("var %s %s = %s", namesStr, varType, valuesStr))
	} else {
		// Type inference with :=
		g.writeLine(fmt.Sprintf("%s := %s", namesStr, valuesStr))
	}
}

// generateOnErrVarDecl handles variable declarations with onerr
// e.g., val := foo() onerr panic "error" → val, err := foo(); if err != nil { panic("error") }
// e.g., port := getPort() onerr "8080" → port, err := getPort(); if err != nil { port = "8080" }
func (g *Generator) generateOnErrVarDecl(names []*ast.Identifier, values []ast.Expression, clause *ast.OnErrClause) {
	// Build the value expression string (typically a single call expression)
	valuesStr := make([]string, len(values))
	for i, v := range values {
		valuesStr[i] = g.exprToString(v)
	}
	valueExpr := strings.Join(valuesStr, ", ")

	// Check for discard case first - we can skip error handling entirely
	if _, isDiscard := clause.Handler.(*ast.DiscardExpr); isDiscard {
		// For discard, just ignore the error by using _
		var lhsParts []string
		for _, name := range names {
			lhsParts = append(lhsParts, name.Value)
		}
		lhsParts = append(lhsParts, "_")
		g.writeLine(fmt.Sprintf("%s := %s", strings.Join(lhsParts, ", "), valueExpr))
		return
	}

	// Generate unique error variable name to prevent shadowing
	errVar := g.uniqueId("err")

	// Build the LHS: user variables + error variable
	var lhsParts []string
	for _, name := range names {
		lhsParts = append(lhsParts, name.Value)
	}
	lhsParts = append(lhsParts, errVar)

	// Generate: names..., err := expression
	g.writeLine(fmt.Sprintf("%s := %s", strings.Join(lhsParts, ", "), valueExpr))

	// Generate error check block
	g.writeLine(fmt.Sprintf("if %s != nil {", errVar))
	g.indent++
	g.generateOnErrHandler(names, clause.Handler)
	g.indent--
	g.writeLine("}")
}

// generateOnErrHandler generates code for the onerr handler expression
func (g *Generator) generateOnErrHandler(names []*ast.Identifier, handler ast.Expression) {
	switch h := handler.(type) {
	case *ast.PanicExpr:
		// onerr panic "message"
		g.writeLine(g.exprToString(h))
	case *ast.ErrorExpr:
		// onerr return empty, error - generate return with error
		// This assumes the function returns (T, error)
		if len(names) > 0 {
			// Return zero value for first var and the error
			g.writeLine(fmt.Sprintf("return %s, %s", names[0].Value, g.exprToString(h)))
		} else {
			g.writeLine(fmt.Sprintf("return %s", g.exprToString(h)))
		}
	case *ast.ReturnExpr:
		// onerr return empty, error
		g.writeLine(g.exprToString(h))
	case *ast.EmptyExpr:
		// onerr return empty - generate bare return (for named return values)
		g.writeLine("return")
	default:
		// onerr expression (default value case)
		// e.g., port := getPort() onerr "8080"
		// Assign the default value to the first variable
		if len(names) > 0 {
			g.writeLine(fmt.Sprintf("%s = %s", names[0].Value, g.exprToString(handler)))
		}
	}
}

// generateOnErrStmt handles statement-level onerr
// e.g., todo |> json.MarshalWrite(w, _) onerr panic("failed")
// Generates: if err := json.MarshalWrite(w, todo); err != nil { panic("failed") }
func (g *Generator) generateOnErrStmt(expr ast.Expression, clause *ast.OnErrClause) {
	// Check for discard case - just execute and ignore error
	if _, isDiscard := clause.Handler.(*ast.DiscardExpr); isDiscard {
		// Generate: _, _ = expression (or just call it if it returns nothing)
		g.writeLine(fmt.Sprintf("_, _ = %s", g.exprToString(expr)))
		return
	}

	// Generate unique error variable name
	errVar := g.uniqueId("err")

	// Generate: if err := expression; err != nil { handler }
	g.writeLine(fmt.Sprintf("if %s := %s; %s != nil {", errVar, g.exprToString(expr), errVar))
	g.indent++

	// Generate the error handler (no variable names for statement-level)
	g.generateOnErrHandler([]*ast.Identifier{}, clause.Handler)

	g.indent--
	g.writeLine("}")
}

func (g *Generator) generateAssignStmt(stmt *ast.AssignStmt) {
	// Check for onerr clause on assignment
	if stmt.OnErr != nil {
		g.generateOnErrAssign(stmt)
		return
	}

	// Build comma-separated list of targets
	targets := make([]string, len(stmt.Targets))
	for i, t := range stmt.Targets {
		targets[i] = g.exprToString(t)
	}
	targetsStr := strings.Join(targets, ", ")

	// Build comma-separated list of values
	values := make([]string, len(stmt.Values))
	for i, v := range stmt.Values {
		// Special case: multi-value assignment with TypeCastExpr should use assertion syntax
		// e.g., val, ok := x as Type -> val, ok := x.(Type)
		if len(stmt.Targets) == 2 && len(stmt.Values) == 1 {
			if typeCast, ok := v.(*ast.TypeCastExpr); ok {
				targetType := g.generateTypeAnnotation(typeCast.TargetType)
				expr := g.exprToString(typeCast.Expression)
				values[i] = fmt.Sprintf("%s.(%s)", expr, targetType)
				continue
			}
		}
		values[i] = g.exprToString(v)
	}
	valuesStr := strings.Join(values, ", ")

	g.writeLine(fmt.Sprintf("%s = %s", targetsStr, valuesStr))
}

// generateOnErrAssign handles assignment statements with onerr
// e.g., x = foo() onerr panic "error" → x, err = foo(); if err != nil { panic("error") }
func (g *Generator) generateOnErrAssign(stmt *ast.AssignStmt) {
	clause := stmt.OnErr

	// Build value expression
	valuesStr := make([]string, len(stmt.Values))
	for i, v := range stmt.Values {
		valuesStr[i] = g.exprToString(v)
	}
	valueExpr := strings.Join(valuesStr, ", ")

	// Build target names for handler (convert targets to identifiers where possible)
	var names []*ast.Identifier
	for _, t := range stmt.Targets {
		if ident, ok := t.(*ast.Identifier); ok {
			names = append(names, ident)
		}
	}

	// Check for discard case
	if _, isDiscard := clause.Handler.(*ast.DiscardExpr); isDiscard {
		var lhsParts []string
		for _, t := range stmt.Targets {
			lhsParts = append(lhsParts, g.exprToString(t))
		}
		lhsParts = append(lhsParts, "_")
		g.writeLine(fmt.Sprintf("%s = %s", strings.Join(lhsParts, ", "), valueExpr))
		return
	}

	// Generate unique error variable name
	errVar := g.uniqueId("err")

	// Build the LHS: targets + error variable
	var lhsParts []string
	for _, t := range stmt.Targets {
		lhsParts = append(lhsParts, g.exprToString(t))
	}
	lhsParts = append(lhsParts, errVar)

	// Generate: targets..., err = expression
	g.writeLine(fmt.Sprintf("%s = %s", strings.Join(lhsParts, ", "), valueExpr))

	// Generate error check block
	g.writeLine(fmt.Sprintf("if %s != nil {", errVar))
	g.indent++
	g.generateOnErrHandler(names, clause.Handler)
	g.indent--
	g.writeLine("}")
}

func (g *Generator) generateIncDecStmt(stmt *ast.IncDecStmt) {
	variable := g.exprToString(stmt.Variable)
	g.writeLine(fmt.Sprintf("%s%s", variable, stmt.Operator))
}

func (g *Generator) generateReturnStmt(stmt *ast.ReturnStmt) {
	if len(stmt.Values) == 0 {
		g.writeLine("return")
		return
	}

	values := make([]string, len(stmt.Values))
	for i, val := range stmt.Values {
		values[i] = g.exprToString(val)
	}

	g.writeLine(fmt.Sprintf("return %s", strings.Join(values, ", ")))
}

func (g *Generator) generateIfStmt(stmt *ast.IfStmt) {
	if stmt.Init != nil {
		g.write("if ")
		// Use a separate generator to avoid adding newline to main output
		tempGen := New(g.program)
		tempGen.indent = 0
		tempGen.generateStatement(stmt.Init)
		initStr := strings.TrimSpace(tempGen.output.String())
		g.write(initStr)
		g.write("; ")
		g.write(g.exprToString(stmt.Condition))
		g.writeLine(" {")
	} else {
		condition := g.exprToString(stmt.Condition)
		g.writeLine(fmt.Sprintf("if %s {", condition))
	}

	g.indent++
	g.generateBlock(stmt.Consequence)
	g.indent--

	if stmt.Alternative != nil {
		switch alt := stmt.Alternative.(type) {
		case *ast.ElseStmt:
			g.writeLine("} else {")
			g.indent++
			g.generateBlock(alt.Body)
			g.indent--
			g.writeLine("}")
		case *ast.IfStmt:
			g.write(g.indentStr() + "} else ")
			g.generateIfStmtContinued(alt)
			return // Don't write closing brace, it's handled recursively
		}
	} else {
		g.writeLine("}")
	}
}

func (g *Generator) generateIfStmtContinued(stmt *ast.IfStmt) {
	condition := g.exprToString(stmt.Condition)
	g.output.WriteString(fmt.Sprintf("if %s {\n", condition))

	g.indent++
	g.generateBlock(stmt.Consequence)
	g.indent--

	if stmt.Alternative != nil {
		switch alt := stmt.Alternative.(type) {
		case *ast.ElseStmt:
			g.writeLine("} else {")
			g.indent++
			g.generateBlock(alt.Body)
			g.indent--
			g.writeLine("}")
		case *ast.IfStmt:
			g.write(g.indentStr() + "} else ")
			g.generateIfStmtContinued(alt)
			return
		}
	} else {
		g.writeLine("}")
	}
}

func (g *Generator) generateForRangeStmt(stmt *ast.ForRangeStmt) {
	collection := g.exprToString(stmt.Collection)

	if stmt.Index != nil {
		g.writeLine(fmt.Sprintf("for %s, %s := range %s {", stmt.Index.Value, stmt.Variable.Value, collection))
	} else {
		g.writeLine(fmt.Sprintf("for _, %s := range %s {", stmt.Variable.Value, collection))
	}

	g.indent++
	g.generateBlock(stmt.Body)
	g.indent--

	g.writeLine("}")
}

func (g *Generator) generateForNumericStmt(stmt *ast.ForNumericStmt) {
	varName := stmt.Variable.Value
	start := g.exprToString(stmt.Start)
	end := g.exprToString(stmt.End)

	var condition string
	if stmt.Through {
		condition = fmt.Sprintf("%s <= %s", varName, end)
	} else {
		condition = fmt.Sprintf("%s < %s", varName, end)
	}

	g.writeLine(fmt.Sprintf("for %s := %s; %s; %s++ {", varName, start, condition, varName))

	g.indent++
	g.generateBlock(stmt.Body)
	g.indent--

	g.writeLine("}")
}

func (g *Generator) generateForConditionStmt(stmt *ast.ForConditionStmt) {
	condition := g.exprToString(stmt.Condition)
	if condition == "true" {
		g.writeLine("for {")
	} else {
		g.writeLine(fmt.Sprintf("for %s {", condition))
	}

	g.indent++
	g.generateBlock(stmt.Body)
	g.indent--

	g.writeLine("}")
}

func (g *Generator) exprToString(expr ast.Expression) string {
	if expr == nil {
		return ""
	}

	switch e := expr.(type) {
	case *ast.Identifier:
		return e.Value
	case *ast.IntegerLiteral:
		return fmt.Sprintf("%d", e.Value)
	case *ast.FloatLiteral:
		return fmt.Sprintf("%f", e.Value)
	case *ast.RuneLiteral:
		return fmt.Sprintf("'%s'", g.escapeRune(e.Value))
	case *ast.StringLiteral:
		return g.generateStringLiteral(e)
	case *ast.BooleanLiteral:
		if e.Value {
			return "true"
		}
		return "false"
	case *ast.BinaryExpr:
		return g.generateBinaryExpr(e)
	case *ast.UnaryExpr:
		return g.generateUnaryExpr(e)
	case *ast.PipeExpr:
		return g.generatePipeExpr(e)
	case *ast.CallExpr:
		return g.generateCallExpr(e)
	case *ast.MethodCallExpr:
		return g.generateMethodCallExpr(e)
	case *ast.IndexExpr:
		left := g.exprToString(e.Left)
		index := g.exprToString(e.Index)
		return fmt.Sprintf("%s[%s]", left, index)
	case *ast.SliceExpr:
		return g.generateSliceExpr(e)
	case *ast.StructLiteralExpr:
		return g.generateStructLiteral(e)
	case *ast.ListLiteralExpr:
		return g.generateListLiteral(e)
	case *ast.MapLiteralExpr:
		return g.generateMapLiteral(e)
	case *ast.ReceiveExpr:
		channel := g.exprToString(e.Channel)
		return fmt.Sprintf("<-%s", channel)
	case *ast.TypeCastExpr:
		targetType := g.generateTypeAnnotation(e.TargetType)
		expr := g.exprToString(e.Expression)
		// Use type assertion syntax for interface types (contains a dot like http.Handler)
		// or when likely asserting from any/interface
		if strings.Contains(targetType, ".") {
			return fmt.Sprintf("%s.(%s)", expr, targetType)
		}
		return fmt.Sprintf("%s(%s)", targetType, expr)
	case *ast.EmptyExpr:
		if e.Type != nil {
			targetType := g.generateTypeAnnotation(e.Type)
			return fmt.Sprintf("%s{}", targetType)
		}
		return "nil"
	case *ast.DiscardExpr:
		return "_"
	case *ast.ErrorExpr:
		message := g.exprToString(e.Message)
		return fmt.Sprintf("errors.New(%s)", message)
	case *ast.ReturnExpr:
		return g.generateReturnExpr(e)
	case *ast.MakeExpr:
		return g.generateMakeExpr(e)
	case *ast.CloseExpr:
		channel := g.exprToString(e.Channel)
		return fmt.Sprintf("close(%s)", channel)
	case *ast.PanicExpr:
		message := g.exprToString(e.Message)
		return fmt.Sprintf("panic(%s)", message)
	case *ast.RecoverExpr:
		return "recover()"
	case *ast.FunctionLiteral:
		return g.generateFunctionLiteral(e)
	case *ast.AddressOfExpr:
		return g.generateAddressOfExpr(e)
	case *ast.DerefExpr:
		return g.generateDerefExpr(e)
	case *ast.TypeAssertionExpr:
		targetType := g.generateTypeAnnotation(e.TargetType)
		expr := g.exprToString(e.Expression)
		return fmt.Sprintf("%s.(%s)", expr, targetType)
	default:
		return ""
	}
}

// escapeRune returns the Go escape sequence for a rune
func (g *Generator) escapeRune(r rune) string {
	switch r {
	case '\n':
		return "\\n"
	case '\t':
		return "\\t"
	case '\r':
		return "\\r"
	case '\\':
		return "\\\\"
	case '\'':
		return "\\'"
	case '\x00':
		return "\\x00"
	default:
		return string(r)
	}
}

// escapeString returns a string with special characters escaped for Go string literals
func (g *Generator) escapeString(s string) string {
	var result strings.Builder
	for _, r := range s {
		switch r {
		case '\n':
			result.WriteString("\\n")
		case '\t':
			result.WriteString("\\t")
		case '\r':
			result.WriteString("\\r")
		case '\\':
			result.WriteString("\\\\")
		case '"':
			result.WriteString("\\\"")
		case '\x00':
			result.WriteString("\\x00")
		default:
			result.WriteRune(r)
		}
	}
	return result.String()
}

func (g *Generator) generateStringLiteral(lit *ast.StringLiteral) string {
	if !lit.Interpolated {
		return fmt.Sprintf("\"%s\"", g.escapeString(lit.Value))
	}

	// Parse string interpolation
	return g.generateStringInterpolation(lit.Value)
}

func (g *Generator) generateStringInterpolation(str string) string {
	// Find all {expr} patterns
	re := regexp.MustCompile(`\{([^}]+)\}`)
	matches := re.FindAllStringSubmatchIndex(str, -1)

	if len(matches) == 0 {
		return fmt.Sprintf("\"%s\"", g.escapeString(str))
	}

	// Build format string and args
	var format strings.Builder
	args := []string{}
	lastIndex := 0

	for _, match := range matches {
		// Add literal part before the interpolation (escaped)
		if match[0] > lastIndex {
			format.WriteString(g.escapeString(str[lastIndex:match[0]]))
		}

		// Add format specifier
		format.WriteString("%v")

		// Extract expression
		expr := str[match[2]:match[3]]
		args = append(args, expr)

		lastIndex = match[1]
	}

	// Add remaining literal part (escaped)
	if lastIndex < len(str) {
		format.WriteString(g.escapeString(str[lastIndex:]))
	}

	// Generate fmt.Sprintf call
	argsStr := strings.Join(args, ", ")
	return fmt.Sprintf("fmt.Sprintf(\"%s\", %s)", format.String(), argsStr)
}

func (g *Generator) generateBinaryExpr(expr *ast.BinaryExpr) string {
	left := g.exprToString(expr.Left)
	right := g.exprToString(expr.Right)

	// Map Kukicha operators to Go operators
	op := expr.Operator
	switch op {
	case "and":
		op = "&&"
	case "or":
		op = "||"
	}

	return fmt.Sprintf("(%s %s %s)", left, op, right)
}

func (g *Generator) generateUnaryExpr(expr *ast.UnaryExpr) string {
	right := g.exprToString(expr.Right)

	op := expr.Operator
	if op == "not" {
		op = "!"
	}

	return fmt.Sprintf("%s%s", op, right)
}

func (g *Generator) generateAddressOfExpr(expr *ast.AddressOfExpr) string {
	operand := g.exprToString(expr.Operand)
	return fmt.Sprintf("&%s", operand)
}

func (g *Generator) generateDerefExpr(expr *ast.DerefExpr) string {
	operand := g.exprToString(expr.Operand)
	return fmt.Sprintf("*%s", operand)
}

func (g *Generator) isContextExpr(expr ast.Expression) bool {
	// Simple type detection for Context
	// 1. Literal 'ctx' identifier
	if id, ok := expr.(*ast.Identifier); ok {
		return id.Value == "ctx"
	}
	// 2. Call to context package (e.g., context.Background(), context.WithTimeout())
	if call, ok := expr.(*ast.CallExpr); ok {
		if id, ok := call.Function.(*ast.Identifier); ok {
			return strings.HasPrefix(id.Value, "context.")
		}
	}
	return false
}

func (g *Generator) generatePipeExpr(expr *ast.PipeExpr) string {
	// Transform a |> b() into b(a)
	// Supports placeholder strategy: a |> b(x, _) becomes b(x, a)
	// Supports context-first strategy: ctx |> b(x) becomes b(ctx, x)

	// Right side can be a CallExpr or MethodCallExpr
	var funcName string
	var arguments []ast.Expression
	var isVariadic bool

	if call, ok := expr.Right.(*ast.CallExpr); ok {
		funcName = g.exprToString(call.Function)
		arguments = call.Arguments
		isVariadic = call.Variadic
	} else if method, ok := expr.Right.(*ast.MethodCallExpr); ok {
		funcName = g.exprToString(method.Object) + "." + method.Method.Value
		if method.Object == nil {
			// Shorthand: .Method() or .Field
			// We will prepend expr.Left as the object
			funcName = g.exprToString(expr.Left) + "." + method.Method.Value

			if !method.IsCall {
				// Field access: obj.Field
				return funcName
			}

			// Method call: obj.Method(args)
			arguments = method.Arguments
			isVariadic = method.Variadic

			args := make([]string, len(arguments))
			for i, arg := range arguments {
				args[i] = g.exprToString(arg)
			}
			if isVariadic {
				return fmt.Sprintf("%s(%s...)", funcName, strings.Join(args, ", "))
			}
			return fmt.Sprintf("%s(%s)", funcName, strings.Join(args, ", "))
		}
		// Normal method call (already has object)
		if !method.IsCall {
			return funcName
		}
		arguments = method.Arguments
		isVariadic = method.Variadic
	} else {
		// Fallback: If piping into something that isn't a call
		return g.exprToString(expr.Left) + " |> " + g.exprToString(expr.Right)
	}

	// Scan arguments for the placeholder "_" (either Identifier or DiscardExpr)
	placeholderIndex := -1
	for i, arg := range arguments {
		if ident, isIdent := arg.(*ast.Identifier); isIdent && ident.Value == "_" {
			placeholderIndex = i
			break
		}
		if _, isDiscard := arg.(*ast.DiscardExpr); isDiscard {
			placeholderIndex = i
			break
		}
	}

	// Build the argument list
	var args []string
	if placeholderIndex != -1 {
		// STRATEGY A: Explicit placeholder found (e.g., json.MarshalWrite(w, _))
		// Replace "_" with the piped expression
		for i, arg := range arguments {
			if i == placeholderIndex {
				args = append(args, g.exprToString(expr.Left))
			} else {
				args = append(args, g.exprToString(arg))
			}
		}
	} else if g.isContextExpr(expr.Left) {
		// STRATEGY C: Context-First Pipe
		// If Left is a Context, it ALWAYS goes to the first argument position
		args = append(args, g.exprToString(expr.Left))
		for _, arg := range arguments {
			args = append(args, g.exprToString(arg))
		}
	} else {
		// STRATEGY B: No placeholder -> Default "Data First" pipe
		// Inject piped expr as the VERY FIRST argument
		args = append(args, g.exprToString(expr.Left))
		for _, arg := range arguments {
			args = append(args, g.exprToString(arg))
		}
	}

	if isVariadic {
		return fmt.Sprintf("%s(%s...)", funcName, strings.Join(args, ", "))
	}
	return fmt.Sprintf("%s(%s)", funcName, strings.Join(args, ", "))
}

func (g *Generator) generateCallExpr(expr *ast.CallExpr) string {
	funcName := g.exprToString(expr.Function)

	// Check if this is a print() builtin - transpile to fmt.Println()
	if id, ok := expr.Function.(*ast.Identifier); ok {
		if id.Value == "print" {
			funcName = "fmt.Println"
		}
	}

	args := make([]string, len(expr.Arguments))
	for i, arg := range expr.Arguments {
		args[i] = g.exprToString(arg)
	}

	if expr.Variadic {
		return fmt.Sprintf("%s(%s...)", funcName, strings.Join(args, ", "))
	}
	return fmt.Sprintf("%s(%s)", funcName, strings.Join(args, ", "))
}

func (g *Generator) generateMethodCallExpr(expr *ast.MethodCallExpr) string {
	object := g.exprToString(expr.Object)
	method := expr.Method.Value

	// If no parentheses were used, it's field access
	if !expr.IsCall {
		return fmt.Sprintf("%s.%s", object, method)
	}

	// Method call with explicit parentheses
	args := make([]string, len(expr.Arguments))
	for i, arg := range expr.Arguments {
		args[i] = g.exprToString(arg)
	}

	if expr.Variadic {
		return fmt.Sprintf("%s.%s(%s...)", object, method, strings.Join(args, ", "))
	}
	return fmt.Sprintf("%s.%s(%s)", object, method, strings.Join(args, ", "))
}

func (g *Generator) generateSliceExpr(expr *ast.SliceExpr) string {
	left := g.exprToString(expr.Left)

	var start, end string
	if expr.Start != nil {
		start = g.exprToString(expr.Start)
	}
	if expr.End != nil {
		end = g.exprToString(expr.End)
	}

	return fmt.Sprintf("%s[%s:%s]", left, start, end)
}

func (g *Generator) generateStructLiteral(expr *ast.StructLiteralExpr) string {
	typeName := g.generateTypeAnnotation(expr.Type)

	if len(expr.Fields) == 0 {
		return fmt.Sprintf("%s{}", typeName)
	}

	fields := make([]string, len(expr.Fields))
	for i, field := range expr.Fields {
		value := g.exprToString(field.Value)
		fields[i] = fmt.Sprintf("%s: %s", field.Name.Value, value)
	}

	return fmt.Sprintf("%s{%s}", typeName, strings.Join(fields, ", "))
}

func (g *Generator) generateListLiteral(expr *ast.ListLiteralExpr) string {
	if len(expr.Elements) == 0 {
		if expr.Type != nil {
			elemType := g.generateTypeAnnotation(expr.Type)
			return fmt.Sprintf("[]%s{}", elemType)
		}
		return "[]interface{}{}"
	}

	elements := make([]string, len(expr.Elements))
	for i, elem := range expr.Elements {
		elements[i] = g.exprToString(elem)
	}

	typePrefix := ""
	if expr.Type != nil {
		elemType := g.generateTypeAnnotation(expr.Type)
		typePrefix = fmt.Sprintf("[]%s", elemType)
	} else {
		typePrefix = "[]interface{}"
	}

	return fmt.Sprintf("%s{%s}", typePrefix, strings.Join(elements, ", "))
}

func (g *Generator) generateMapLiteral(expr *ast.MapLiteralExpr) string {
	keyType := g.generateTypeAnnotation(expr.KeyType)
	valType := g.generateTypeAnnotation(expr.ValType)

	if len(expr.Pairs) == 0 {
		return fmt.Sprintf("map[%s]%s{}", keyType, valType)
	}

	pairs := make([]string, len(expr.Pairs))
	for i, pair := range expr.Pairs {
		key := g.exprToString(pair.Key)
		value := g.exprToString(pair.Value)
		pairs[i] = fmt.Sprintf("%s: %s", key, value)
	}

	return fmt.Sprintf("map[%s]%s{%s}", keyType, valType, strings.Join(pairs, ", "))
}

func (g *Generator) generateMakeExpr(expr *ast.MakeExpr) string {
	targetType := g.generateTypeAnnotation(expr.Type)

	if len(expr.Args) == 0 {
		// Slices require a size argument, maps and channels don't
		if strings.HasPrefix(targetType, "[]") {
			return fmt.Sprintf("make(%s, 0)", targetType)
		}
		return fmt.Sprintf("make(%s)", targetType)
	}

	args := make([]string, len(expr.Args))
	for i, arg := range expr.Args {
		args[i] = g.exprToString(arg)
	}

	return fmt.Sprintf("make(%s, %s)", targetType, strings.Join(args, ", "))
}

// Helper methods

func (g *Generator) write(s string) {
	g.output.WriteString(s)
}

func (g *Generator) writeLine(s string) {
	if s != "" {
		g.output.WriteString(g.indentStr() + s)
	}
	g.output.WriteString("\n")
}

func (g *Generator) indentStr() string {
	return strings.Repeat("\t", g.indent)
}

// uniqueId generates unique identifiers to prevent variable shadowing
func (g *Generator) uniqueId(prefix string) string {
	g.tempCounter++
	return fmt.Sprintf("%s_%d", prefix, g.tempCounter)
}

func (g *Generator) needsStringInterpolation() bool {
	// Check if any string literals have interpolation
	return g.checkProgramForInterpolation(g.program)
}

func (g *Generator) checkProgramForInterpolation(program *ast.Program) bool {
	for _, decl := range program.Declarations {
		if fn, ok := decl.(*ast.FunctionDecl); ok {
			if fn.Body != nil && g.checkBlockForInterpolation(fn.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) checkBlockForInterpolation(block *ast.BlockStmt) bool {
	for _, stmt := range block.Statements {
		if g.checkStmtForInterpolation(stmt) {
			return true
		}
	}
	return false
}

func (g *Generator) checkStmtForInterpolation(stmt ast.Statement) bool {
	switch s := stmt.(type) {
	case *ast.VarDeclStmt:
		for _, val := range s.Values {
			if g.checkExprForInterpolation(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForInterpolation(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.AssignStmt:
		for _, val := range s.Values {
			if g.checkExprForInterpolation(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForInterpolation(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.ReturnStmt:
		for _, val := range s.Values {
			if g.checkExprForInterpolation(val) {
				return true
			}
		}
	case *ast.IfStmt:
		if g.checkExprForInterpolation(s.Condition) {
			return true
		}
		if s.Consequence != nil && g.checkBlockForInterpolation(s.Consequence) {
			return true
		}
		if s.Alternative != nil {
			return g.checkStmtForInterpolation(s.Alternative)
		}
	case *ast.ForRangeStmt:
		if s.Body != nil {
			return g.checkBlockForInterpolation(s.Body)
		}
	case *ast.ForNumericStmt:
		if s.Body != nil {
			return g.checkBlockForInterpolation(s.Body)
		}
	case *ast.ForConditionStmt:
		if s.Body != nil {
			return g.checkBlockForInterpolation(s.Body)
		}
	case *ast.ExpressionStmt:
		if g.checkExprForInterpolation(s.Expression) {
			return true
		}
		if s.OnErr != nil && g.checkExprForInterpolation(s.OnErr.Handler) {
			return true
		}
	}
	return false
}

func (g *Generator) checkExprForInterpolation(expr ast.Expression) bool {
	if expr == nil {
		return false
	}

	switch e := expr.(type) {
	case *ast.StringLiteral:
		return e.Interpolated
	case *ast.BinaryExpr:
		return g.checkExprForInterpolation(e.Left) || g.checkExprForInterpolation(e.Right)
	case *ast.UnaryExpr:
		return g.checkExprForInterpolation(e.Right)
	case *ast.CallExpr:
		for _, arg := range e.Arguments {
			if g.checkExprForInterpolation(arg) {
				return true
			}
		}
	case *ast.MethodCallExpr:
		for _, arg := range e.Arguments {
			if g.checkExprForInterpolation(arg) {
				return true
			}
		}
	}

	return false
}

func (g *Generator) needsPrintBuiltin() bool {
	// Check if any calls use the print() builtin
	return g.checkProgramForPrint(g.program)
}

func (g *Generator) checkProgramForPrint(program *ast.Program) bool {
	for _, decl := range program.Declarations {
		if fn, ok := decl.(*ast.FunctionDecl); ok {
			if fn.Body != nil && g.checkBlockForPrint(fn.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) checkBlockForPrint(block *ast.BlockStmt) bool {
	for _, stmt := range block.Statements {
		if g.checkStmtForPrint(stmt) {
			return true
		}
	}
	return false
}

func (g *Generator) checkStmtForPrint(stmt ast.Statement) bool {
	switch s := stmt.(type) {
	case *ast.VarDeclStmt:
		for _, val := range s.Values {
			if g.checkExprForPrint(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForPrint(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.AssignStmt:
		for _, val := range s.Values {
			if g.checkExprForPrint(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForPrint(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.ReturnStmt:
		for _, val := range s.Values {
			if g.checkExprForPrint(val) {
				return true
			}
		}
	case *ast.IfStmt:
		if g.checkExprForPrint(s.Condition) {
			return true
		}
		if s.Consequence != nil && g.checkBlockForPrint(s.Consequence) {
			return true
		}
		if s.Alternative != nil {
			return g.checkStmtForPrint(s.Alternative)
		}
	case *ast.ForRangeStmt:
		if s.Body != nil {
			return g.checkBlockForPrint(s.Body)
		}
	case *ast.ForNumericStmt:
		if s.Body != nil {
			return g.checkBlockForPrint(s.Body)
		}
	case *ast.ForConditionStmt:
		if s.Body != nil {
			return g.checkBlockForPrint(s.Body)
		}
	case *ast.ExpressionStmt:
		if g.checkExprForPrint(s.Expression) {
			return true
		}
		if s.OnErr != nil && g.checkExprForPrint(s.OnErr.Handler) {
			return true
		}
	case *ast.DeferStmt:
		if s.Call != nil {
			return g.checkExprForPrint(s.Call)
		}
	case *ast.GoStmt:
		if s.Call != nil {
			return g.checkExprForPrint(s.Call)
		}
	}
	return false
}

func (g *Generator) checkExprForPrint(expr ast.Expression) bool {
	if expr == nil {
		return false
	}

	switch e := expr.(type) {
	case *ast.CallExpr:
		// Check if this is a print() call
		if id, ok := e.Function.(*ast.Identifier); ok {
			if id.Value == "print" {
				return true
			}
		}
		// Also check arguments recursively
		for _, arg := range e.Arguments {
			if g.checkExprForPrint(arg) {
				return true
			}
		}
	case *ast.BinaryExpr:
		return g.checkExprForPrint(e.Left) || g.checkExprForPrint(e.Right)
	case *ast.UnaryExpr:
		return g.checkExprForPrint(e.Right)
	case *ast.MethodCallExpr:
		for _, arg := range e.Arguments {
			if g.checkExprForPrint(arg) {
				return true
			}
		}
	case *ast.PipeExpr:
		return g.checkExprForPrint(e.Left) || g.checkExprForPrint(e.Right)
	case *ast.FunctionLiteral:
		if e.Body != nil {
			return g.checkBlockForPrint(e.Body)
		}
	}

	return false
}

func (g *Generator) needsErrorsPackage() bool {
	// Check if any error expressions are used
	return g.checkProgramForErrors(g.program)
}

func (g *Generator) checkProgramForErrors(program *ast.Program) bool {
	for _, decl := range program.Declarations {
		if fn, ok := decl.(*ast.FunctionDecl); ok {
			if fn.Body != nil && g.checkBlockForErrors(fn.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) checkBlockForErrors(block *ast.BlockStmt) bool {
	for _, stmt := range block.Statements {
		if g.checkStmtForErrors(stmt) {
			return true
		}
	}
	return false
}

func (g *Generator) checkStmtForErrors(stmt ast.Statement) bool {
	switch s := stmt.(type) {
	case *ast.VarDeclStmt:
		for _, val := range s.Values {
			if g.checkExprForErrors(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForErrors(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.AssignStmt:
		for _, val := range s.Values {
			if g.checkExprForErrors(val) {
				return true
			}
		}
		if s.OnErr != nil && g.checkExprForErrors(s.OnErr.Handler) {
			return true
		}
		return false
	case *ast.ReturnStmt:
		for _, val := range s.Values {
			if g.checkExprForErrors(val) {
				return true
			}
		}
	case *ast.IfStmt:
		if g.checkExprForErrors(s.Condition) {
			return true
		}
		if s.Consequence != nil && g.checkBlockForErrors(s.Consequence) {
			return true
		}
		if s.Alternative != nil {
			return g.checkStmtForErrors(s.Alternative)
		}
	case *ast.ForRangeStmt:
		if s.Body != nil {
			return g.checkBlockForErrors(s.Body)
		}
	case *ast.ForNumericStmt:
		if s.Body != nil {
			return g.checkBlockForErrors(s.Body)
		}
	case *ast.ForConditionStmt:
		if s.Body != nil {
			return g.checkBlockForErrors(s.Body)
		}
	case *ast.ExpressionStmt:
		if g.checkExprForErrors(s.Expression) {
			return true
		}
		if s.OnErr != nil && g.checkExprForErrors(s.OnErr.Handler) {
			return true
		}
	}
	return false
}

func (g *Generator) checkExprForErrors(expr ast.Expression) bool {
	if expr == nil {
		return false
	}

	switch e := expr.(type) {
	case *ast.ErrorExpr:
		return true
	case *ast.BinaryExpr:
		return g.checkExprForErrors(e.Left) || g.checkExprForErrors(e.Right)
	case *ast.UnaryExpr:
		return g.checkExprForErrors(e.Right)
	case *ast.CallExpr:
		for _, arg := range e.Arguments {
			if g.checkExprForErrors(arg) {
				return true
			}
		}
	case *ast.MethodCallExpr:
		for _, arg := range e.Arguments {
			if g.checkExprForErrors(arg) {
				return true
			}
		}
	case *ast.PipeExpr:
		return g.checkExprForErrors(e.Left) || g.checkExprForErrors(e.Right)
	case *ast.FunctionLiteral:
		if e.Body != nil {
			return g.checkBlockForErrors(e.Body)
		}
	}

	return false
}
func (g *Generator) generateReturnExpr(expr *ast.ReturnExpr) string {
	values := make([]string, len(expr.Values))
	for i, v := range expr.Values {
		values[i] = g.exprToString(v)
	}
	return "return " + strings.Join(values, ", ")
}
