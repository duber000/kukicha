# Tests for Kukicha Standard Library - Fetch Package

petiole fetch_test

import "testing"
import "stdlib/fetch"
import "net/http"
import "net/http/httptest"
import "encoding/json"
import "fmt"

type TestData
    Message string json:"message"
    Count int json:"count"

type PostData
    Name string json:"name"
    Value int json:"value"

# TestGet verifies that fetch.Get can make a basic HTTP GET request
func TestGet(t reference testing.T)
    # Create a test server
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.WriteHeader(http.StatusOK)
        w.Write("Hello, World!" as list of byte)
    ))
    defer server.Close()

    # Test fetch.Get
    resp, err := fetch.Get(server.URL)
    if err != empty
        t.Fatalf("fetch.Get failed: {err}")

    if resp.StatusCode != http.StatusOK
        t.Errorf("Expected status 200, got {resp.StatusCode}")

    resp.Body.Close()

# TestJson verifies that fetch.Json can parse typed JSON responses
func TestJson(t reference testing.T)
    testData := TestData{Message: "test", Count: 42}
    jsonBytes, _ := json.Marshal(testData)

    # Create a test server
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(jsonBytes)
    ))
    defer server.Close()

    # Test fetch.Get |> fetch.Json pipeline
    resp, err := fetch.Get(server.URL)
    if err != empty
        t.Fatalf("fetch.Get failed: {err}")

    data, jsonErr := fetch.Json(resp, empty TestData)
    if jsonErr != empty
        t.Fatalf("fetch.Json failed: {jsonErr}")

    if data.Message != "test" or data.Count != 42
        t.Errorf("Unexpected parsed data: {data}")

# TestJsonArray verifies that fetch.Json supports top-level JSON arrays
func TestJsonArray(t reference testing.T)
    jsonBytes := "[{\"message\":\"a\",\"count\":1},{\"message\":\"b\",\"count\":2}]" as list of byte

    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(jsonBytes)
    ))
    defer server.Close()

    resp, err := fetch.Get(server.URL)
    if err != empty
        t.Fatalf("fetch.Get failed: {err}")

    data, jsonErr := fetch.Json(resp, empty list of TestData)
    if jsonErr != empty
        t.Fatalf("fetch.Json failed for array payload: {jsonErr}")
    if len(data) != 2 or data[0].Message != "a" or data[1].Count != 2
        t.Errorf("Unexpected parsed array data: {data}")

# TestDecode verifies that fetch.Decode can unmarshal directly into typed targets
func TestDecode(t reference testing.T)
    testData := list of TestData{
        TestData{Message: "typed", Count: 7},
        TestData{Message: "decode", Count: 9},
    }
    jsonBytes, marshalErr := json.Marshal(testData)
    if marshalErr != empty
        t.Fatalf("json.Marshal failed: {marshalErr}")

    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(jsonBytes)
    ))
    defer server.Close()

    resp, err := fetch.Get(server.URL)
    if err != empty
        t.Fatalf("fetch.Get failed: {err}")

    decoded := empty list of TestData
    decodeErr := fetch.Decode(resp, reference of decoded)
    if decodeErr != empty
        t.Fatalf("fetch.Decode failed: {decodeErr}")

    if len(decoded) != 2
        t.Fatalf("Expected 2 decoded items, got {len(decoded)}")
    if decoded[0].Message != "typed" or decoded[1].Count != 9
        t.Errorf("Decoded data mismatch: {decoded}")

# TestURLTemplate verifies safe path placeholder expansion
func TestURLTemplate(t reference testing.T)
    tmpl := fmt.Sprintf("https://api.example.com/users/%cusername%c/repos/%crepo%c", 123, 125, 123, 125)
    builtURL, err := fetch.URLTemplate(tmpl, map of string to string{"username": "acme/dev team", "repo": "hello world"})
    if err != empty
        t.Fatalf("URLTemplate failed: {err}")

    expected := "https://api.example.com/users/acme%2Fdev%20team/repos/hello%20world"
    if builtURL != expected
        t.Errorf("Expected URL '{expected}', got '{builtURL}'")

# TestURLTemplateMissingPlaceholder verifies unresolved placeholders error
func TestURLTemplateMissingPlaceholder(t reference testing.T)
    tmpl := fmt.Sprintf("https://api.example.com/users/%cusername%c/repos/%crepo%c", 123, 125, 123, 125)
    _, err := fetch.URLTemplate(tmpl, map of string to string{"username": "golang"})
    if err == empty
        t.Fatal("Expected error for unresolved URL template placeholder")

# TestURLWithQuery verifies safe query encoding
func TestURLWithQuery(t reference testing.T)
    builtURL, err := fetch.URLWithQuery("https://api.example.com/search", map of string to string{"q": "go lang", "sort": "stars desc"})
    if err != empty
        t.Fatalf("URLWithQuery failed: {err}")

    if builtURL != "https://api.example.com/search?q=go+lang&sort=stars+desc" and builtURL != "https://api.example.com/search?sort=stars+desc&q=go+lang"
        t.Errorf("Unexpected query URL: {builtURL}")

# TestText verifies that fetch.Text can read response body as string
func TestText(t reference testing.T)
    expectedText := "Hello, Kukicha!"

    # Create a test server
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.WriteHeader(http.StatusOK)
        w.Write(expectedText as list of byte)
    ))
    defer server.Close()

    # Test fetch.Get |> fetch.Text pipeline
    resp, err := fetch.Get(server.URL)
    if err != empty
        t.Fatalf("fetch.Get failed: {err}")

    text, textErr := fetch.Text(resp)
    if textErr != empty
        t.Fatalf("fetch.Text failed: {textErr}")

    if text != expectedText
        t.Errorf("Expected text '{expectedText}', got '{text}'")

# TestPost verifies that fetch.Post can send JSON data
func TestPost(t reference testing.T)
    # Create a test server that echoes the received data
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        if r.Method != "POST"
            t.Errorf("Expected POST request, got {r.Method}")
        w.WriteHeader(http.StatusCreated)
        w.Write("created" as list of byte)
    ))
    defer server.Close()

    # Test fetch.Post
    postData := PostData{Name: "test", Value: 123}
    resp, err := fetch.Post(postData, server.URL)
    if err != empty
        t.Fatalf("fetch.Post failed: {err}")

    if resp.StatusCode != http.StatusCreated
        t.Errorf("Expected status 201, got {resp.StatusCode}")

    resp.Body.Close()

# TestCheckStatus verifies status code checking
func TestCheckStatus(t reference testing.T)
    # Test success case (200)
    server200 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.WriteHeader(http.StatusOK)
        w.Write("success" as list of byte)
    ))
    defer server200.Close()

    resp, err := fetch.Get(server200.URL)
    if err != empty
        t.Fatalf("fetch.Get failed: {err}")

    checkedResp, checkErr := fetch.CheckStatus(resp)
    if checkErr != empty
        t.Errorf("CheckStatus failed for 200: {checkErr}")
    if checkedResp == empty
        t.Error("Expected non-nil response")
    checkedResp.Body.Close()

    # Test failure case (404)
    server404 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.WriteHeader(http.StatusNotFound)
        w.Write("not found" as list of byte)
    ))
    defer server404.Close()

    resp404, err404 := fetch.Get(server404.URL)
    if err404 != empty
        t.Fatalf("fetch.Get failed: {err404}")

    _, checkErr404 := fetch.CheckStatus(resp404)
    if checkErr404 == empty
        t.Error("Expected error for 404 status")

# TestRequestBuilder verifies the request builder pattern
func TestRequestBuilder(t reference testing.T)
    # Create a test server
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        # Check custom header
        auth := r.Header.Get("Authorization")
        if auth != "Bearer test-token"
            t.Errorf("Expected Authorization header, got '{auth}'")
        w.WriteHeader(http.StatusOK)
        w.Write("authorized" as list of byte)
    ))
    defer server.Close()

    # Test request builder
    req := fetch.New(server.URL) |> fetch.Header("Authorization", "Bearer test-token")

    resp, err := fetch.Do(req)
    if err != empty
        t.Fatalf("fetch.Do failed: {err}")

    if resp.StatusCode != http.StatusOK
        t.Errorf("Expected status 200, got {resp.StatusCode}")

    resp.Body.Close()

# TestAuthHelpers verifies Bearer and Basic auth helpers
func TestAuthHelpers(t reference testing.T)
    # Test Bearer Auth
    serverBearer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        auth := r.Header.Get("Authorization")
        if auth != "Bearer my-token"
            t.Errorf("Expected Bearer token, got '{auth}'")
        w.WriteHeader(http.StatusOK)
    ))
    defer serverBearer.Close()

    reqBearer := fetch.New(serverBearer.URL) |> fetch.BearerAuth("my-token")
    respBearer, errBearer := fetch.Do(reqBearer)
    if errBearer != empty
        t.Fatalf("BearerAuth request failed: {errBearer}")
    respBearer.Body.Close()

    # Test Basic Auth
    serverBasic := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        auth := r.Header.Get("Authorization")
        # "user:pass" base64 encoded is "dXNlcjpwYXNz"
        expected := "Basic dXNlcjpwYXNz"
        if auth != expected
            t.Errorf("Expected Basic auth '{expected}', got '{auth}'")
        w.WriteHeader(http.StatusOK)
    ))
    defer serverBasic.Close()

    reqBasic := fetch.New(serverBasic.URL) |> fetch.BasicAuth("user", "pass")
    respBasic, errBasic := fetch.Do(reqBasic)
    if errBasic != empty
        t.Fatalf("BasicAuth request failed: {errBasic}")
    respBasic.Body.Close()

# TestFormData verifies form data submission
func TestFormData(t reference testing.T)
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        contentType := r.Header.Get("Content-Type")
        if contentType != "application/x-www-form-urlencoded"
            t.Errorf("Expected form content type, got '{contentType}'")

        r.ParseForm()
        val := r.Form.Get("key")
        if val != "value"
            t.Errorf("Expected form value 'value', got '{val}'")

        w.WriteHeader(http.StatusOK)
    ))
    defer server.Close()

    data := map of string to string{"key": "value"}
    req := fetch.New(server.URL) |> fetch.FormData(data) |> fetch.Method("POST")
    resp, err := fetch.Do(req)
    if err != empty
        t.Fatalf("FormData request failed: {err}")
    resp.Body.Close()

# TestSession verifies session cookie persistence
func TestSession(t reference testing.T)
    # Server that sets a cookie on first request and checks it on second
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        cookie, err := r.Cookie("session_id")
        if err == empty
            # Cookie present
            if cookie.Value != "12345"
                t.Errorf("Expected cookie value 12345, got {cookie.Value}")
            w.WriteHeader(http.StatusOK)
            w.Write("logged in" as list of byte)
        else
            # No cookie, set it
            http.SetCookie(w, reference of http.Cookie{Name: "session_id", Value: "12345"})
            w.WriteHeader(http.StatusOK)
            w.Write("cookie set" as list of byte)
    ))
    defer server.Close()

    session := fetch.NewSession()

    # First request: gets cookie
    resp1, err1 := fetch.SessionGet(session, server.URL)
    if err1 != empty
        t.Fatalf("First session request failed: {err1}")
    resp1.Body.Close()

    # Second request: sends cookie
    resp2, err2 := fetch.SessionGet(session, server.URL)
    if err2 != empty
        t.Fatalf("Second session request failed: {err2}")

    text, errText := fetch.Text(resp2)
    if errText != empty
        t.Fatalf("Text read failed: {errText}")
    if text != "logged in"
        t.Errorf("Expected 'logged in', got '{text}'")
