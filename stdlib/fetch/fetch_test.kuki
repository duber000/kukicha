# Tests for Kukicha Standard Library - Fetch Package

petiole fetch_test

import "testing"
import "stdlib/test"
import "stdlib/fetch"
import "net/http"
import "net/http/httptest"
import "encoding/json"
import "fmt"

type TestData
    Message string as "message"
    Count   int    as "count"

type PostData
    Name  string as "name"
    Value int    as "value"

# --- TestGet ---
type GetCase
    name string

func TestGet(t reference testing.T)
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.WriteHeader(http.StatusOK)
        w.Write("Hello, World!" as list of byte)
    ))
    defer server.Close()

    cases := list of GetCase{
        GetCase{name: "basic get"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            resp, err := fetch.Get(server.URL)
            test.AssertNoError(t, err)
            test.AssertEqual(t, resp.StatusCode, http.StatusOK)
            resp.Body.Close()
        )

# --- TestJson ---
type JsonCase
    name string

func TestJson(t reference testing.T)
    testData := TestData{Message: "test", Count: 42}
    jsonBytes, _ := json.Marshal(testData)

    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(jsonBytes)
    ))
    defer server.Close()

    cases := list of JsonCase{
        JsonCase{name: "parse object"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            resp, err := fetch.Get(server.URL)
            test.AssertNoError(t, err)
            data, jsonErr := fetch.Json(resp, empty TestData)
            test.AssertNoError(t, jsonErr)
            test.AssertEqual(t, data.Message, "test")
            test.AssertEqual(t, data.Count, 42)
        )

# --- TestJsonArray ---
type JsonArrayCase
    name string

func TestJsonArray(t reference testing.T)
    jsonBytes := "[{\"message\":\"a\",\"count\":1},{\"message\":\"b\",\"count\":2}]" as list of byte
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(jsonBytes)
    ))
    defer server.Close()

    cases := list of JsonArrayCase{
        JsonArrayCase{name: "parse array"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            resp, err := fetch.Get(server.URL)
            test.AssertNoError(t, err)
            data, jsonErr := fetch.Json(resp, empty list of TestData)
            test.AssertNoError(t, jsonErr)
            test.AssertEqual(t, len(data), 2)
            test.AssertEqual(t, data[0].Message, "a")
            test.AssertEqual(t, data[1].Count, 2)
        )

# --- TestDecode ---
type DecodeCase
    name string

func TestDecode(t reference testing.T)
    testData := list of TestData{
        TestData{Message: "typed", Count: 7},
        TestData{Message: "decode", Count: 9},
    }
    jsonBytes, _ := json.Marshal(testData)
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(jsonBytes)
    ))
    defer server.Close()

    cases := list of DecodeCase{
        DecodeCase{name: "decode into reference"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            resp, err := fetch.Get(server.URL)
            test.AssertNoError(t, err)
            decoded := empty list of TestData
            decodeErr := fetch.Decode(resp, reference of decoded)
            test.AssertNoError(t, decodeErr)
            test.AssertEqual(t, len(decoded), 2)
            test.AssertEqual(t, decoded[0].Message, "typed")
            test.AssertEqual(t, decoded[1].Count, 9)
        )

# --- TestURLTemplate ---
type URLTemplateCase
    name    string
    tmpl    string
    args    map of string to string
    want    string
    wantErr bool

func TestURLTemplate(t reference testing.T)
    tmpl := fmt.Sprintf("https://api.example.com/users/%cusername%c/repos/%crepo%c", 123, 125, 123, 125)
    
    cases := list of URLTemplateCase{
        URLTemplateCase{
            name: "success with encoding",
            tmpl: tmpl,
            args: map of string to string{"username": "acme/dev team", "repo": "hello world"},
            want: "https://api.example.com/users/acme%2Fdev%20team/repos/hello%20world",
            wantErr: false,
        },
        URLTemplateCase{
            name: "missing placeholder",
            tmpl: tmpl,
            args: map of string to string{"username": "golang"},
            want: "",
            wantErr: true,
        },
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            builtURL, err := fetch.URLTemplate(tc.tmpl, tc.args)
            if tc.wantErr
                test.AssertError(t, err)
            else
                test.AssertNoError(t, err)
                test.AssertEqual(t, builtURL, tc.want)
        )

# --- TestURLWithQuery ---
type URLWithQueryCase
    name    string
    url     string
    query   map of string to string
    want1   string
    want2   string

func TestURLWithQuery(t reference testing.T)
    cases := list of URLWithQueryCase{
        URLWithQueryCase{
            name: "encode multiple params",
            url: "https://api.example.com/search",
            query: map of string to string{"q": "go lang", "sort": "stars desc"},
            want1: "https://api.example.com/search?q=go+lang&sort=stars+desc",
            want2: "https://api.example.com/search?sort=stars+desc&q=go+lang",
        },
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            builtURL, err := fetch.URLWithQuery(tc.url, tc.query)
            test.AssertNoError(t, err)
            if builtURL != tc.want1 and builtURL != tc.want2
                t.Errorf("Unexpected query URL: {builtURL}")
        )

# --- TestText ---
type TextCase
    name string

func TestText(t reference testing.T)
    expectedText := "Hello, Kukicha!"
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        w.WriteHeader(http.StatusOK)
        w.Write(expectedText as list of byte)
    ))
    defer server.Close()

    cases := list of TextCase{
        TextCase{name: "read as text"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            resp, err := fetch.Get(server.URL)
            test.AssertNoError(t, err)
            text, textErr := fetch.Text(resp)
            test.AssertNoError(t, textErr)
            test.AssertEqual(t, text, expectedText)
        )

# --- TestPost ---
type PostCase
    name string

func TestPost(t reference testing.T)
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        test.AssertEqual(t, r.Method, "POST")
        w.WriteHeader(http.StatusCreated)
        w.Write("created" as list of byte)
    ))
    defer server.Close()

    cases := list of PostCase{
        PostCase{name: "post object"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            postData := PostData{Name: "test", Value: 123}
            resp, err := fetch.Post(postData, server.URL)
            test.AssertNoError(t, err)
            test.AssertEqual(t, resp.StatusCode, http.StatusCreated)
            resp.Body.Close()
        )

# --- TestCheckStatus ---
type CheckStatusCase
    name string
    code int
    wantErr bool

func TestCheckStatus(t reference testing.T)
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        if r.URL.Path == "/ok"
            w.WriteHeader(http.StatusOK)
        else
            w.WriteHeader(http.StatusNotFound)
    ))
    defer server.Close()

    cases := list of CheckStatusCase{
        CheckStatusCase{name: "success status", code: 200, wantErr: false},
        CheckStatusCase{name: "error status", code: 404, wantErr: true},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            path := "/ok"
            if tc.wantErr
                path = "/notfound"
            resp, err := fetch.Get(server.URL + path)
            test.AssertNoError(t, err)
            
            checkedResp, checkErr := fetch.CheckStatus(resp)
            if tc.wantErr
                test.AssertError(t, checkErr)
            else
                test.AssertNoError(t, checkErr)
                if checkedResp == empty
                    t.Error("Expected non-nil response")
                checkedResp.Body.Close()
        )

# --- TestRequestBuilder ---
type RequestBuilderCase
    name string

func TestRequestBuilder(t reference testing.T)
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        test.AssertEqual(t, r.Header.Get("Authorization"), "Bearer test-token")
        w.WriteHeader(http.StatusOK)
        w.Write("authorized" as list of byte)
    ))
    defer server.Close()

    cases := list of RequestBuilderCase{
        RequestBuilderCase{name: "builder properties"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            req := fetch.New(server.URL) |> fetch.Header("Authorization", "Bearer test-token")
            resp, err := fetch.Do(req)
            test.AssertNoError(t, err)
            test.AssertEqual(t, resp.StatusCode, http.StatusOK)
            resp.Body.Close()
        )

# --- TestAuthHelpers ---
type AuthHelpersCase
    name string

func TestAuthHelpers(t reference testing.T)
    cases := list of AuthHelpersCase{
        AuthHelpersCase{name: "auth headers"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            serverBearer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
                test.AssertEqual(t, r.Header.Get("Authorization"), "Bearer my-token")
                w.WriteHeader(http.StatusOK)
            ))
            defer serverBearer.Close()

            reqBearer := fetch.New(serverBearer.URL) |> fetch.BearerAuth("my-token")
            respBearer, errBearer := fetch.Do(reqBearer)
            test.AssertNoError(t, errBearer)
            respBearer.Body.Close()

            serverBasic := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
                test.AssertEqual(t, r.Header.Get("Authorization"), "Basic dXNlcjpwYXNz")
                w.WriteHeader(http.StatusOK)
            ))
            defer serverBasic.Close()

            reqBasic := fetch.New(serverBasic.URL) |> fetch.BasicAuth("user", "pass")
            respBasic, errBasic := fetch.Do(reqBasic)
            test.AssertNoError(t, errBasic)
            respBasic.Body.Close()
        )

# --- TestFormData ---
type FormDataCase
    name string

func TestFormData(t reference testing.T)
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        test.AssertEqual(t, r.Header.Get("Content-Type"), "application/x-www-form-urlencoded")
        r.ParseForm()
        test.AssertEqual(t, r.Form.Get("key"), "value")
        w.WriteHeader(http.StatusOK)
    ))
    defer server.Close()

    cases := list of FormDataCase{
        FormDataCase{name: "post form data"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            data := map of string to string{"key": "value"}
            req := fetch.New(server.URL) |> fetch.FormData(data) |> fetch.Method("POST")
            resp, err := fetch.Do(req)
            test.AssertNoError(t, err)
            resp.Body.Close()
        )

# --- TestSession ---
type SessionCase
    name string

func TestSession(t reference testing.T)
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r reference http.Request)
        cookie, err := r.Cookie("session_id")
        if err == empty
            test.AssertEqual(t, cookie.Value, "12345")
            w.WriteHeader(http.StatusOK)
            w.Write("logged in" as list of byte)
        else
            http.SetCookie(w, reference of http.Cookie{Name: "session_id", Value: "12345"})
            w.WriteHeader(http.StatusOK)
            w.Write("cookie set" as list of byte)
    ))
    defer server.Close()

    cases := list of SessionCase{
        SessionCase{name: "persist cookies"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            session := fetch.NewSession()
            resp1, err1 := fetch.SessionGet(session, server.URL)
            test.AssertNoError(t, err1)
            resp1.Body.Close()

            resp2, err2 := fetch.SessionGet(session, server.URL)
            test.AssertNoError(t, err2)
            text, errText := fetch.Text(resp2)
            test.AssertNoError(t, errText)
            test.AssertEqual(t, text, "logged in")
        )
