// Generated by Kukicha v0.0.1 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package fetch

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"github.com/duber000/kukicha/stdlib/json"
	"io"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"time"
)

type Request struct {
	url       string
	headers   map[string]string
	timeoutNs int64
	method    string
	body      any
}

func New(url string) Request {
	req := Request{}
	req.url = url
	req.headers = make(map[string]string)
	req.timeoutNs = 30000000000
	req.method = "GET"
	req.body = nil
	return req
}

func Header(req Request, name string, value string) Request {
	req.headers[name] = value
	return req
}

func Timeout(req Request, durationNs int64) Request {
	req.timeoutNs = durationNs
	return req
}

func Method(req Request, method string) Request {
	req.method = method
	return req
}

func Body(req Request, data any) Request {
	req.body = data
	return req
}

func Do(req Request) (*http.Response, error) {
	client := http.Client{}
	client.Timeout = time.Duration(req.timeoutNs)
	var bodyData interface{}
	if req.body != nil {
		bodyStr, isString := req.body.(string)
		if isString {
			bodyData = []byte(bodyStr)
		} else {
			jsonBytes, marshalErr := json.Marshal(req.body)
			if marshalErr != nil {
				return nil, marshalErr
			}
			bodyData = jsonBytes
		}
	}
	httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
	if reqErr != nil {
		return nil, reqErr
	}
	for name, value := range req.headers {
		httpReq.Header.Set(name, value)
	}
	if req.body != nil {
		contentType := httpReq.Header.Get("Content-Type")
		if contentType == "" {
			httpReq.Header.Set("Content-Type", "application/json")
		}
	}
	resp, doErr := client.Do(httpReq)
	return resp, doErr
}

func createHTTPRequest(method string, url string, bodyData any) (*http.Request, error) {
	if bodyData != nil {
		bodyBytes := bodyData.([]byte)
		req, err := http.NewRequest(method, url, bytes.NewReader(bodyBytes))
		return req, err
	}
	req, err := http.NewRequest(method, url, nil)
	return req, err
}

func Get(url string) (*http.Response, error) {
	req := New(url)
	resp, err := Do(req)
	return resp, err
}

func Post(data any, url string) (*http.Response, error) {
	req := New(url)
	req = Method(req, "POST")
	req.body = data
	resp, err := Do(req)
	return resp, err
}

func CheckStatus(resp *http.Response) (*http.Response, error) {
	if resp.StatusCode >= 400 {
		return nil, errors.New(fmt.Sprintf("request failed: %v", resp.Status))
	}
	return resp, nil
}

func Text(resp *http.Response) (string, error) {
	defer resp.Body.Close()
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	text := string(bodyBytes)
	return text, nil
}

func Bytes(resp *http.Response) ([]byte, error) {
	defer resp.Body.Close()
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return bodyBytes, nil
}

func Json(resp *http.Response) (any, error) {
	defer resp.Body.Close()
	data := make(map[string]any)
	err := json.UnmarshalRead(resp.Body, &data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func BearerAuth(req Request, token string) Request {
	return Header(req, "Authorization", fmt.Sprintf("Bearer %v", token))
}

func BasicAuth(req Request, username string, password string) Request {
	credentials := fmt.Sprintf("%v:%v", username, password)
	encoded := base64.StdEncoding.EncodeToString([]byte(credentials))
	return Header(req, "Authorization", fmt.Sprintf("Basic %v", encoded))
}

func FormData(req Request, data map[string]string) Request {
	values := url.Values{}
	for key, value := range data {
		values.Set(key, value)
	}
	req.body = values.Encode()
	req = Header(req, "Content-Type", "application/x-www-form-urlencoded")
	return req
}

type Session struct {
	client    http.Client
	headers   map[string]string
	timeoutNs int64
}

func NewSession() Session {
	jar, _ := cookiejar.New(nil)
	client := http.Client{Jar: jar}
	s := Session{}
	s.client = client
	s.headers = make(map[string]string)
	s.timeoutNs = 30000000000
	return s
}

func SessionHeader(s Session, name string, value string) Session {
	s.headers[name] = value
	return s
}

func SessionTimeout(s Session, durationNs int64) Session {
	s.timeoutNs = durationNs
	return s
}

func SessionDo(s Session, req Request) (*http.Response, error) {
	for name, value := range s.headers {
		_, exists := req.headers[name]
		if !exists {
			req.headers[name] = value
		}
	}
	if req.timeoutNs == 30000000000 {
		req.timeoutNs = s.timeoutNs
	}
	s.client.Timeout = time.Duration(req.timeoutNs)
	var bodyData interface{}
	if req.body != nil {
		bodyStr, isString := req.body.(string)
		if isString {
			bodyData = []byte(bodyStr)
		} else {
			jsonBytes, marshalErr := json.Marshal(req.body)
			if marshalErr != nil {
				return nil, marshalErr
			}
			bodyData = jsonBytes
		}
	}
	httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
	if reqErr != nil {
		return nil, reqErr
	}
	for name, value := range req.headers {
		httpReq.Header.Set(name, value)
	}
	if req.body != nil {
		contentType := httpReq.Header.Get("Content-Type")
		if contentType == "" {
			httpReq.Header.Set("Content-Type", "application/json")
		}
	}
	resp, doErr := s.client.Do(httpReq)
	return resp, doErr
}

func SessionGet(s Session, url string) (*http.Response, error) {
	req := New(url)
	return SessionDo(s, req)
}

func SessionPost(s Session, data any, url string) (*http.Response, error) {
	req := New(url)
	req = Method(req, "POST")
	req.body = data
	return SessionDo(s, req)
}
