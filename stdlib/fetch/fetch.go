// Generated by Kukicha v1.0.0 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package fetch

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/duber000/kukicha/stdlib/json"
	"io"
	"net/http"
	"time"
)

type Request struct {
	url       string
	headers   map[string]string
	timeoutNs int64
	method    string
	body      any
}

func New(url string) Request {
	req := Request{}
	req.url = url
	req.headers = make(map[string]string)
	req.timeoutNs = 30000000000
	req.method = "GET"
	req.body = nil
	return req
}

func Header(req Request, name string, value string) Request {
	req.headers[name] = value
	return req
}

func Timeout(req Request, durationNs int64) Request {
	req.timeoutNs = durationNs
	return req
}

func Method(req Request, method string) Request {
	req.method = method
	return req
}

func Body(req Request, data any) Request {
	req.body = data
	return req
}

func Do(req Request) (any, error) {
	client := http.Client{}
	client.Timeout = time.Duration(req.timeoutNs)
	bodyReader := nil.(io.Reader)
	if req.body != nil {
		jsonBytes, marshalErr := json.Marshal(req.body)
		if marshalErr != nil {
			return nil, marshalErr
		}
		bodyReader = bytes.NewReader(jsonBytes)
	}
	httpReq, reqErr := http.NewRequest(req.method, req.url, bodyReader)
	if reqErr != nil {
		return nil, reqErr
	}
	for name, value := range req.headers {
		httpReq.Header.Set(name, value)
	}
	if req.body != nil {
		contentType := httpReq.Header.Get("Content-Type")
		if contentType == "" {
			httpReq.Header.Set("Content-Type", "application/json")
		}
	}
	resp, doErr := client.Do(httpReq)
	return resp, doErr
}

func Get(url string) (any, error) {
	req := New(url)
	resp, err := Do(req)
	return resp, err
}

func Post(data any, url string) (any, error) {
	req := New(url)
	req = Method(req, "POST")
	req.body = data
	resp, err := Do(req)
	return resp, err
}

func CheckStatus(resp any) (any, error) {
	httpResp := resp.(*http.Response)
	if httpResp.StatusCode >= 400 {
		return nil, errors.New(fmt.Sprintf("request failed: %v", httpResp.Status))
	}
	return resp, nil
}

func Text(resp any) (string, error) {
	httpResp := resp.(*http.Response)
	defer httpResp.Body.Close()
	bodyBytes, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return "", err
	}
	text := string(bodyBytes)
	return text, nil
}

func Bytes(resp any) ([]byte, error) {
	httpResp := resp.(*http.Response)
	defer httpResp.Body.Close()
	bodyBytes, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return nil, err
	}
	return bodyBytes, nil
}
