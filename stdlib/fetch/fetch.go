// Generated by Kukicha v1.0.0 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package fetch

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/duber000/kukicha/stdlib/json"
	"io"
	"net/http"
	"time"
)

type Request struct {
	url       string
	headers   map[string]string
	timeoutNs int64
	method    string
	body      any
}

func New(url string) Request {
	req := Request{}
	req.url = url
	req.headers = make(map[string]string)
	req.timeoutNs = 30000000000
	req.method = "GET"
	req.body = nil
	return req
}

func Header(req Request, name string, value string) Request {
	req.headers[name] = value
	return req
}

func Timeout(req Request, durationNs int64) Request {
	req.timeoutNs = durationNs
	return req
}

func Method(req Request, method string) Request {
	req.method = method
	return req
}

func Body(req Request, data any) Request {
	req.body = data
	return req
}

func Do(req Request) (*http.Response, error) {
	client := http.Client{}
	client.Timeout = time.Duration(req.timeoutNs)
	var bodyData interface{}
	if req.body != nil {
		jsonBytes, marshalErr := json.Marshal(req.body)
		if marshalErr != nil {
			return nil, marshalErr
		}
		bodyData = jsonBytes
	}
	httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
	if reqErr != nil {
		return nil, reqErr
	}
	for name, value := range req.headers {
		httpReq.Header.Set(name, value)
	}
	if req.body != nil {
		contentType := httpReq.Header.Get("Content-Type")
		if contentType == "" {
			httpReq.Header.Set("Content-Type", "application/json")
		}
	}
	resp, doErr := client.Do(httpReq)
	return resp, doErr
}

func createHTTPRequest(method string, url string, bodyData any) (*http.Request, error) {
	if bodyData != nil {
		bodyBytes := bodyData.([]byte)
		req, err := http.NewRequest(method, url, bytes.NewReader(bodyBytes))
		return req, err
	}
	req, err := http.NewRequest(method, url, nil)
	return req, err
}

func Get(url string) (*http.Response, error) {
	req := New(url)
	resp, err := Do(req)
	return resp, err
}

func Post(data any, url string) (*http.Response, error) {
	req := New(url)
	req = Method(req, "POST")
	req.body = data
	resp, err := Do(req)
	return resp, err
}

func CheckStatus(resp *http.Response) (*http.Response, error) {
	if resp.StatusCode >= 400 {
		return nil, errors.New(fmt.Sprintf("request failed: %v", resp.Status))
	}
	return resp, nil
}

func Text(resp *http.Response) (string, error) {
	defer resp.Body.Close()
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	text := string(bodyBytes)
	return text, nil
}

func Bytes(resp *http.Response) ([]byte, error) {
	defer resp.Body.Close()
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return bodyBytes, nil
}

func Json(resp *http.Response) (any, error) {
	defer resp.Body.Close()
	data := make(map[string]any)
	err := json.UnmarshalRead(resp.Body, &data)
	if err != nil {
		return nil, err
	}
	return data, nil
}
