# Kukicha Standard Library - Fetch (HTTP Client)
# Provides both simple functions (Get, Post) and a fluent builder pattern
#
# Examples:
#   # Simple usage
#   resp, err := fetch.Get("https://api.example.com/data")
#
#   # Builder pattern with chaining
#   resp, err := fetch.New("https://api.example.com/data")
#       |> fetch.Header("Authorization", "Bearer token")
#       |> fetch.Timeout(30 * time.Second)
#       |> fetch.Do()

petiole fetch

import "net/http"
import "time"
import "io"
import "strings"
import "stdlib/json"

# Request represents an HTTP request with builder pattern support
type Request
    url string
    headers map of string to string
    timeoutNs int64
    method string
    body any

# New creates a new HTTP request builder for the given URL
# Returns a Request that can be configured with Header(), Timeout(), etc.
# Example: req := fetch.New("https://api.example.com/data")
func New(url string) Request
    req := Request{}
    req.url = url
    req.headers = make(map of string to string)
    req.timeoutNs = 30000000000
    req.method = "GET"
    req.body = empty
    return req

# Header adds an HTTP header to the request and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Header("Authorization", "Bearer token")
func Header(req Request, name string, value string) Request
    req.headers[name] = value
    return req

# Timeout sets the request timeout and returns the modified request for chaining
# Accepts int64 in nanoseconds (use time.Second, time.Millisecond constants)
# Example: req := fetch.New(url) |> fetch.Timeout(30 * time.Second)
func Timeout(req Request, durationNs int64) Request
    req.timeoutNs = durationNs
    return req

# Method sets the HTTP method and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Method("POST")
func Method(req Request, method string) Request
    req.method = method
    return req

# Body sets the request body and returns the modified request for chaining
# Can accept any data type - will be automatically serialized to JSON
# Example: req := fetch.New(url) |> fetch.Body(data)
func Body(req Request, data any) Request
    req.body = data
    return req

# Do executes the configured HTTP request
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.New(url) |> fetch.Header(...) |> fetch.Do()
func Do(req Request) (any, error)
    client := http.Client{}
    client.Timeout = time.Duration(req.timeoutNs)

    # Create body if data is provided
    var bodyReader io.Reader
    if req.body != empty
        # If body is already a reader, use it directly
        if reader, ok := req.body as io.Reader; ok
            bodyReader = reader
        else
            # Otherwise, marshal to JSON
            jsonBytes, marshalErr := json.Marshal(req.body)
            if marshalErr != empty
                return empty, marshalErr
            bodyReader = strings.NewReader(string(jsonBytes))
    
    httpReq, reqErr := http.NewRequest(req.method, req.url, bodyReader)
    if reqErr != empty
        return empty, reqErr

    # Add headers to request
    for name, value in req.headers
        httpReq.Header.Set(name, value)

    # Set Content-Type if body is provided and not already set
    if req.body != empty and httpReq.Header.Get("Content-Type") equals ""
        httpReq.Header.Set("Content-Type", "application/json")

    resp, doErr := client.Do(httpReq)
    return resp, doErr

# Get performs an HTTP GET request to the specified URL (quick function)
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Get("https://api.example.com/data")
func Get(url string) (any, error)
    req := New(url)
    resp, err := Do(req)
    return resp, err

# Post performs an HTTP POST request (quick function)
# Automatically serializes data to JSON using stdlib/json
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Post(userData, "https://api.example.com/users")
func Post(data any, url string) (any, error)
    req := New(url)
    req = Method(req, "POST")
    req.body = data  # Set the body data for automatic JSON serialization
    resp, err := Do(req)
    return resp, err

# CheckStatus checks if response status is successful (2xx)
# Returns the response if successful, error otherwise
# Example: resp |> fetch.CheckStatus() |> fetch.Text()
func CheckStatus(resp any) (any, error)
    httpResp := resp as reference http.Response
    if httpResp.StatusCode >= 400
        return empty, error "request failed: {httpResp.Status}"
    return resp, empty

# Text reads the response body as text
# Example: resp |> fetch.Text()
func Text(resp any) (string, error)
    httpResp := resp as reference http.Response
    defer httpResp.Body.Close()
    bodyBytes, err := io.ReadAll(httpResp.Body)
    if err != empty
        return "", err
    return string(bodyBytes), empty

# Bytes reads the response body as bytes
# Perfect for JSON parsing: resp |> fetch.Bytes() |> json.Unmarshal(_, reference data)
# Example: resp |> fetch.Bytes()
func Bytes(resp any) (list of byte, error)
    httpResp := resp as reference http.Response
    defer httpResp.Body.Close()
    bodyBytes, err := io.ReadAll(httpResp.Body)
    if err != empty
        return empty, err
    return bodyBytes, empty
