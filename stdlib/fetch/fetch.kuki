# Kukicha Standard Library - Fetch (HTTP Client)
# Provides both simple functions (Get, Post) and a fluent builder pattern
#
# Examples:
#   # Simple usage
#   resp, err := fetch.Get("https://api.example.com/data")
#
#   # Builder pattern with chaining
#   resp, err := fetch.New("https://api.example.com/data")
#       |> fetch.Header("Authorization", "Bearer token")
#       |> fetch.Timeout(30 * time.Second)
#       |> fetch.Do()

petiole fetch

import "net/http"
import "net/http/cookiejar"
import "net/url"
import "encoding/base64"
import "time"
import "io"
import "bytes"
import "fmt"
import "stdlib/json"

# Request represents an HTTP request with builder pattern support
type Request
    url string
    headers map of string to string
    timeoutNs int64
    method string
    body any

# New creates a new HTTP request builder for the given URL
# Returns a Request that can be configured with Header(), Timeout(), etc.
# Example: req := fetch.New("https://api.example.com/data")
func New(url string) Request
    req := Request{}
    req.url = url
    req.headers = make(map of string to string)
    req.timeoutNs = 30000000000
    req.method = "GET"
    req.body = empty
    return req

# Header adds an HTTP header to the request and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Header("Authorization", "Bearer token")
func Header(req Request, name string, value string) Request
    req.headers[name] = value
    return req

# Timeout sets the request timeout and returns the modified request for chaining
# Accepts int64 in nanoseconds (use time.Second, time.Millisecond constants)
# Example: req := fetch.New(url) |> fetch.Timeout(30 * time.Second)
func Timeout(req Request, durationNs int64) Request
    req.timeoutNs = durationNs
    return req

# Method sets the HTTP method and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Method("POST")
func Method(req Request, method string) Request
    req.method = method
    return req

# Body sets the request body and returns the modified request for chaining
# Can accept any data type - will be automatically serialized to JSON
# Example: req := fetch.New(url) |> fetch.Body(data)
func Body(req Request, data any) Request
    req.body = data
    return req

# Do executes the configured HTTP request
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.New(url) |> fetch.Header(...) |> fetch.Do()
func Do(req Request) (reference http.Response, error)
    client := http.Client{}
    client.Timeout = time.Duration(req.timeoutNs)

    # Create HTTP request with optional body
    # Use a conditional approach to handle nil vs non-nil io.Reader
    bodyData := empty
    if req.body != empty
        # Check if body is already a string (form data) or needs JSON marshaling
        bodyStr, isString := req.body.(string)
        if isString
            bodyData = bodyStr as list of byte
        else
            # Marshal body to JSON (stdlib/json uses jsonv2 for performance)
            jsonBytes, marshalErr := json.Marshal(req.body)
            if marshalErr != empty
                return empty, marshalErr
            bodyData = jsonBytes

    httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
    if reqErr != empty
        return empty, reqErr

    # Add headers to request
    for name, value in req.headers
        httpReq.Header.Set(name, value)

    # Set Content-Type if body is provided and not already set
    if req.body != empty
        contentType := httpReq.Header.Get("Content-Type")
        if contentType == ""
            httpReq.Header.Set("Content-Type", "application/json")

    resp, doErr := client.Do(httpReq)
    return resp, doErr

# createHTTPRequest wraps http.NewRequest with conditional body reader
func createHTTPRequest(method string, url string, bodyData any) (reference http.Request, error)
    if bodyData != empty
        bodyBytes := bodyData.(list of byte)
        req, err := http.NewRequest(method, url, bytes.NewReader(bodyBytes))
        return req, err
    req, err := http.NewRequest(method, url, empty)
    return req, err

# Get performs an HTTP GET request to the specified URL (quick function)
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Get("https://api.example.com/data")
func Get(url string) (reference http.Response, error)
    req := New(url)
    resp, err := Do(req)
    return resp, err

# Post performs an HTTP POST request (quick function)
# Automatically serializes data to JSON using stdlib/json
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Post(userData, "https://api.example.com/users")
func Post(data any, url string) (reference http.Response, error)
    req := New(url)
    req = Method(req, "POST")
    req.body = data  # Set the body data for automatic JSON serialization
    resp, err := Do(req)
    return resp, err

# CheckStatus checks if response status is successful (2xx)
# Returns the response if successful, error otherwise
# Example: resp |> fetch.CheckStatus() |> fetch.Text()
func CheckStatus(resp reference http.Response) (reference http.Response, error)
    if resp.StatusCode >= 400
        return empty, error "request failed: {resp.Status}"
    return resp, empty

# Text reads the response body as text
# Example: resp |> fetch.Text()
func Text(resp reference http.Response) (string, error)
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return "", err
    # Convert bytes to string using Go's built-in conversion
    text := bodyBytes as string
    return text, empty

# Bytes reads the response body as bytes
# Perfect for JSON parsing: resp |> fetch.Bytes() |> json.Unmarshal(_, reference data)
# Example: resp |> fetch.Bytes()
func Bytes(resp reference http.Response) (list of byte, error)
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return empty, err
    return bodyBytes, empty

# Json reads the response body and unmarshals it as JSON
# Returns the parsed data as any type (typically map of string to any)
# Example: data, err := resp |> fetch.Json()
func Json(resp reference http.Response) (any, error)
    defer resp.Body.Close()
    data := make(map of string to any)
    err := json.UnmarshalRead(resp.Body, reference of data)
    if err != empty
        return empty, err
    return data, empty

# ============================================================================
# P1: Auth Helpers
# ============================================================================

# BearerAuth adds Bearer token authentication to the request
# Example: req |> fetch.BearerAuth(token)
func BearerAuth(req Request, token string) Request
    return Header(req, "Authorization", "Bearer {token}")

# BasicAuth adds HTTP Basic authentication to the request
# Example: req |> fetch.BasicAuth("user", "pass")
func BasicAuth(req Request, username string, password string) Request
    credentials := "{username}:{password}"
    encoded := base64.StdEncoding.EncodeToString(credentials as list of byte)
    return Header(req, "Authorization", "Basic {encoded}")

# ============================================================================
# P2: Form Data Support
# ============================================================================

# FormData sets URL-encoded form data as the request body
# Automatically sets Content-Type to application/x-www-form-urlencoded
# Example: req |> fetch.FormData(map of string to string{"grant_type": "client_credentials"})
func FormData(req Request, data map of string to string) Request
    values := url.Values{}
    for key, value in data
        values.Set(key, value)
    req.body = values.Encode()
    req = Header(req, "Content-Type", "application/x-www-form-urlencoded")
    return req

# ============================================================================
# P3: Sessions with Cookie Jar
# ============================================================================

# Session represents an HTTP client with persistent cookies and default headers
type Session
    client http.Client
    headers map of string to string
    timeoutNs int64

# NewSession creates a new session with a cookie jar for maintaining state
# Example: session := fetch.NewSession()
func NewSession() Session
    jar, _ := cookiejar.New(empty)
    client := http.Client{Jar: jar}
    s := Session{}
    s.client = client
    s.headers = make(map of string to string)
    s.timeoutNs = 30000000000
    return s

# SessionHeader adds a default header to all requests made with this session
# Example: session |> fetch.SessionHeader("Authorization", "Bearer token")
func SessionHeader(s Session, name string, value string) Session
    s.headers[name] = value
    return s

# SessionTimeout sets the default timeout for all requests made with this session
# Example: session |> fetch.SessionTimeout(60 * time.Second)
func SessionTimeout(s Session, durationNs int64) Session
    s.timeoutNs = durationNs
    return s

# SessionDo executes a request using the session's client and default headers
# Maintains cookies across requests automatically
# Example: resp := fetch.SessionDo(session, req)
func SessionDo(s Session, req Request) (reference http.Response, error)
    # Apply session headers to request (request headers override session headers)
    for name, value in s.headers
        _, exists := req.headers[name]
        if not exists
            req.headers[name] = value

    # Use session timeout if request doesn't have custom timeout
    if req.timeoutNs == 30000000000
        req.timeoutNs = s.timeoutNs

    # Set client timeout
    s.client.Timeout = time.Duration(req.timeoutNs)

    # Create HTTP request
    bodyData := empty
    if req.body != empty
        # Check if body is already a string (form data) or needs JSON marshaling
        bodyStr, isString := req.body.(string)
        if isString
            bodyData = bodyStr as list of byte
        else
            jsonBytes, marshalErr := json.Marshal(req.body)
            if marshalErr != empty
                return empty, marshalErr
            bodyData = jsonBytes

    httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
    if reqErr != empty
        return empty, reqErr

    for name, value in req.headers
        httpReq.Header.Set(name, value)

    # Set Content-Type if body is provided and not already set
    if req.body != empty
        contentType := httpReq.Header.Get("Content-Type")
        if contentType == ""
            httpReq.Header.Set("Content-Type", "application/json")

    resp, doErr := s.client.Do(httpReq)
    return resp, doErr

# SessionGet performs an HTTP GET request using the session
# Example: resp := fetch.SessionGet(session, "https://api.example.com/data")
func SessionGet(s Session, url string) (reference http.Response, error)
    req := New(url)
    return SessionDo(s, req)

# SessionPost performs an HTTP POST request using the session
# Example: resp := fetch.SessionPost(session, data, "https://api.example.com/users")
func SessionPost(s Session, data any, url string) (reference http.Response, error)
    req := New(url)
    req = Method(req, "POST")
    req.body = data
    return SessionDo(s, req)
