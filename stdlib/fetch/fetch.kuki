# Kukicha Standard Library - Fetch (HTTP Client)
# Provides both simple functions (Get, Post) and a fluent builder pattern
#
# Examples:
#   # Simple usage
#   resp, err := fetch.Get("https://api.example.com/data")
#
#   # Builder pattern with chaining
#   resp, err := fetch.New("https://api.example.com/data")
#       |> fetch.Header("Authorization", "Bearer token")
#       |> fetch.Timeout(30 * time.Second)
#       |> fetch.Do()

petiole fetch

import "net/http"
import "net/http/cookiejar"
import "net/url"
import "encoding/base64"
import "time"
import "io"
import "bytes"
import "fmt"
import "stdlib/json"
import "stdlib/string"
import "stdlib/retry"
import "stdlib/sandbox"
import "stdlib/netguard"

# Request represents an HTTP request with builder pattern support
type Request
    url string
    headers map of string to string
    timeoutNs int64
    method string
    body any
    transport reference http.Transport
    retryMaxAttempts int
    retryDelayMs int
    maxBodySize int64

# New creates a new HTTP request builder for the given URL
# Returns a Request that can be configured with Header(), Timeout(), etc.
# Example: req := fetch.New("https://api.example.com/data")
func New(url string) Request
    req := Request{}
    req.url = url
    req.headers = make(map of string to string)
    req.timeoutNs = 30000000000
    req.method = "GET"
    req.body = empty
    req.retryMaxAttempts = 0
    req.retryDelayMs = 0
    return req

# Header adds an HTTP header to the request and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Header("Authorization", "Bearer token")
func Header(req Request, name string, value string) Request
    req.headers[name] = value
    return req

# Timeout sets the request timeout and returns the modified request for chaining
# Accepts int64 in nanoseconds (use time.Second, time.Millisecond constants)
# Example: req := fetch.New(url) |> fetch.Timeout(30 * time.Second)
func Timeout(req Request, durationNs int64) Request
    req.timeoutNs = durationNs
    return req

# Method sets the HTTP method and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Method("POST")
func Method(req Request, method string) Request
    req.method = method
    return req

# Body sets the request body and returns the modified request for chaining
# Can accept any data type - will be automatically serialized to JSON
# Example: req := fetch.New(url) |> fetch.Body(data)
func Body(req Request, data any) Request
    req.body = data
    return req

# Transport sets a custom *http.Transport on the request for chaining
# Use with netguard.HTTPTransport() for network-restricted requests
# Example: req |> fetch.Transport(netguard.HTTPTransport(guard))
func Transport(req Request, t reference http.Transport) Request
    req.transport = t
    return req

# MaxBodySize limits the response body to at most limit bytes using io.LimitReader
# Prevents OOM from unexpectedly large server responses
# Example: req := fetch.New(url) |> fetch.MaxBodySize(1 << 20)
func MaxBodySize(req Request, limit int64) Request
    req.maxBodySize = limit
    return req

# Retry configures automatic retry on transient failures (429, 503, network errors).
# maxAttempts is the total number of attempts (1 = no retry). Uses exponential backoff.
# Example: req |> fetch.Retry(3, 500)
func Retry(req Request, maxAttempts int, delayMs int) Request
    req.retryMaxAttempts = maxAttempts
    if delayMs <= 0
        req.retryDelayMs = 1000
    else
        req.retryDelayMs = delayMs
    return req

# doOnce performs a single HTTP attempt with no retry logic
func doOnce(req Request) (reference http.Response, error)
    client := http.Client{}
    if req.transport != empty
        client.Transport = req.transport
    client.Timeout = time.Duration(req.timeoutNs)

    # Create HTTP request with optional body
    bodyData := empty
    if req.body != empty
        # Check if body is already a string (form data) or needs JSON marshaling
        switch req.body as bodyStr
            when string
                bodyData = bodyStr as list of byte
            otherwise
                # Marshal body to JSON (stdlib/json uses jsonv2 for performance)
                jsonBytes, marshalErr := json.Marshal(req.body)
                if marshalErr != empty
                    return empty, marshalErr
                bodyData = jsonBytes

    httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
    if reqErr != empty
        return empty, reqErr

    # Add headers to request
    for name, value in req.headers
        httpReq.Header.Set(name, value)

    # Set Content-Type if body is provided and not already set
    if req.body != empty
        contentType := httpReq.Header.Get("Content-Type")
        if contentType == ""
            httpReq.Header.Set("Content-Type", "application/json")

    resp, doErr := client.Do(httpReq)
    if doErr != empty
        return empty, doErr
    if req.maxBodySize > 0
        resp.Body = io.NopCloser(io.LimitReader(resp.Body, req.maxBodySize))
    return resp, empty

# Do executes the configured HTTP request.
# If Retry() was configured, automatically retries on network errors, 429, and 503.
# Example: resp, err := fetch.New(url) |> fetch.Header(...) |> fetch.Do()
func Do(req Request) (reference http.Response, error)
    if req.retryMaxAttempts <= 1
        return doOnce(req)

    delayMs := req.retryDelayMs
    if delayMs <= 0
        delayMs = 1000
    cfg := retry.Config{MaxAttempts: req.retryMaxAttempts, InitialDelay: delayMs, Strategy: 1}

    attempt := 0
    lastErr := error "no attempts made"
    for attempt < cfg.MaxAttempts
        resp, err := doOnce(req)
        if err == empty
            # Success or non-retryable status: return immediately
            if resp.StatusCode != 429 and resp.StatusCode != 503
                return resp, empty
            # Retryable status (429/503): close body, record error, sleep and retry
            resp.Body.Close()
            lastErr = error "request failed: status {resp.StatusCode}"
        else
            # Network/transport error: record and retry
            lastErr = err
        retry.Sleep(cfg, attempt)
        attempt = attempt + 1

    return empty, lastErr

# createHTTPRequest wraps http.NewRequest with conditional body reader
func createHTTPRequest(method string, url string, bodyData any) (reference http.Request, error)
    if bodyData != empty
        bodyBytes := bodyData.(list of byte)
        req, err := http.NewRequest(method, url, bytes.NewReader(bodyBytes))
        return req, err
    req, err := http.NewRequest(method, url, empty)
    return req, err

# Get performs an HTTP GET request to the specified URL (quick function)
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Get("https://api.example.com/data")
func Get(url string) (reference http.Response, error)
    req := New(url)
    resp, err := Do(req)
    return resp, err

# SafeGet performs an SSRF-protected HTTP GET request
# Uses netguard to block requests to internal IPs, cloud metadata endpoints,
# and loopback addresses. Use this instead of fetch.Get inside HTTP handlers.
# Example: resp, err := fetch.SafeGet("https://api.example.com/data")
func SafeGet(url string) (reference http.Response, error)
    guard := netguard.NewSSRFGuard()
    transport := netguard.HTTPTransport(guard)
    req := New(url)
    req.transport = transport
    resp, err := Do(req)
    return resp, err

# Post performs an HTTP POST request (quick function)
# Automatically serializes data to JSON using stdlib/json
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Post(userData, "https://api.example.com/users")
func Post(data any, url string) (reference http.Response, error)
    req := New(url)
    req = Method(req, "POST")
    req.body = data  # Set the body data for automatic JSON serialization
    resp, err := Do(req)
    return resp, err

# CheckStatus checks if response status is successful (2xx)
# Returns the response if successful, error otherwise
# Example: resp |> fetch.CheckStatus() |> fetch.Text()
func CheckStatus(resp reference http.Response) (reference http.Response, error)
    if resp.StatusCode >= 400
        return empty, error "request failed: {resp.Status}"
    return resp, empty

# Text reads the response body as text
# Example: resp |> fetch.Text()
func Text(resp reference http.Response) (string, error)
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return "", err
    # Convert bytes to string using Go's built-in conversion
    text := bodyBytes as string
    return text, empty

# Bytes reads the response body as bytes
# Perfect for JSON parsing: resp |> fetch.Bytes() |> json.Unmarshal(_, reference data)
# Example: resp |> fetch.Bytes()
func Bytes(resp reference http.Response) (list of byte, error)
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return empty, err
    return bodyBytes, empty

# Json reads the response body and unmarshals it as typed JSON.
# Pass a typed empty value as the second argument to drive inference.
# Example: repos := resp |> fetch.Json(list of Repo)
func Json(resp reference http.Response, sample any) (any, error)
    defer resp.Body.Close()
    data := sample
    json.UnmarshalRead(resp.Body, reference of data) onerr explain "failed to decode response json"
    return data, empty

# Decode reads the response body and unmarshals JSON into a typed target
# Target must be a pointer (use "reference of" in Kukicha)
# Example:
#   repos := empty list of Repo
#   fetch.Get(url) |> fetch.CheckStatus() |> fetch.Decode(_, reference of repos) onerr panic "{error}"
func Decode(resp reference http.Response, target any) error
    defer resp.Body.Close()
    return json.UnmarshalRead(resp.Body, target)

# PathEscape escapes user-provided path segments for safe URL construction.
# Example: safe := fetch.PathEscape("acme/dev team")
func PathEscape(value string) string
    return url.PathEscape(value)

# QueryEscape escapes user-provided query values for safe URL construction.
# Example: safe := fetch.QueryEscape("go lang")
func QueryEscape(value string) string
    return url.QueryEscape(value)

# URLTemplate safely fills {name} placeholders using path escaping by default.
# Any unresolved placeholders cause an error to enforce explicit mapping.
# Example:
#   url := fetch.URLTemplate("https://api.github.com/users/{username}/repos", map of string to string{"username": username}) onerr panic "{error}"
func URLTemplate(tmpl string, params map of string to string) (string, error)
    result := tmpl
    for key, value in params
        placeholder := fmt.Sprintf("%c%s%c", 123, key, 125)
        result = string.ReplaceAll(result, placeholder, url.PathEscape(value))

    if string.Contains(result, "{") or string.Contains(result, "}")
        return "", error "unresolved URL template placeholders: {result}"
    return result, empty

# URLWithQuery adds query parameters with proper encoding.
# Example:
#   withQuery := fetch.URLWithQuery(base, map of string to string{"q": search}) onerr panic "{error}"
func URLWithQuery(baseURL string, params map of string to string) (string, error)
    parsed, err := url.Parse(baseURL)
    if err != empty
        return "", err
    query := parsed.Query()
    for key, value in params
        query.Set(key, value)
    parsed.RawQuery = query.Encode()
    return parsed.String(), empty

# ============================================================================
# P1: Auth Helpers
# ============================================================================

# BearerAuth adds Bearer token authentication to the request
# Example: req |> fetch.BearerAuth(token)
func BearerAuth(req Request, token string) Request
    return Header(req, "Authorization", "Bearer {token}")

# BasicAuth adds HTTP Basic authentication to the request
# Example: req |> fetch.BasicAuth("user", "pass")
func BasicAuth(req Request, username string, password string) Request
    credentials := "{username}:{password}"
    encoded := base64.StdEncoding.EncodeToString(credentials as list of byte)
    return Header(req, "Authorization", "Basic {encoded}")

# ============================================================================
# P2: Form Data Support
# ============================================================================

# FormData sets URL-encoded form data as the request body
# Automatically sets Content-Type to application/x-www-form-urlencoded
# Example: req |> fetch.FormData(map of string to string{"grant_type": "client_credentials"})
func FormData(req Request, data map of string to string) Request
    values := url.Values{}
    for key, value in data
        values.Set(key, value)
    req.body = values.Encode()
    req = Header(req, "Content-Type", "application/x-www-form-urlencoded")
    return req

# ============================================================================
# P3: Sessions with Cookie Jar
# ============================================================================

# Session represents an HTTP client with persistent cookies and default headers
type Session
    client http.Client
    headers map of string to string
    timeoutNs int64

# NewSession creates a new session with a cookie jar for maintaining state
# Example: session := fetch.NewSession()
func NewSession() Session
    jar, _ := cookiejar.New(empty)
    client := http.Client{Jar: jar}
    s := Session{}
    s.client = client
    s.headers = make(map of string to string)
    s.timeoutNs = 30000000000
    return s

# SessionHeader adds a default header to all requests made with this session
# Example: session |> fetch.SessionHeader("Authorization", "Bearer token")
func SessionHeader(s Session, name string, value string) Session
    s.headers[name] = value
    return s

# SessionTimeout sets the default timeout for all requests made with this session
# Example: session |> fetch.SessionTimeout(60 * time.Second)
func SessionTimeout(s Session, durationNs int64) Session
    s.timeoutNs = durationNs
    return s

# SessionDo executes a request using the session's client and default headers
# Maintains cookies across requests automatically
# Example: resp := fetch.SessionDo(session, req)
func SessionDo(s Session, req Request) (reference http.Response, error)
    # Apply session headers to request (request headers override session headers)
    for name, value in s.headers
        _, exists := req.headers[name]
        if not exists
            req.headers[name] = value

    # Use session timeout if request doesn't have custom timeout
    if req.timeoutNs == 30000000000
        req.timeoutNs = s.timeoutNs

    # Set client timeout
    s.client.Timeout = time.Duration(req.timeoutNs)

    # Create HTTP request
    bodyData := empty
    if req.body != empty
        # Check if body is already a string (form data) or needs JSON marshaling
        switch req.body as bodyStr
            when string
                bodyData = bodyStr as list of byte
            otherwise
                jsonBytes, marshalErr := json.Marshal(req.body)
                if marshalErr != empty
                    return empty, marshalErr
                bodyData = jsonBytes

    httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
    if reqErr != empty
        return empty, reqErr

    for name, value in req.headers
        httpReq.Header.Set(name, value)

    # Set Content-Type if body is provided and not already set
    if req.body != empty
        contentType := httpReq.Header.Get("Content-Type")
        if contentType == ""
            httpReq.Header.Set("Content-Type", "application/json")

    resp, doErr := s.client.Do(httpReq)
    return resp, doErr

# SessionGet performs an HTTP GET request using the session
# Example: resp := fetch.SessionGet(session, "https://api.example.com/data")
func SessionGet(s Session, url string) (reference http.Response, error)
    req := New(url)
    return SessionDo(s, req)

# SessionPost performs an HTTP POST request using the session
# Example: resp := fetch.SessionPost(session, data, "https://api.example.com/users")
func SessionPost(s Session, data any, url string) (reference http.Response, error)
    req := New(url)
    req = Method(req, "POST")
    req.body = data
    return SessionDo(s, req)

# SessionTransport sets a custom *http.Transport on the session's client
# Use with netguard.HTTPTransport() for network-restricted sessions
# Example: session |> fetch.SessionTransport(netguard.HTTPTransport(guard))
func SessionTransport(s Session, t reference http.Transport) Session
    s.client.Transport = t
    return s

# ============================================================================
# P4: Sandbox Integration
# ============================================================================

# DownloadTo saves a response body to a file within a sandbox
# Example: fetch.Get(url) |> fetch.DownloadTo(box, "data.json")
func DownloadTo(resp reference http.Response, box sandbox.Root, path string) error
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return err
    return sandbox.WriteString(box, bodyBytes as string, path)
