# Kukicha Standard Library - Fetch (HTTP Client)
# Provides both simple functions (Get, Post) and a fluent builder pattern
#
# Examples:
#   # Simple usage
#   resp, err := fetch.Get("https://api.example.com/data")
#
#   # Builder pattern with chaining
#   resp, err := fetch.New("https://api.example.com/data")
#       |> fetch.Header("Authorization", "Bearer token")
#       |> fetch.Timeout(30 * time.Second)
#       |> fetch.Do()

petiole fetch

import "net/http"
import "time"
import "io"
import "bytes"
import "fmt"
import "stdlib/json"

# Request represents an HTTP request with builder pattern support
type Request
    url string
    headers map of string to string
    timeoutNs int64
    method string
    body any

# New creates a new HTTP request builder for the given URL
# Returns a Request that can be configured with Header(), Timeout(), etc.
# Example: req := fetch.New("https://api.example.com/data")
func New(url string) Request
    req := Request{}
    req.url = url
    req.headers = make(map of string to string)
    req.timeoutNs = 30000000000
    req.method = "GET"
    req.body = empty
    return req

# Header adds an HTTP header to the request and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Header("Authorization", "Bearer token")
func Header(req Request, name string, value string) Request
    req.headers[name] = value
    return req

# Timeout sets the request timeout and returns the modified request for chaining
# Accepts int64 in nanoseconds (use time.Second, time.Millisecond constants)
# Example: req := fetch.New(url) |> fetch.Timeout(30 * time.Second)
func Timeout(req Request, durationNs int64) Request
    req.timeoutNs = durationNs
    return req

# Method sets the HTTP method and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Method("POST")
func Method(req Request, method string) Request
    req.method = method
    return req

# Body sets the request body and returns the modified request for chaining
# Can accept any data type - will be automatically serialized to JSON
# Example: req := fetch.New(url) |> fetch.Body(data)
func Body(req Request, data any) Request
    req.body = data
    return req

# Do executes the configured HTTP request
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.New(url) |> fetch.Header(...) |> fetch.Do()
func Do(req Request) (reference http.Response, error)
    client := http.Client{}
    client.Timeout = time.Duration(req.timeoutNs)

    # Create HTTP request with optional body
    # Use a conditional approach to handle nil vs non-nil io.Reader
    bodyData := empty
    if req.body != empty
        # Marshal body to JSON (stdlib/json uses jsonv2 for performance)
        jsonBytes, marshalErr := json.Marshal(req.body)
        if marshalErr != empty
            return empty, marshalErr
        bodyData = jsonBytes

    httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
    if reqErr != empty
        return empty, reqErr

    # Add headers to request
    for name, value in req.headers
        httpReq.Header.Set(name, value)

    # Set Content-Type if body is provided and not already set
    if req.body != empty
        contentType := httpReq.Header.Get("Content-Type")
        if contentType == ""
            httpReq.Header.Set("Content-Type", "application/json")

    resp, doErr := client.Do(httpReq)
    return resp, doErr

# createHTTPRequest wraps http.NewRequest with conditional body reader
func createHTTPRequest(method string, url string, bodyData any) (reference http.Request, error)
    if bodyData != empty
        bodyBytes := bodyData.(list of byte)
        req, err := http.NewRequest(method, url, bytes.NewReader(bodyBytes))
        return req, err
    req, err := http.NewRequest(method, url, empty)
    return req, err

# Get performs an HTTP GET request to the specified URL (quick function)
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Get("https://api.example.com/data")
func Get(url string) (reference http.Response, error)
    req := New(url)
    resp, err := Do(req)
    return resp, err

# Post performs an HTTP POST request (quick function)
# Automatically serializes data to JSON using stdlib/json
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Post(userData, "https://api.example.com/users")
func Post(data any, url string) (reference http.Response, error)
    req := New(url)
    req = Method(req, "POST")
    req.body = data  # Set the body data for automatic JSON serialization
    resp, err := Do(req)
    return resp, err

# CheckStatus checks if response status is successful (2xx)
# Returns the response if successful, error otherwise
# Example: resp |> fetch.CheckStatus() |> fetch.Text()
func CheckStatus(resp reference http.Response) (reference http.Response, error)
    if resp.StatusCode >= 400
        return empty, error "request failed: {resp.Status}"
    return resp, empty

# Text reads the response body as text
# Example: resp |> fetch.Text()
func Text(resp reference http.Response) (string, error)
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return "", err
    # Convert bytes to string using Go's built-in conversion
    text := bodyBytes as string
    return text, empty

# Bytes reads the response body as bytes
# Perfect for JSON parsing: resp |> fetch.Bytes() |> json.Unmarshal(_, reference data)
# Example: resp |> fetch.Bytes()
func Bytes(resp reference http.Response) (list of byte, error)
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return empty, err
    return bodyBytes, empty
