# Kukicha Standard Library - Fetch (HTTP Client)
# Provides both simple functions (Get, Post) and a fluent builder pattern
#
# Examples:
#   # Simple usage
#   resp, err := fetch.Get("https://api.example.com/data")
#
#   # Builder pattern with chaining
#   resp, err := fetch.New("https://api.example.com/data")
#       |> fetch.Header("Authorization", "Bearer token")
#       |> fetch.Timeout(30 * time.Second)
#       |> fetch.Do()

petiole fetch

import "net/http"
import "net/http/cookiejar"
import "net/url"
import "encoding/base64"
import "time"
import "io"
import "bytes"
import "fmt"
import "strings"
import "stdlib/json"
import "stdlib/sandbox"

# Request represents an HTTP request with builder pattern support
type Request
    url string
    headers map of string to string
    timeoutNs int64
    method string
    body any
    transport reference http.Transport

# New creates a new HTTP request builder for the given URL
# Returns a Request that can be configured with Header(), Timeout(), etc.
# Example: req := fetch.New("https://api.example.com/data")
func New(url string) Request
    req := Request{}
    req.url = url
    req.headers = make(map of string to string)
    req.timeoutNs = 30000000000
    req.method = "GET"
    req.body = empty
    return req

# Header adds an HTTP header to the request and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Header("Authorization", "Bearer token")
func Header(req Request, name string, value string) Request
    req.headers[name] = value
    return req

# Timeout sets the request timeout and returns the modified request for chaining
# Accepts int64 in nanoseconds (use time.Second, time.Millisecond constants)
# Example: req := fetch.New(url) |> fetch.Timeout(30 * time.Second)
func Timeout(req Request, durationNs int64) Request
    req.timeoutNs = durationNs
    return req

# Method sets the HTTP method and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Method("POST")
func Method(req Request, method string) Request
    req.method = method
    return req

# Body sets the request body and returns the modified request for chaining
# Can accept any data type - will be automatically serialized to JSON
# Example: req := fetch.New(url) |> fetch.Body(data)
func Body(req Request, data any) Request
    req.body = data
    return req

# Transport sets a custom *http.Transport on the request for chaining
# Use with netguard.HTTPTransport() for network-restricted requests
# Example: req |> fetch.Transport(netguard.HTTPTransport(guard))
func Transport(req Request, t reference http.Transport) Request
    req.transport = t
    return req

# Do executes the configured HTTP request
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.New(url) |> fetch.Header(...) |> fetch.Do()
func Do(req Request) (reference http.Response, error)
    client := http.Client{}
    if req.transport != empty
        client.Transport = req.transport
    client.Timeout = time.Duration(req.timeoutNs)

    # Create HTTP request with optional body
    # Use a conditional approach to handle nil vs non-nil io.Reader
    bodyData := empty
    if req.body != empty
        # Check if body is already a string (form data) or needs JSON marshaling
        switch req.body as bodyStr
            when string
                bodyData = bodyStr as list of byte
            otherwise
                # Marshal body to JSON (stdlib/json uses jsonv2 for performance)
                jsonBytes, marshalErr := json.Marshal(req.body)
                if marshalErr != empty
                    return empty, marshalErr
                bodyData = jsonBytes

    httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
    if reqErr != empty
        return empty, reqErr

    # Add headers to request
    for name, value in req.headers
        httpReq.Header.Set(name, value)

    # Set Content-Type if body is provided and not already set
    if req.body != empty
        contentType := httpReq.Header.Get("Content-Type")
        if contentType == ""
            httpReq.Header.Set("Content-Type", "application/json")

    resp, doErr := client.Do(httpReq)
    return resp, doErr

# createHTTPRequest wraps http.NewRequest with conditional body reader
func createHTTPRequest(method string, url string, bodyData any) (reference http.Request, error)
    if bodyData != empty
        bodyBytes := bodyData.(list of byte)
        req, err := http.NewRequest(method, url, bytes.NewReader(bodyBytes))
        return req, err
    req, err := http.NewRequest(method, url, empty)
    return req, err

# Get performs an HTTP GET request to the specified URL (quick function)
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Get("https://api.example.com/data")
func Get(url string) (reference http.Response, error)
    req := New(url)
    resp, err := Do(req)
    return resp, err

# Post performs an HTTP POST request (quick function)
# Automatically serializes data to JSON using stdlib/json
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Post(userData, "https://api.example.com/users")
func Post(data any, url string) (reference http.Response, error)
    req := New(url)
    req = Method(req, "POST")
    req.body = data  # Set the body data for automatic JSON serialization
    resp, err := Do(req)
    return resp, err

# CheckStatus checks if response status is successful (2xx)
# Returns the response if successful, error otherwise
# Example: resp |> fetch.CheckStatus() |> fetch.Text()
func CheckStatus(resp reference http.Response) (reference http.Response, error)
    if resp.StatusCode >= 400
        return empty, error "request failed: {resp.Status}"
    return resp, empty

# Text reads the response body as text
# Example: resp |> fetch.Text()
func Text(resp reference http.Response) (string, error)
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return "", err
    # Convert bytes to string using Go's built-in conversion
    text := bodyBytes as string
    return text, empty

# Bytes reads the response body as bytes
# Perfect for JSON parsing: resp |> fetch.Bytes() |> json.Unmarshal(_, reference data)
# Example: resp |> fetch.Bytes()
func Bytes(resp reference http.Response) (list of byte, error)
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return empty, err
    return bodyBytes, empty

# Json reads the response body and unmarshals it as JSON
# Returns parsed JSON as any (map/list/scalar based on payload shape)
# Example: data, err := resp |> fetch.Json()
func Json(resp reference http.Response) (any, error)
    defer resp.Body.Close()
    data := empty any
    err := json.UnmarshalRead(resp.Body, reference of data)
    if err != empty
        return empty, err
    return data, empty

# Decode reads the response body and unmarshals JSON into a typed target
# Target must be a pointer (use "reference of" in Kukicha)
# Example:
#   repos := empty list of Repo
#   fetch.Get(url) |> fetch.CheckStatus() |> fetch.Decode(_, reference of repos) onerr panic "{error}"
func Decode(resp reference http.Response, target any) error
    defer resp.Body.Close()
    return json.UnmarshalRead(resp.Body, target)

# JsonAs is a typed decode helper for JSON responses.
# Target must be a pointer (use "reference of" in Kukicha).
# Example:
#   repos := empty list of Repo
#   fetch.Get(url) |> fetch.CheckStatus() |> fetch.JsonAs(_, reference of repos) onerr panic "{error}"
func JsonAs(resp reference http.Response, target any) error
    return Decode(resp, target)

# DecodeAs is an alias for Decode with naming that mirrors JsonAs.
# Target must be a pointer (use "reference of" in Kukicha).
func DecodeAs(resp reference http.Response, target any) error
    return Decode(resp, target)

# PathEscape escapes user-provided path segments for safe URL construction.
# Example: safe := fetch.PathEscape("acme/dev team")
func PathEscape(value string) string
    return url.PathEscape(value)

# QueryEscape escapes user-provided query values for safe URL construction.
# Example: safe := fetch.QueryEscape("go lang")
func QueryEscape(value string) string
    return url.QueryEscape(value)

# URLTemplate safely fills {name} placeholders using path escaping by default.
# Any unresolved placeholders cause an error to enforce explicit mapping.
# Example:
#   url := fetch.URLTemplate("https://api.github.com/users/{username}/repos", map of string to string{"username": username}) onerr panic "{error}"
func URLTemplate(tmpl string, params map of string to string) (string, error)
    result := tmpl
    for key, value in params
        placeholder := fmt.Sprintf("%c%s%c", 123, key, 125)
        result = strings.ReplaceAll(result, placeholder, url.PathEscape(value))

    if strings.Contains(result, "{") or strings.Contains(result, "}")
        return "", error "unresolved URL template placeholders: {result}"
    return result, empty

# URLWithQuery adds query parameters with proper encoding.
# Example:
#   withQuery := fetch.URLWithQuery(base, map of string to string{"q": search}) onerr panic "{error}"
func URLWithQuery(baseURL string, params map of string to string) (string, error)
    parsed, err := url.Parse(baseURL)
    if err != empty
        return "", err
    query := parsed.Query()
    for key, value in params
        query.Set(key, value)
    parsed.RawQuery = query.Encode()
    return parsed.String(), empty

# ============================================================================
# P1: Auth Helpers
# ============================================================================

# BearerAuth adds Bearer token authentication to the request
# Example: req |> fetch.BearerAuth(token)
func BearerAuth(req Request, token string) Request
    return Header(req, "Authorization", "Bearer {token}")

# BasicAuth adds HTTP Basic authentication to the request
# Example: req |> fetch.BasicAuth("user", "pass")
func BasicAuth(req Request, username string, password string) Request
    credentials := "{username}:{password}"
    encoded := base64.StdEncoding.EncodeToString(credentials as list of byte)
    return Header(req, "Authorization", "Basic {encoded}")

# ============================================================================
# P2: Form Data Support
# ============================================================================

# FormData sets URL-encoded form data as the request body
# Automatically sets Content-Type to application/x-www-form-urlencoded
# Example: req |> fetch.FormData(map of string to string{"grant_type": "client_credentials"})
func FormData(req Request, data map of string to string) Request
    values := url.Values{}
    for key, value in data
        values.Set(key, value)
    req.body = values.Encode()
    req = Header(req, "Content-Type", "application/x-www-form-urlencoded")
    return req

# ============================================================================
# P3: Sessions with Cookie Jar
# ============================================================================

# Session represents an HTTP client with persistent cookies and default headers
type Session
    client http.Client
    headers map of string to string
    timeoutNs int64

# NewSession creates a new session with a cookie jar for maintaining state
# Example: session := fetch.NewSession()
func NewSession() Session
    jar, _ := cookiejar.New(empty)
    client := http.Client{Jar: jar}
    s := Session{}
    s.client = client
    s.headers = make(map of string to string)
    s.timeoutNs = 30000000000
    return s

# SessionHeader adds a default header to all requests made with this session
# Example: session |> fetch.SessionHeader("Authorization", "Bearer token")
func SessionHeader(s Session, name string, value string) Session
    s.headers[name] = value
    return s

# SessionTimeout sets the default timeout for all requests made with this session
# Example: session |> fetch.SessionTimeout(60 * time.Second)
func SessionTimeout(s Session, durationNs int64) Session
    s.timeoutNs = durationNs
    return s

# SessionDo executes a request using the session's client and default headers
# Maintains cookies across requests automatically
# Example: resp := fetch.SessionDo(session, req)
func SessionDo(s Session, req Request) (reference http.Response, error)
    # Apply session headers to request (request headers override session headers)
    for name, value in s.headers
        _, exists := req.headers[name]
        if not exists
            req.headers[name] = value

    # Use session timeout if request doesn't have custom timeout
    if req.timeoutNs == 30000000000
        req.timeoutNs = s.timeoutNs

    # Set client timeout
    s.client.Timeout = time.Duration(req.timeoutNs)

    # Create HTTP request
    bodyData := empty
    if req.body != empty
        # Check if body is already a string (form data) or needs JSON marshaling
        switch req.body as bodyStr
            when string
                bodyData = bodyStr as list of byte
            otherwise
                jsonBytes, marshalErr := json.Marshal(req.body)
                if marshalErr != empty
                    return empty, marshalErr
                bodyData = jsonBytes

    httpReq, reqErr := createHTTPRequest(req.method, req.url, bodyData)
    if reqErr != empty
        return empty, reqErr

    for name, value in req.headers
        httpReq.Header.Set(name, value)

    # Set Content-Type if body is provided and not already set
    if req.body != empty
        contentType := httpReq.Header.Get("Content-Type")
        if contentType == ""
            httpReq.Header.Set("Content-Type", "application/json")

    resp, doErr := s.client.Do(httpReq)
    return resp, doErr

# SessionGet performs an HTTP GET request using the session
# Example: resp := fetch.SessionGet(session, "https://api.example.com/data")
func SessionGet(s Session, url string) (reference http.Response, error)
    req := New(url)
    return SessionDo(s, req)

# SessionPost performs an HTTP POST request using the session
# Example: resp := fetch.SessionPost(session, data, "https://api.example.com/users")
func SessionPost(s Session, data any, url string) (reference http.Response, error)
    req := New(url)
    req = Method(req, "POST")
    req.body = data
    return SessionDo(s, req)

# SessionTransport sets a custom *http.Transport on the session's client
# Use with netguard.HTTPTransport() for network-restricted sessions
# Example: session |> fetch.SessionTransport(netguard.HTTPTransport(guard))
func SessionTransport(s Session, t reference http.Transport) Session
    s.client.Transport = t
    return s

# ============================================================================
# P4: Sandbox Integration
# ============================================================================

# DownloadTo saves a response body to a file within a sandbox
# Example: fetch.Get(url) |> fetch.DownloadTo(box, "data.json")
func DownloadTo(resp reference http.Response, box sandbox.Root, path string) error
    defer resp.Body.Close()
    bodyBytes, err := io.ReadAll(resp.Body)
    if err != empty
        return err
    return sandbox.WriteString(box, bodyBytes as string, path)
