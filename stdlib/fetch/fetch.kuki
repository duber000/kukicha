# Kukicha Standard Library - Fetch (HTTP Client)
# Provides both simple functions (Get, Post) and a fluent builder pattern
#
# Examples:
#   # Simple usage
#   resp, err := fetch.Get("https://api.example.com/data")
#
#   # Builder pattern with chaining
#   resp, err := fetch.New("https://api.example.com/data")
#       |> fetch.Header("Authorization", "Bearer token")
#       |> fetch.Timeout(30 * time.Second)
#       |> fetch.Do()

petiole fetch

import "net/http"
import "time"

# Request represents an HTTP request with builder pattern support
type Request
    url string
    headers map of string to string
    timeoutNs int64
    method string
    body any

# New creates a new HTTP request builder for the given URL
# Returns a Request that can be configured with Header(), Timeout(), etc.
# Example: req := fetch.New("https://api.example.com/data")
func New(url string) Request
    req := Request{}
    req.url = url
    req.headers = make(map of string to string)
    req.timeoutNs = 30000000000
    req.method = "GET"
    req.body = empty
    return req

# Header adds an HTTP header to the request and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Header("Authorization", "Bearer token")
func Header(req Request, name string, value string) Request
    req.headers[name] = value
    return req

# Timeout sets the request timeout and returns the modified request for chaining
# Accepts int64 in nanoseconds (use time.Second, time.Millisecond constants)
# Example: req := fetch.New(url) |> fetch.Timeout(30 * time.Second)
func Timeout(req Request, durationNs int64) Request
    req.timeoutNs = durationNs
    return req

# Method sets the HTTP method and returns the modified request for chaining
# Example: req := fetch.New(url) |> fetch.Method("POST")
func Method(req Request, method string) Request
    req.method = method
    return req

# Do executes the configured HTTP request
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.New(url) |> fetch.Header(...) |> fetch.Do()
func Do(req Request) (any, error)
    client := http.Client{}
    client.Timeout = time.Duration(req.timeoutNs)

    httpReq, reqErr := http.NewRequest(req.method, req.url, empty)
    if reqErr != empty
        return empty, reqErr

    # Add headers to request
    for name, value in req.headers
        httpReq.Header.Set(name, value)

    resp, doErr := client.Do(httpReq)
    return resp, doErr

# Get performs an HTTP GET request to the specified URL (quick function)
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Get("https://api.example.com/data")
func Get(url string) (any, error)
    req := New(url)
    resp, err := Do(req)
    return resp, err

# Post performs an HTTP POST request (quick function)
# Returns the HTTP response and any error that occurred
# Example: resp, err := fetch.Post(data, "https://api.example.com/users")
func Post(data any, url string) (any, error)
    req := New(url)
    req = Method(req, "POST")
    resp, err := Do(req)
    return resp, err

# Json reads and parses JSON from an HTTP response
# Note: Requires manual Go interop - resp is *http.Response
func Json(resp any) (any, error)
    return empty, error "use Go interop"

# Text reads the response body as text
# Note: Requires manual Go interop - resp is *http.Response
func Text(resp any) (string, error)
    return "", error "use Go interop"

# CheckStatus checks if response status is successful (2xx)
# Note: Requires manual Go interop - resp is *http.Response
func CheckStatus(resp any) (any, error)
    return empty, error "use Go interop"
