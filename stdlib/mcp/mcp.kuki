# Kukicha Standard Library - MCP Server Wrapper

petiole mcp

import "context"
import "stdlib/ctx" as ctxpkg
import "encoding/json"
import "github.com/modelcontextprotocol/go-sdk/mcp"

# ToolHandler is a callback for handling MCP tool invocations.
type ToolHandler func(map of string to any) (any, error)

# SchemaProperty represents a property in a JSON schema
type SchemaProperty
    Name string
    Type string
    Description string

# New creates a new MCP server with the given name and version.
# Example:
#   server := mcp.New("my-server", "1.0.0")
func New(name string, version string) reference mcp.Server
    return mcp.NewServer(reference of mcp.Implementation{
        Name: name,
        Version: version,
    }, empty)

# Serve runs the server on the stdio transport (blocking).
# Usually called at the very end of func main().
# Example:
#   server |> mcp.Serve() onerr panic "{error}"
func Serve(server reference mcp.Server) error
    bg := ctxpkg.Background()
    return server.Run(ctxpkg.Value(bg), reference of mcp.StdioTransport{})

# Prop creates a new SchemaProperty
func Prop(name string, typ string, description string) SchemaProperty
    return SchemaProperty{Name: name, Type: typ, Description: description}

# Schema creates a JSON schema object from a list of properties
func Schema(props list of SchemaProperty) map of string to any
    properties := make(map of string to any)
    for prop in props
        properties[prop.Name] = map of string to any{
            "type": prop.Type,
            "description": prop.Description,
        }

    return map of string to any{
        "type": "object",
        "properties": properties,
    }

# Required adds a list of required property names to a schema
func Required(schema any, names list of string) any
    switch schema as s
        when map of string to any
            s["required"] = names
            return s
        otherwise
            return schema

# TextResult creates a successful tool result containing the given text.
# Useful for returning strings directly to the AI.
func TextResult(text string) any
    return reference of mcp.CallToolResult{
        Content: list of mcp.Content{reference of mcp.TextContent{Text: text}},
    }

# ErrorResult creates an error tool result containing the given message.
func ErrorResult(msg string) any
    return reference of mcp.CallToolResult{
        Content: list of mcp.Content{reference of mcp.TextContent{Text: msg}},
        IsError: true,
    }

# Tool registers an MCP tool with the given handler.
# The handler receives parsed JSON arguments and returns a result.
# String and *mcp.CallToolResult results are handled directly;
# other types are JSON-serialized.
# Example:
#   server |> mcp.Tool("hello", "Say hello", schema, func(args) { return "Hi!", empty })
func Tool(server reference mcp.Server, name string, description string, schema any, handler ToolHandler)
    server.AddTool(reference of mcp.Tool{
        Name: name,
        Description: description,
        InputSchema: schema,
    }, func(ctx context.Context, req reference mcp.CallToolRequest) (reference mcp.CallToolResult, error)
        args := make(map of string to any)
        if len(req.Params.Arguments) > 0
            unmarshalErr := json.Unmarshal(req.Params.Arguments, reference of args)
            if unmarshalErr != empty
                return empty, unmarshalErr
        res, handlerErr := handler(args)
        if handlerErr != empty
            return reference of mcp.CallToolResult{
                Content: list of mcp.Content{reference of mcp.TextContent{Text: handlerErr.Error()}},
                IsError: true,
            }, empty
        switch res as r
            when reference mcp.CallToolResult
                return r, empty
            when string
                return reference of mcp.CallToolResult{
                    Content: list of mcp.Content{reference of mcp.TextContent{Text: r}},
                }, empty
        data, _ := json.Marshal(res)
        return reference of mcp.CallToolResult{
            Content: list of mcp.Content{reference of mcp.TextContent{Text: string(data)}},
        }, empty
    )
