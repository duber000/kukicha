# Tests for Kukicha Standard Library - JSON Package

petiole json_test

import "stdlib/json"
import "stdlib/test"
import "bytes"
import "testing"

# Simple struct used across tests
type Person
    Name string as "name"
    Age int as "age"

# --- TestMarshal ---
type MarshalCase
    name string

func TestMarshal(t reference testing.T)
    cases := list of MarshalCase{
        MarshalCase{name: "marshal person"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            p := Person{Name: "Alice", Age: 30}
            data, err := json.Marshal(p)
            test.AssertNoError(t, err)
            if len(data) == 0
                t.Error("Expected non-empty JSON bytes")

            data2, err2 := json.Marshal(p)
            test.AssertNoError(t, err2)
            test.AssertEqual(t, len(data), len(data2))
        )

# --- TestUnmarshal ---
type UnmarshalCase
    name string

func TestUnmarshal(t reference testing.T)
    cases := list of UnmarshalCase{
        UnmarshalCase{name: "unmarshal person"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            p := Person{Name: "Bob", Age: 25}
            data, marshalErr := json.Marshal(p)
            test.AssertNoError(t, marshalErr)

            result := empty Person
            unmarshalErr := json.Unmarshal(data, reference of result)
            test.AssertNoError(t, unmarshalErr)
            test.AssertEqual(t, result.Name, "Bob")
            test.AssertEqual(t, result.Age, 25)
        )

# --- TestMarshalUnmarshalRoundTrip ---
type RoundTripCase
    name string

func TestMarshalUnmarshalRoundTrip(t reference testing.T)
    cases := list of RoundTripCase{
        RoundTripCase{name: "round trip"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            original := Person{Name: "Charlie", Age: 42}
            data, err := json.Marshal(original)
            test.AssertNoError(t, err)

            restored := empty Person
            err2 := json.Unmarshal(data, reference of restored)
            test.AssertNoError(t, err2)

            test.AssertEqual(t, restored.Name, original.Name)
            test.AssertEqual(t, restored.Age, original.Age)
        )

# --- TestMarshalPretty ---
type MarshalPrettyCase
    name string

func TestMarshalPretty(t reference testing.T)
    cases := list of MarshalPrettyCase{
        MarshalPrettyCase{name: "pretty print"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            p := Person{Name: "Dan", Age: 28}
            compact, err := json.Marshal(p)
            test.AssertNoError(t, err)

            pretty, err2 := json.MarshalPretty(p)
            test.AssertNoError(t, err2)

            if len(pretty) == 0
                t.Error("Expected non-empty pretty JSON bytes")

            if len(pretty) <= len(compact)
                t.Errorf("Expected pretty JSON (len={len(pretty)}) to be longer than compact (len={len(compact)})")
        )

# --- TestMarshalWrite ---
type MarshalWriteCase
    name string

func TestMarshalWrite(t reference testing.T)
    cases := list of MarshalWriteCase{
        MarshalWriteCase{name: "write to buffer"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            p := Person{Name: "Eve", Age: 22}
            buf := bytes.Buffer{}
            err := json.MarshalWrite(reference of buf, p)
            test.AssertNoError(t, err)
            if buf.Len() == 0
                t.Error("Expected non-empty buffer after MarshalWrite")
        )

# --- TestUnmarshalRead ---
type UnmarshalReadCase
    name string

func TestUnmarshalRead(t reference testing.T)
    cases := list of UnmarshalReadCase{
        UnmarshalReadCase{name: "read from buffer"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            p := Person{Name: "Frank", Age: 35}
            buf := bytes.Buffer{}
            writeErr := json.MarshalWrite(reference of buf, p)
            test.AssertNoError(t, writeErr)

            result := empty Person
            readErr := json.UnmarshalRead(reference of buf, reference of result)
            test.AssertNoError(t, readErr)
            test.AssertEqual(t, result.Name, "Frank")
            test.AssertEqual(t, result.Age, 35)
        )

# --- TestEncode ---
type EncodeCase
    name string

func TestEncode(t reference testing.T)
    cases := list of EncodeCase{
        EncodeCase{name: "encode to buffer"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            p := Person{Name: "Grace", Age: 29}
            buf := bytes.Buffer{}
            enc := json.NewEncoder(reference of buf)
            err := json.Encode(enc, p)
            test.AssertNoError(t, err)
            if buf.Len() == 0
                t.Error("Expected non-empty buffer after Encode")
        )

# --- TestDecode ---
type DecodeCase
    name string

func TestDecode(t reference testing.T)
    cases := list of DecodeCase{
        DecodeCase{name: "decode from buffer"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            p := Person{Name: "Hank", Age: 40}
            buf := bytes.Buffer{}
            enc := json.NewEncoder(reference of buf)
            encErr := json.Encode(enc, p)
            test.AssertNoError(t, encErr)

            result := empty Person
            dec := json.NewDecoder(reference of buf)
            decErr := json.Decode(dec, reference of result)
            test.AssertNoError(t, decErr)
            test.AssertEqual(t, result.Name, "Hank")
            test.AssertEqual(t, result.Age, 40)
        )

# --- TestWithIndent ---
type WithIndentCase
    name string

func TestWithIndent(t reference testing.T)
    cases := list of WithIndentCase{
        WithIndentCase{name: "indent encoding"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            p := Person{Name: "Iris", Age: 33}
            buf := bytes.Buffer{}
            enc := json.NewEncoder(reference of buf) |> json.WithIndent("  ")
            err := json.Encode(enc, p)
            test.AssertNoError(t, err)
            if buf.Len() == 0
                t.Error("Expected non-empty buffer after Encode with indent")
        )

# --- TestUnmarshalInvalidJSON ---
type UnmarshalInvalidCase
    name string

func TestUnmarshalInvalidJSON(t reference testing.T)
    cases := list of UnmarshalInvalidCase{
        UnmarshalInvalidCase{name: "invalid json"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            invalid := "not valid json" as list of byte
            result := empty Person
            err := json.Unmarshal(invalid, reference of result)
            test.AssertError(t, err)
        )
