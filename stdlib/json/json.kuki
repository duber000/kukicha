# Kukicha Standard Library - JSON (jsonv2 wrapper)
# Pipe-friendly wrapper around Go 1.26+ encoding/json/v2
# Provides beautiful pipe syntax with 2-10x performance improvements

petiole json

import "encoding/json/v2"
import "encoding/json" as jsonv1
import "io"

# Encoder wraps jsonv2 for pipe-friendly encoding with builder pattern
type Encoder
    writer io.Writer
    deterministic bool
    indent string
    prefix string

# Decoder wraps jsonv2 for pipe-friendly decoding
type Decoder
    reader io.Reader

# NewEncoder creates a pipe-friendly jsonv2 encoder
# Returns an Encoder that can be chained with options before encoding
# Example: response |> json.NewEncoder() |> json.Encode(data)
func NewEncoder(writer io.Writer) Encoder
    enc := Encoder{}
    enc.writer = writer
    enc.deterministic = false
    enc.indent = ""
    enc.prefix = ""
    return enc

# WithDeterministic sets deterministic output (consistent field ordering)
# Chainable - returns modified encoder for piping
# Example: writer |> json.NewEncoder() |> json.WithDeterministic() |> json.Encode(data)
func WithDeterministic(enc Encoder) Encoder
    enc.deterministic = true
    return enc

# WithIndent sets pretty-printing with indentation
# Chainable - returns modified encoder for piping
# Example: writer |> json.NewEncoder() |> json.WithIndent("  ") |> json.Encode(data)
func WithIndent(enc Encoder, indent string) Encoder
    enc.indent = indent
    return enc

# WithPrefix sets prefix for each line (used with indentation)
# Chainable - returns modified encoder for piping
func WithPrefix(enc Encoder, prefix string) Encoder
    enc.prefix = prefix
    return enc

# Encode writes a value as JSON using jsonv2 with configured options
# This is the final step in the pipe chain
# Uses encoding/json/v2.MarshalWrite for direct io.Writer support
# Note: indent/prefix options not yet supported (limitation of current jsonv2 wrapper)
# Example: response |> json.NewEncoder() |> json.Encode(todo) onerr return
# Or with onerr: json.Encode(enc, todo) onerr return error
func Encode(enc Encoder, value any) error
    # Apply deterministic encoding if requested
    if enc.deterministic
        return json.MarshalWrite(enc.writer, value, json.Deterministic(true))

    # Default: standard marshaling to writer
    return json.MarshalWrite(enc.writer, value)

# NewDecoder creates a pipe-friendly jsonv2 decoder
# Returns a Decoder for reading JSON from a stream
# Example: request.Body |> json.NewDecoder() |> json.Decode(reference result)
func NewDecoder(reader io.Reader) Decoder
    dec := Decoder{}
    dec.reader = reader
    return dec

# Decode reads JSON from the decoder's reader into the target value
# Target must be a pointer (use "reference of" in Kukicha)
# Uses encoding/json/v2.UnmarshalRead for direct io.Reader support
# Example: body |> json.NewDecoder() |> json.Decode(reference todo) onerr return
# Or with onerr: json.Decode(dec, reference todo) onerr return error
func Decode(dec Decoder, target any) error
    return json.UnmarshalRead(dec.reader, target)

# Marshal converts a value to JSON bytes (convenience function)
# For simple marshaling without a writer
# Uses encoding/json/v2 for 2-10x performance improvement
# Example: jsonBytes, err := Marshal(data) onerr panic
# Or with onerr: jsonBytes := Marshal(data) onerr return empty, error
func Marshal(value any) (list of byte, error)
    bytes, err := json.Marshal(value)
    return bytes, err

# MarshalPretty converts a value to pretty-printed JSON bytes with 2-space indentation
# Uses encoding/json (v1) MarshalIndent for compatibility
# Note: Slightly slower than Marshal but provides readable output
# Example: jsonBytes, err := MarshalPretty(config) onerr panic
# Or with onerr: jsonBytes := MarshalPretty(config) onerr return empty, error
func MarshalPretty(value any) (list of byte, error)
    # Use v1 MarshalIndent for pretty-printing (2-space indentation)
    # TODO: Migrate to jsonv2 options when textual encoding API is available
    bytes, err := jsonv1.MarshalIndent(value, "", "  ")
    return bytes, err

# Unmarshal parses JSON bytes into a target value
# Target must be a pointer (use "reference of" in Kukicha)
# Uses encoding/json/v2 for 2-10x performance improvement
# Example: Unmarshal(jsonBytes, reference config) onerr panic
# Or with onerr: Unmarshal(jsonBytes, reference config) onerr return error
func Unmarshal(data list of byte, target any) error
    return json.Unmarshal(data, target)

# MarshalWrite writes JSON directly to an io.Writer (Go 1.26+ jsonv2)
# Perfect for HTTP responses and streaming scenarios
# Uses placeholder strategy: todo |> MarshalWrite(response, _)
# Example: todo |> json.MarshalWrite(w, _) onerr panic
func MarshalWrite(writer io.Writer, value any) error
    return json.MarshalWrite(writer, value)

# UnmarshalRead reads JSON directly from an io.Reader into the target value
# Target must be a pointer (use "reference of" in Kukicha)
# Uses encoding/json/v2.UnmarshalRead for direct io.Reader support
# Perfect for HTTP request bodies with pipe placeholder strategy
# Example: request.Body |> json.UnmarshalRead(_, reference todo) onerr return
func UnmarshalRead(reader io.Reader, target any) error
    return json.UnmarshalRead(reader, target)

# DecodeRead reads JSON from an io.Reader into a typed value using the sample pattern.
# Pass a typed empty value to drive type inference â€” no pre-declared variable needed.
# Example: input := request.Body |> json.DecodeRead(empty ShortenRequest) onerr ...
func DecodeRead(reader io.Reader, sample any) (any, error)
    data := sample
    json.UnmarshalRead(reader, reference of data) onerr explain "failed to decode json"
    return data, empty
