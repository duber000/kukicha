# Kukicha Standard Library - JSON
# Pipe-friendly wrapper around Go encoding/json

petiole json

import "encoding/json"
import "io"

# Encoder wraps encoding/json for pipe-friendly encoding with builder pattern
type Encoder
    writer io.Writer
    deterministic bool
    indent string
    prefix string

# Decoder wraps encoding/json for pipe-friendly decoding
type Decoder
    reader io.Reader

# NewEncoder creates a pipe-friendly encoder
# Returns an Encoder that can be chained with options before encoding
# Example: response |> json.NewEncoder() |> json.Encode(data)
func NewEncoder(writer io.Writer) Encoder
    enc := Encoder{}
    enc.writer = writer
    enc.deterministic = false
    enc.indent = ""
    enc.prefix = ""
    return enc

# WithDeterministic sets deterministic output (consistent field ordering)
# Chainable - returns modified encoder for piping
# Example: writer |> json.NewEncoder() |> json.WithDeterministic() |> json.Encode(data)
func WithDeterministic(enc Encoder) Encoder
    enc.deterministic = true
    return enc

# WithIndent sets pretty-printing with indentation
# Chainable - returns modified encoder for piping
# Example: writer |> json.NewEncoder() |> json.WithIndent("  ") |> json.Encode(data)
func WithIndent(enc Encoder, indent string) Encoder
    enc.indent = indent
    return enc

# WithPrefix sets prefix for each line (used with indentation)
# Chainable - returns modified encoder for piping
func WithPrefix(enc Encoder, prefix string) Encoder
    enc.prefix = prefix
    return enc

# Encode writes a value as JSON using encoding/json with configured options
# This is the final step in the pipe chain
# Uses json.NewEncoder(w).Encode(v) for direct io.Writer support
# Note: indent/prefix options not yet supported
# Example: response |> json.NewEncoder() |> json.Encode(todo) onerr return
# Or with onerr: json.Encode(enc, todo) onerr return error
func Encode(enc Encoder, value any) error
    # Use standard encoder; v1 already sorts map keys deterministically
    encoder := json.NewEncoder(enc.writer)
    return encoder.Encode(value)

# NewDecoder creates a pipe-friendly decoder
# Returns a Decoder for reading JSON from a stream
# Example: request.Body |> json.NewDecoder() |> json.Decode(reference result)
func NewDecoder(reader io.Reader) Decoder
    dec := Decoder{}
    dec.reader = reader
    return dec

# Decode reads JSON from the decoder's reader into the target value
# Target must be a pointer (use "reference of" in Kukicha)
# Example: body |> json.NewDecoder() |> json.Decode(reference todo) onerr return
# Or with onerr: json.Decode(dec, reference todo) onerr return error
func Decode(dec Decoder, target any) error
    decoder := json.NewDecoder(dec.reader)
    return decoder.Decode(target)

# Marshal converts a value to JSON bytes (convenience function)
# For simple marshaling without a writer
# Example: jsonBytes, err := Marshal(data) onerr panic
# Or with onerr: jsonBytes := Marshal(data) onerr return empty, error
func Marshal(value any) (list of byte, error)
    bytes, err := json.Marshal(value)
    return bytes, err

# MarshalPretty converts a value to pretty-printed JSON bytes with 2-space indentation
# Example: jsonBytes, err := MarshalPretty(config) onerr panic
# Or with onerr: jsonBytes := MarshalPretty(config) onerr return empty, error
func MarshalPretty(value any) (list of byte, error)
    bytes, err := json.MarshalIndent(value, "", "  ")
    return bytes, err

# Unmarshal parses JSON bytes into a target value
# Target must be a pointer (use "reference of" in Kukicha)
# Example: Unmarshal(jsonBytes, reference config) onerr panic
# Or with onerr: Unmarshal(jsonBytes, reference config) onerr return error
func Unmarshal(data list of byte, target any) error
    return json.Unmarshal(data, target)

# MarshalWrite writes JSON directly to an io.Writer
# Perfect for HTTP responses and streaming scenarios
# Uses placeholder strategy: todo |> MarshalWrite(response, _)
# Example: todo |> json.MarshalWrite(w, _) onerr panic
func MarshalWrite(writer io.Writer, value any) error
    encoder := json.NewEncoder(writer)
    return encoder.Encode(value)

# UnmarshalRead reads JSON directly from an io.Reader into the target value
# Target must be a pointer (use "reference of" in Kukicha)
# Perfect for HTTP request bodies with pipe placeholder strategy
# Example: request.Body |> json.UnmarshalRead(_, reference todo) onerr return
func UnmarshalRead(reader io.Reader, target any) error
    decoder := json.NewDecoder(reader)
    return decoder.Decode(target)

# DecodeRead reads JSON from an io.Reader into a typed value using the sample pattern.
# Pass a typed empty value to drive type inference â€” no pre-declared variable needed.
# Example: input := request.Body |> json.DecodeRead(empty ShortenRequest) onerr ...
func DecodeRead(reader io.Reader, sample any) (any, error)
    data := sample
    decoder := json.NewDecoder(reader)
    decoder.Decode(reference of data) onerr explain "failed to decode json"
    return data, empty
