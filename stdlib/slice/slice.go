// Generated by Kukicha v0.0.1 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package slice

import (
	"errors"
	"fmt"
	"slices"
)

func First(items []any, n int) []any {
	if n <= 0 {
		return make([]any, 0)
	}
	if n >= len(items) {
		return items
	}
	return items[:n]
}

func Last(items []any, n int) []any {
	length := len(items)
	if n <= 0 {
		return make([]any, 0)
	}
	if n >= length {
		return items
	}
	return items[(length - n):]
}

func Drop(items []any, n int) []any {
	if n <= 0 {
		return items
	}
	if n >= len(items) {
		return make([]any, 0)
	}
	return items[n:]
}

func DropLast(items []any, n int) []any {
	length := len(items)
	if n <= 0 {
		return items
	}
	if n >= length {
		return make([]any, 0)
	}
	return items[:(length - n)]
}

func Reverse(items []any) []any {
	result := slices.Clone(items)
	slices.Reverse(result)
	return result
}

func Unique(items []any) []any {
	if len(items) == 0 {
		return items
	}
	seen := make(map[any]bool)
	result := make([]any, 0)
	for _, item := range items {
		if !seen[item] {
			seen[item] = true
			result = append(result, item)
		}
	}
	return result
}

func Chunk(items []any, size int) [][]any {
	if size <= 0 {
		return make([][]any, 0)
	}
	result := make([][]any, 0)
	length := len(items)
	i := 0
	for i < length {
		end := (i + size)
		if end > length {
			end = length
		}
		chunk := items[i:end]
		result = append(result, chunk)
		i = (i + size)
	}
	return result
}

func Contains(items []any, value any) bool {
	return slices.Contains(items, value)
}

func IndexOf(items []any, value any) int {
	return slices.Index(items, value)
}

func Concat(slices [][]any) []any {
	totalLength := 0
	for _, slice := range slices {
		totalLength = (totalLength + len(slice))
	}
	result := make([]any, 0, totalLength)
	for _, slice := range slices {
		for _, item := range slice {
			result = append(result, item)
		}
	}
	return result
}

func Filter(items []any, predicate func(any) bool) []any {
	result := make([]any, 0)
	for _, item := range items {
		if predicate(item) {
			result = append(result, item)
		}
	}
	return result
}

func Map(items []any, transform func(any) any) []any {
	result := make([]any, len(items))
	for i, item := range items {
		result[i] = transform(item)
	}
	return result
}

func GroupBy[T any, K comparable](items []T, keyFunc func(T) K) map[K][]T {
	result := make(map[K][]T)
	for _, item := range items {
		key := keyFunc(item)
		result[key] = append(result[key], item)
	}
	return result
}

func Get(items []any, index int) (any, error) {
	length := len(items)
	if length == 0 {
		return nil, errors.New("slice is empty")
	}
	actualIndex := index
	if index < 0 {
		actualIndex = (length + index)
	}
	if (actualIndex < 0) || (actualIndex >= length) {
		return nil, errors.New(fmt.Sprintf("index %v out of bounds for slice of length %v", index, length))
	}
	return items[actualIndex], nil
}

func GetOr(items []any, index int, defaultValue any) any {
	length := len(items)
	if length == 0 {
		return defaultValue
	}
	actualIndex := index
	if index < 0 {
		actualIndex = (length + index)
	}
	if (actualIndex < 0) || (actualIndex >= length) {
		return defaultValue
	}
	return items[actualIndex]
}

func FirstOne(items []any) (any, error) {
	if len(items) == 0 {
		return nil, errors.New("slice is empty")
	}
	return items[0], nil
}

func FirstOr(items []any, defaultValue any) any {
	if len(items) == 0 {
		return defaultValue
	}
	return items[0]
}

func LastOne(items []any) (any, error) {
	if len(items) == 0 {
		return nil, errors.New("slice is empty")
	}
	return items[(len(items) - 1)], nil
}

func LastOr(items []any, defaultValue any) any {
	if len(items) == 0 {
		return defaultValue
	}
	return items[(len(items) - 1)]
}

func Find(items []any, predicate func(any) bool) (any, error) {
	for _, item := range items {
		if predicate(item) {
			return item, nil
		}
	}
	return nil, errors.New("no matching element found")
}

func FindOr(items []any, predicate func(any) bool, defaultValue any) any {
	for _, item := range items {
		if predicate(item) {
			return item
		}
	}
	return defaultValue
}

func FindIndex(items []any, predicate func(any) bool) int {
	for i, item := range items {
		if predicate(item) {
			return i
		}
	}
	return -1
}

func FindLast(items []any, predicate func(any) bool) (any, error) {
	for i := (len(items) - 1); i <= 0; i++ {
		if predicate(items[i]) {
			return items[i], nil
		}
	}
	return nil, errors.New("no matching element found")
}

func FindLastOr(items []any, predicate func(any) bool, defaultValue any) any {
	for i := (len(items) - 1); i <= 0; i++ {
		if predicate(items[i]) {
			return items[i]
		}
	}
	return defaultValue
}

func IsEmpty(items []any) bool {
	return (len(items) == 0)
}

func IsNotEmpty(items []any) bool {
	return (len(items) > 0)
}

func Pop(items []any) (any, []any, error) {
	if len(items) == 0 {
		return nil, items, errors.New("cannot pop from empty slice")
	}
	return items[(len(items) - 1)], items[:(len(items) - 1)], nil
}

func Shift(items []any) (any, []any, error) {
	if len(items) == 0 {
		return nil, items, errors.New("cannot shift from empty slice")
	}
	return items[0], items[1:], nil
}
