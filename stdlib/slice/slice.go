// Generated by Kukicha v0.0.1 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package slice

import "slices"

func First(items []any, n int) []any {
	if n <= 0 {
		return make([]any, 0)
	}
	if n >= len(items) {
		return items
	}
	return items[:n]
}

func Last(items []any, n int) []any {
	length := len(items)
	if n <= 0 {
		return make([]any, 0)
	}
	if n >= length {
		return items
	}
	return items[(length - n):]
}

func Drop(items []any, n int) []any {
	if n <= 0 {
		return items
	}
	if n >= len(items) {
		return make([]any, 0)
	}
	return items[n:]
}

func DropLast(items []any, n int) []any {
	length := len(items)
	if n <= 0 {
		return items
	}
	if n >= length {
		return make([]any, 0)
	}
	return items[:(length - n)]
}

func Reverse(items []any) []any {
	result := slices.Clone(items)
	slices.Reverse(result)
	return result
}

func Unique(items []any) []any {
	if len(items) == 0 {
		return items
	}
	seen := make(map[any]bool)
	result := make([]any, 0)
	for _, item := range items {
		if !seen[item] {
			seen[item] = true
			result = append(result, item)
		}
	}
	return result
}

func Chunk(items []any, size int) [][]any {
	if size <= 0 {
		return make([][]any, 0)
	}
	result := make([][]any, 0)
	length := len(items)
	i := 0
	for i < length {
		end := (i + size)
		if end > length {
			end = length
		}
		chunk := items[i:end]
		result = append(result, chunk)
		i = (i + size)
	}
	return result
}

func Contains(items []any, value any) bool {
	return slices.Contains(items, value)
}

func IndexOf(items []any, value any) int {
	return slices.Index(items, value)
}

func Concat(slices [][]any) []any {
	totalLength := 0
	for _, slice := range slices {
		totalLength = (totalLength + len(slice))
	}
	result := make([]any, 0, totalLength)
	for _, slice := range slices {
		for _, item := range slice {
			result = append(result, item)
		}
	}
	return result
}

func Filter(items []any, predicate func(any) bool) []any {
	result := make([]any, 0)
	for _, item := range items {
		if predicate(item) {
			result = append(result, item)
		}
	}
	return result
}

func Map(items []any, transform func(any) any) []any {
	result := make([]any, len(items))
	for i, item := range items {
		result[i] = transform(item)
	}
	return result
}

func GroupBy[T any, K comparable](items []T, keyFunc func(T) K) map[K][]T {
	result := make(map[K][]T)
	for _, item := range items {
		key := keyFunc(item)
		result[key] = append(result[key], item)
	}
	return result
}
