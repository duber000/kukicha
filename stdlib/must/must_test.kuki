# Tests for Kukicha Standard Library - Must Package

petiole must_test

import "stdlib/must"
import "os"
import "stdlib/string"
import "stdlib/test"
import "testing"

# --- TestDoWithoutError ---
type DoCase
    name string
    value string
    err error
    want string

func TestDo(t reference testing.T)
    cases := list of DoCase{
        DoCase{
            name: "returns value when no error",
            value: "ok",
            err: empty,
            want: "ok",
        },
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := must.Do(tc.value, tc.err)
            test.AssertEqual(t, got, tc.want)
        )

# --- TestOk ---
type OkCase
    name string
    err error
    wantPanic bool

func TestOk(t reference testing.T)
    cases := list of OkCase{
        OkCase{
            name: "succeeds when error empty",
            err: empty,
            wantPanic: false,
        },
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            must.Ok(tc.err)
            test.AssertNoError(t, tc.err)
        )

# --- TestEnvHelpers ---
type EnvCase
    name string
    envKey string
    envValue string
    want string

func TestEnvHelpers(t reference testing.T)
    cases := list of EnvCase{
        EnvCase{
            name: "returns set env value",
            envKey: "MUST_TEST",
            envValue: "value",
            want: "value",
        },
        EnvCase{
            name: "returns default when env missing",
            envKey: "MISSING_TEST",
            envValue: "",
            want: "default",
        },
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            if len(tc.envValue) > 0
                os.Setenv(tc.envKey, tc.envValue)
            
            if tc.want == "default"
                got := must.EnvOr(tc.envKey, "default")
                test.AssertEqual(t, got, "default")
                os.Unsetenv(tc.envKey)
                gotDefault := must.EnvOr(tc.envKey, "default")
                test.AssertEqual(t, gotDefault, "default")
            else
                got := must.Env(tc.envKey)
                test.AssertEqual(t, got, tc.want)
                gotOr := must.EnvOr(tc.envKey, "default")
                test.AssertEqual(t, gotOr, tc.want)
        )

# --- TestAssertionHelpers ---
type AssertionCase
    name string
    condition bool
    wantPanic bool

func TestAssertionHelpers(t reference testing.T)
    cases := list of AssertionCase{
        AssertionCase{name: "True succeeds on true", condition: true, wantPanic: false},
        AssertionCase{name: "False succeeds on false", condition: false, wantPanic: false},
        AssertionCase{name: "NotEmpty succeeds on non-empty", condition: true, wantPanic: false},
        AssertionCase{name: "NotNil succeeds on non-nil", condition: true, wantPanic: false},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            if string.Contains(tc.name, "True")
                must.True(tc.condition, "message")
            else if string.Contains(tc.name, "False")
                must.False(tc.condition, "message")
            else if string.Contains(tc.name, "Empty")
                must.NotEmpty("x", "name")
            else if string.Contains(tc.name, "Nil")
                must.NotNil("value", "value")
            test.AssertNoError(t, empty)
        )
