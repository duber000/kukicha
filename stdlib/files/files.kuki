# Kukicha Standard Library - File Operations
# Simplified version compatible with current Kukicha compiler limitations

petiole files

import "os"
import "io"
import "path/filepath"
import "stdlib/json"
import "time"

# Read reads the entire contents of a file as bytes
# Returns the file contents and any error that occurred
# Example: "config.json" |> files.Read()
func Read(path string) (list of byte, error)
    data, err := os.ReadFile(path)
    if err != empty
        return empty, err
    return data, empty

# ReadBytes reads the entire contents of a file as a byte slice
# Returns the file contents and any error that occurred
# Example: "image.png" |> files.ReadBytes()
func ReadBytes(path string) (list of byte, error)
    data, err := os.ReadFile(path)
    return data, err

# Write writes data to a file, creating it if it doesn't exist
# Marshals data to JSON with indentation
# Returns any error that occurred
# Example: data |> files.Write("output.json")
func Write(data any, path string) error
    jsonData, err := json.MarshalPretty(data)
    if err != empty
        return err
    writeErr := os.WriteFile(path, jsonData, 0644)
    return writeErr

# WriteString writes a string to a file
# Returns any error that occurred
# Example: "Hello, World!" |> files.WriteString("output.txt")
func WriteString(data string, path string) error
    bytesData := data as list of byte
    return os.WriteFile(path, bytesData, 0644)

# Append appends data to a file, creating it if it doesn't exist
# Marshals data to JSON
# Returns any error that occurred
# Example: "new line\n" |> files.Append("log.txt")
func Append(data any, path string) error
    file, err := os.OpenFile(path, os.O_APPEND | os.O_CREATE | os.O_WRONLY, 0644)
    if err != empty
        return err
    defer file.Close()

    jsonData, jsonErr := json.Marshal(data)
    if jsonErr != empty
        return jsonErr
    # Add newline by appending a byte directly
    jsonData = append(jsonData, '\n')
    _, writeErr := file.Write(jsonData)
    return writeErr

# AppendString appends a raw string to a file, creating it if it doesn't exist
# Unlike Append, this does NOT marshal the data as JSON
# Returns any error that occurred
# Example: "new line\n" |> files.AppendString("log.txt")
func AppendString(data string, path string) error
    file, err := os.OpenFile(path, os.O_APPEND | os.O_CREATE | os.O_WRONLY, 0644)
    if err != empty
        return err
    defer file.Close()

    bytesData := data as list of byte
    _, writeErr := file.Write(bytesData)
    return writeErr

# Exists checks if a file or directory exists
# Returns true if the path exists, false otherwise
# Example: if files.Exists("config.yaml") ...
func Exists(path string) bool
    _, err := os.Stat(path)
    return err == empty

# IsDir checks if a path is a directory
# Returns true if the path is a directory, false otherwise
# Example: if files.IsDir("src") ...
func IsDir(path string) bool
    info, err := os.Stat(path)
    if err != empty
        return false
    return info.IsDir()

# IsFile checks if a path is a regular file
# Returns true if the path is a file, false otherwise
# Example: if files.IsFile("main.go") ...
func IsFile(path string) bool
    info, err := os.Stat(path)
    if err != empty
        return false
    return not info.IsDir()

# List returns a list of file names in the specified directory
# Does not recurse into subdirectories
# Returns a list of file names and any error that occurred
# Example: files.List("/var/log")
func List(path string) (list of string, error)
    entries, err := os.ReadDir(path)
    if err != empty
        return empty, err

    result := make(list of string, 0, len(entries))
    for entry in entries
        result = append(result, entry.Name())

    return result, empty

# ListRecursive returns all files recursively under the specified directory
# Returns a list of absolute file paths and any error that occurred
# Example: files.ListRecursive("/var/log")
func ListRecursive(path string) (list of string, error)
    result := make(list of string, 0)
    walkErr := filepath.Walk(path, func(filePath string, info os.FileInfo, err error) error
        if err != empty
            return err
        if not info.IsDir()
            result = append(result, filePath)
        return empty
    )
    return result, walkErr

# Delete removes a file or empty directory
# Returns any error that occurred
# Example: "temp.txt" |> files.Delete()
func Delete(path string) error
    return os.Remove(path)

# DeleteAll removes a file or directory tree
# Recursively removes all subdirectories and files
# Returns any error that occurred
# Example: "temp_dir" |> files.DeleteAll()
func DeleteAll(path string) error
    return os.RemoveAll(path)

# Copy copies a file from src to dst
# Creates the destination file if it doesn't exist
# Returns any error that occurred
# Example: files.Copy("source.txt", "destination.txt")
func Copy(src string, dst string) error
    sourceFile, err := os.Open(src)
    if err != empty
        return err
    defer sourceFile.Close()

    destFile, createErr := os.Create(dst)
    if createErr != empty
        return createErr
    defer destFile.Close()

    _, copyErr := io.Copy(destFile, sourceFile)
    return copyErr

# Move moves/renames a file or directory
# Returns any error that occurred
# Example: files.Move("old.txt", "new.txt")
func Move(src string, dst string) error
    return os.Rename(src, dst)

# MkDir creates a directory with the specified path
# Returns any error if the directory cannot be created
# Example: "/tmp/mydir" |> files.MkDir()
func MkDir(path string) error
    return os.Mkdir(path, 0755)

# MkDirAll creates a directory and all necessary parent directories
# Returns any error that occurred
# Example: "/tmp/a/b/c" |> files.MkDirAll()
func MkDirAll(path string) error
    return os.MkdirAll(path, 0755)

# TempFile creates a temporary file and returns its path
# The file will have the specified prefix in its name
# Returns the file path and any error that occurred
# Example: files.TempFile("upload-") |> processFile()
func TempFile(prefix string) (string, error)
    file, err := os.CreateTemp("", prefix)
    if err != empty
        return "", err

    path := file.Name()
    closeErr := file.Close()
    return path, closeErr

# TempDir creates a temporary directory and returns its path
# The directory will have the specified prefix in its name
# Returns the directory path and any error that occurred
# Example: files.TempDir("build-") |> runBuild()
func TempDir(prefix string) (string, error)
    path, err := os.MkdirTemp("", prefix)
    return path, err

# Size returns the size of a file in bytes
# Returns the size and any error that occurred
# Example: "large-file.dat" |> files.Size()
func Size(path string) (int64, error)
    info, err := os.Stat(path)
    if err != empty
        return 0, err
    return info.Size(), empty

# ModTime returns the last modification time of a file as Unix timestamp
# Returns the modification time in seconds since epoch and any error that occurred
# Example: "document.txt" |> files.ModTime()
func ModTime(path string) (int64, error)
    info, err := os.Stat(path)
    if err != empty
        return 0, err
    return info.ModTime().Unix(), empty

# Basename returns the last element of the path
# Example: "/path/to/file.txt" |> files.Basename() # Returns "file.txt"
func Basename(path string) string
    return filepath.Base(path)

# Dirname returns the directory portion of the path
# Example: "/path/to/file.txt" |> files.Dirname() # Returns "/path/to"
func Dirname(path string) string
    return filepath.Dir(path)

# Extension returns the file extension including the dot
# Example: "file.txt" |> files.Extension() # Returns ".txt"
func Extension(path string) string
    return filepath.Ext(path)

# Join joins two path elements into a single path
# Example: files.Join("/home", "user/file.txt")
func Join(part1 string, part2 string) string
    return filepath.Join(part1, part2)

# Abs returns the absolute path of the file
# Returns the absolute path and any error that occurred
# Example: "relative/path.txt" |> files.Abs()
func Abs(path string) (string, error)
    absPath, err := filepath.Abs(path)
    return absPath, err

# UseWith executes an action on a file path and ensures it is deleted afterwards
# Useful for temporary files and directories
# Example: files.TempDir("test") |> files.UseWith(processDir)
func UseWith(path string, action func(string))
    defer os.RemoveAll(path)
    action(path)

# Watch monitors files matching a pattern for changes
# Polls for changes every 500ms
# Example: files.Watch("./*.txt", func(path string) { print("Changed: " + path) })
func Watch(pattern string, callback func(string))
    lastModified := make(map of string to int64)

    # Initial scan to populate baseline
    matches, _ := filepath.Glob(pattern)
    if matches != empty
        for match in matches
            info, err := os.Stat(match)
            if err == empty
                lastModified[match] = info.ModTime().UnixNano()

    for
        time.Sleep(500 * time.Millisecond)
        
        matches, err := filepath.Glob(pattern)
        if err == empty
            for match in matches
                info, statErr := os.Stat(match)
                if statErr == empty
                    currentModTime := info.ModTime().UnixNano()
                    
                    # Check for zero value (implies new/not found)
                    lastModTime := lastModified[match]
                    
                    if lastModTime == 0
                        # New file found
                        lastModified[match] = currentModTime
                        callback(match)
                    else if currentModTime > lastModTime
                        # File modified
                        lastModified[match] = currentModTime
                        callback(match)

