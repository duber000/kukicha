# Tests for Kukicha Standard Library - Files Package

petiole files_test

import "testing"
import "stdlib/test"
import "stdlib/files"
import "os"
import "path/filepath"
import "time"

type TestData
    Name  string
    Value int

# --- TestReadWrite ---
type ReadWriteCase
    name string

func TestReadWrite(t reference testing.T)
    cases := list of ReadWriteCase{
        ReadWriteCase{name: "basic"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-files-test-")
            test.AssertNoError(t, err)
            defer os.RemoveAll(tmpDir)

            testFile := filepath.Join(tmpDir, "test.txt")
            testContent := "Hello, Kukicha!"

            err = files.WriteString(testContent, testFile)
            test.AssertNoError(t, err)

            content, readErr := files.Read(testFile)
            test.AssertNoError(t, readErr)

            contentStr := content as string
            test.AssertEqual(t, contentStr, testContent)
        )

# --- TestWriteJSON ---
type WriteJSONCase
    name string

func TestWriteJSON(t reference testing.T)
    cases := list of WriteJSONCase{
        WriteJSONCase{name: "write struct"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-files-test-")
            test.AssertNoError(t, err)
            defer os.RemoveAll(tmpDir)

            testFile := filepath.Join(tmpDir, "data.json")
            testData := TestData{Name: "test", Value: 42}

            err = files.Write(testData, testFile)
            test.AssertNoError(t, err)
            test.AssertTrue(t, files.Exists(testFile))

            content, readErr := files.Read(testFile)
            test.AssertNoError(t, readErr)
            if len(content) == 0
                t.Error("Expected non-empty JSON content")
        )

# --- TestExists ---
type ExistsCase
    name string

func TestExists(t reference testing.T)
    cases := list of ExistsCase{
        ExistsCase{name: "file exists"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-files-test-")
            test.AssertNoError(t, err)
            defer os.RemoveAll(tmpDir)

            existingFile := filepath.Join(tmpDir, "exists.txt")
            nonExistentFile := filepath.Join(tmpDir, "does-not-exist.txt")

            err = files.WriteString("test", existingFile)
            test.AssertNoError(t, err)

            test.AssertTrue(t, files.Exists(existingFile))
            test.AssertFalse(t, files.Exists(nonExistentFile))
        )

# --- TestIsDir ---
type IsDirCase
    name string

func TestIsDir(t reference testing.T)
    cases := list of IsDirCase{
        IsDirCase{name: "check directory"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-files-test-")
            test.AssertNoError(t, err)
            defer os.RemoveAll(tmpDir)

            testFile := filepath.Join(tmpDir, "file.txt")
            testDir := filepath.Join(tmpDir, "subdir")

            err = files.WriteString("test", testFile)
            test.AssertNoError(t, err)

            err = os.Mkdir(testDir, 0755)
            test.AssertNoError(t, err)

            test.AssertTrue(t, files.IsDir(testDir))
            test.AssertFalse(t, files.IsDir(testFile))
        )

# --- TestList ---
type ListCase
    name string

func TestList(t reference testing.T)
    cases := list of ListCase{
        ListCase{name: "list files"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-files-test-")
            test.AssertNoError(t, err)
            defer os.RemoveAll(tmpDir)

            files.WriteString("test1", filepath.Join(tmpDir, "file1.txt"))
            files.WriteString("test2", filepath.Join(tmpDir, "file2.txt"))
            os.Mkdir(filepath.Join(tmpDir, "subdir"), 0755)

            entries, listErr := files.List(tmpDir)
            test.AssertNoError(t, listErr)
            test.AssertEqual(t, len(entries), 3)

            for entry in entries
                if entry == ""
                    t.Error("Expected non-empty path")
        )

# --- TestAppend ---
type AppendCase
    name string

func TestAppend(t reference testing.T)
    cases := list of AppendCase{
        AppendCase{name: "append string"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-files-test-")
            test.AssertNoError(t, err)
            defer os.RemoveAll(tmpDir)

            testFile := filepath.Join(tmpDir, "append.txt")

            err = files.WriteString("Line 1\n", testFile)
            test.AssertNoError(t, err)

            err = files.AppendString("Line 2\n", testFile)
            test.AssertNoError(t, err)

            content, readErr := files.Read(testFile)
            test.AssertNoError(t, readErr)

            expected := "Line 1\nLine 2\n"
            contentStr := content as string
            test.AssertEqual(t, contentStr, expected)
        )

# --- TestCopy ---
type CopyCase
    name string

func TestCopy(t reference testing.T)
    cases := list of CopyCase{
        CopyCase{name: "copy file"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-files-test-")
            test.AssertNoError(t, err)
            defer os.RemoveAll(tmpDir)

            srcFile := filepath.Join(tmpDir, "source.txt")
            dstFile := filepath.Join(tmpDir, "destination.txt")
            testContent := "Copy me!"

            err = files.WriteString(testContent, srcFile)
            test.AssertNoError(t, err)

            err = files.Copy(srcFile, dstFile)
            test.AssertNoError(t, err)
            test.AssertTrue(t, files.Exists(dstFile))

            content, readErr := files.Read(dstFile)
            test.AssertNoError(t, readErr)

            contentStr := content as string
            test.AssertEqual(t, contentStr, testContent)
        )

# --- TestDelete ---
type DeleteCase
    name string

func TestDelete(t reference testing.T)
    cases := list of DeleteCase{
        DeleteCase{name: "delete file"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-files-test-")
            test.AssertNoError(t, err)
            defer os.RemoveAll(tmpDir)

            testFile := filepath.Join(tmpDir, "delete-me.txt")

            err = files.WriteString("test", testFile)
            test.AssertNoError(t, err)
            test.AssertTrue(t, files.Exists(testFile))

            err = files.Delete(testFile)
            test.AssertNoError(t, err)
            test.AssertFalse(t, files.Exists(testFile))
        )

# --- TestTempFile ---
type TempFileCase
    name string

func TestTempFile(t reference testing.T)
    cases := list of TempFileCase{
        TempFileCase{name: "create temp file"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            path, err := files.TempFile("kukicha-test-")
            test.AssertNoError(t, err)
            defer os.Remove(path)

            test.AssertTrue(t, files.Exists(path))

            err = files.WriteString("temp data", path)
            test.AssertNoError(t, err)
        )

# --- TestPathFunctions ---
type PathCase
    name string

func TestPathFunctions(t reference testing.T)
    cases := list of PathCase{
        PathCase{name: "path operations"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            testPath := "/home/user/document.txt"

            basename := files.Basename(testPath)
            test.AssertEqual(t, basename, "document.txt")

            dirname := files.Dirname(testPath)
            test.AssertEqual(t, dirname, "/home/user")

            ext := files.Extension(testPath)
            test.AssertEqual(t, ext, ".txt")
        )

# --- TestUseWith ---
type UseWithCase
    name string

func TestUseWith(t reference testing.T)
    cases := list of UseWithCase{
        UseWithCase{name: "use with block"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-files-test-")
            test.AssertNoError(t, err)
            
            testFile := filepath.Join(tmpDir, "temp.txt")
            files.WriteString("content", testFile)
            
            existed := false
            files.UseWith(testFile, func(path string)
                if files.Exists(path)
                    existed = true
            )
            
            test.AssertTrue(t, existed)
            test.AssertFalse(t, files.Exists(testFile))
                
            os.RemoveAll(tmpDir)
        )

# --- TestWatch ---
type WatchCase
    name string

func TestWatch(t reference testing.T)
    cases := list of WatchCase{
        WatchCase{name: "watch file"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            tmpDir, err := os.MkdirTemp("", "kukicha-watch-test-")
            test.AssertNoError(t, err)
            defer os.RemoveAll(tmpDir)
            
            testFile := filepath.Join(tmpDir, "watch.txt")
            files.WriteString("initial", testFile)
            
            ch := make(channel of string)
            go files.Watch(filepath.Join(tmpDir, "*.txt"), func(path string)
                send path to ch
            )
            
            time.Sleep(1 * time.Second)
            files.WriteString("modified", testFile)
            
            receivedPath := receive from ch
            test.AssertEqual(t, receivedPath, testFile)
        )
