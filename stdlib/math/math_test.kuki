# Tests for Kukicha Standard Library - Math Package

petiole math_test

import "stdlib/math"
import "testing"

# Test Abs returns the absolute value
func TestAbs(t reference testing.T)
    if math.Abs(-5.0) != 5.0
        t.Errorf("Expected Abs(-5.0) = 5.0, got {math.Abs(-5.0)}")
    if math.Abs(5.0) != 5.0
        t.Errorf("Expected Abs(5.0) = 5.0, got {math.Abs(5.0)}")
    if math.Abs(0.0) != 0.0
        t.Errorf("Expected Abs(0.0) = 0.0, got {math.Abs(0.0)}")
    if math.Abs(-0.001) != 0.001
        t.Errorf("Expected Abs(-0.001) = 0.001, got {math.Abs(-0.001)}")

# Test Round rounds to nearest integer
func TestRound(t reference testing.T)
    if math.Round(3.7) != 4.0
        t.Errorf("Expected Round(3.7) = 4.0, got {math.Round(3.7)}")
    if math.Round(3.2) != 3.0
        t.Errorf("Expected Round(3.2) = 3.0, got {math.Round(3.2)}")
    if math.Round(3.5) != 4.0
        t.Errorf("Expected Round(3.5) = 4.0, got {math.Round(3.5)}")
    if math.Round(-3.5) != -4.0
        t.Errorf("Expected Round(-3.5) = -4.0, got {math.Round(-3.5)}")
    if math.Round(0.0) != 0.0
        t.Errorf("Expected Round(0.0) = 0.0, got {math.Round(0.0)}")

# Test Floor rounds down
func TestFloor(t reference testing.T)
    if math.Floor(3.9) != 3.0
        t.Errorf("Expected Floor(3.9) = 3.0, got {math.Floor(3.9)}")
    if math.Floor(3.0) != 3.0
        t.Errorf("Expected Floor(3.0) = 3.0, got {math.Floor(3.0)}")
    if math.Floor(-1.1) != -2.0
        t.Errorf("Expected Floor(-1.1) = -2.0, got {math.Floor(-1.1)}")
    if math.Floor(-1.0) != -1.0
        t.Errorf("Expected Floor(-1.0) = -1.0, got {math.Floor(-1.0)}")

# Test Ceil rounds up
func TestCeil(t reference testing.T)
    if math.Ceil(3.1) != 4.0
        t.Errorf("Expected Ceil(3.1) = 4.0, got {math.Ceil(3.1)}")
    if math.Ceil(3.0) != 3.0
        t.Errorf("Expected Ceil(3.0) = 3.0, got {math.Ceil(3.0)}")
    if math.Ceil(-1.9) != -1.0
        t.Errorf("Expected Ceil(-1.9) = -1.0, got {math.Ceil(-1.9)}")
    if math.Ceil(-1.0) != -1.0
        t.Errorf("Expected Ceil(-1.0) = -1.0, got {math.Ceil(-1.0)}")

# Test Min and Max
func TestMinMax(t reference testing.T)
    if math.Min(3.0, 7.0) != 3.0
        t.Errorf("Expected Min(3.0, 7.0) = 3.0, got {math.Min(3.0, 7.0)}")
    if math.Min(7.0, 3.0) != 3.0
        t.Errorf("Expected Min(7.0, 3.0) = 3.0, got {math.Min(7.0, 3.0)}")
    if math.Min(5.0, 5.0) != 5.0
        t.Errorf("Expected Min(5.0, 5.0) = 5.0, got {math.Min(5.0, 5.0)}")

    if math.Max(3.0, 7.0) != 7.0
        t.Errorf("Expected Max(3.0, 7.0) = 7.0, got {math.Max(3.0, 7.0)}")
    if math.Max(7.0, 3.0) != 7.0
        t.Errorf("Expected Max(7.0, 3.0) = 7.0, got {math.Max(7.0, 3.0)}")
    if math.Max(5.0, 5.0) != 5.0
        t.Errorf("Expected Max(5.0, 5.0) = 5.0, got {math.Max(5.0, 5.0)}")

# Test Pow raises a base to a power
func TestPow(t reference testing.T)
    if math.Pow(2.0, 8.0) != 256.0
        t.Errorf("Expected Pow(2.0, 8.0) = 256.0, got {math.Pow(2.0, 8.0)}")
    if math.Pow(3.0, 3.0) != 27.0
        t.Errorf("Expected Pow(3.0, 3.0) = 27.0, got {math.Pow(3.0, 3.0)}")
    if math.Pow(5.0, 0.0) != 1.0
        t.Errorf("Expected Pow(5.0, 0.0) = 1.0, got {math.Pow(5.0, 0.0)}")
    if math.Pow(1.0, 100.0) != 1.0
        t.Errorf("Expected Pow(1.0, 100.0) = 1.0, got {math.Pow(1.0, 100.0)}")

# Test Sqrt returns the square root
func TestSqrt(t reference testing.T)
    if math.Sqrt(9.0) != 3.0
        t.Errorf("Expected Sqrt(9.0) = 3.0, got {math.Sqrt(9.0)}")
    if math.Sqrt(0.0) != 0.0
        t.Errorf("Expected Sqrt(0.0) = 0.0, got {math.Sqrt(0.0)}")
    if math.Sqrt(1.0) != 1.0
        t.Errorf("Expected Sqrt(1.0) = 1.0, got {math.Sqrt(1.0)}")
    if math.Sqrt(4.0) != 2.0
        t.Errorf("Expected Sqrt(4.0) = 2.0, got {math.Sqrt(4.0)}")

    # Verify Sqrt(2) is approximately 1.41421
    result := math.Sqrt(2.0)
    if result < 1.41 or result > 1.42
        t.Errorf("Expected Sqrt(2.0) ≈ 1.41421, got {result}")

# Test Log (natural logarithm)
func TestLog(t reference testing.T)
    # Log(1) = 0
    if math.Log(1.0) != 0.0
        t.Errorf("Expected Log(1.0) = 0.0, got {math.Log(1.0)}")

    # Log(E) ≈ 1
    e := math.E()
    result := math.Log(e)
    if result < 0.99 or result > 1.01
        t.Errorf("Expected Log(E) ≈ 1.0, got {result}")

# Test Log2 (base-2 logarithm)
func TestLog2(t reference testing.T)
    if math.Log2(1.0) != 0.0
        t.Errorf("Expected Log2(1.0) = 0.0, got {math.Log2(1.0)}")
    if math.Log2(2.0) != 1.0
        t.Errorf("Expected Log2(2.0) = 1.0, got {math.Log2(2.0)}")
    if math.Log2(8.0) != 3.0
        t.Errorf("Expected Log2(8.0) = 3.0, got {math.Log2(8.0)}")

# Test Log10 (base-10 logarithm)
func TestLog10(t reference testing.T)
    if math.Log10(1.0) != 0.0
        t.Errorf("Expected Log10(1.0) = 0.0, got {math.Log10(1.0)}")
    if math.Log10(10.0) != 1.0
        t.Errorf("Expected Log10(10.0) = 1.0, got {math.Log10(10.0)}")
    if math.Log10(1000.0) != 3.0
        t.Errorf("Expected Log10(1000.0) = 3.0, got {math.Log10(1000.0)}")

# Test Pi and E constants
func TestConstants(t reference testing.T)
    pi := math.Pi()
    if pi < 3.14 or pi > 3.15
        t.Errorf("Expected Pi ≈ 3.14159, got {pi}")

    e := math.E()
    if e < 2.71 or e > 2.72
        t.Errorf("Expected E ≈ 2.71828, got {e}")

    # Pi and E are distinct
    if pi == e
        t.Error("Expected Pi and E to be different constants")

# Test Clamp restricts a value to [min, max]
func TestClamp(t reference testing.T)
    # Value within range is unchanged
    if math.Clamp(5.0, 0.0, 10.0) != 5.0
        t.Errorf("Expected Clamp(5.0, 0.0, 10.0) = 5.0, got {math.Clamp(5.0, 0.0, 10.0)}")

    # Value below min is clamped to min
    if math.Clamp(-5.0, 0.0, 10.0) != 0.0
        t.Errorf("Expected Clamp(-5.0, 0.0, 10.0) = 0.0, got {math.Clamp(-5.0, 0.0, 10.0)}")

    # Value above max is clamped to max
    if math.Clamp(15.0, 0.0, 10.0) != 10.0
        t.Errorf("Expected Clamp(15.0, 0.0, 10.0) = 10.0, got {math.Clamp(15.0, 0.0, 10.0)}")

    # Exact boundary values
    if math.Clamp(0.0, 0.0, 10.0) != 0.0
        t.Errorf("Expected Clamp(0.0, 0.0, 10.0) = 0.0, got {math.Clamp(0.0, 0.0, 10.0)}")
    if math.Clamp(10.0, 0.0, 10.0) != 10.0
        t.Errorf("Expected Clamp(10.0, 0.0, 10.0) = 10.0, got {math.Clamp(10.0, 0.0, 10.0)}")

    # Negative range
    if math.Clamp(0.0, -10.0, -1.0) != -1.0
        t.Errorf("Expected Clamp(0.0, -10.0, -1.0) = -1.0, got {math.Clamp(0.0, -10.0, -1.0)}")
    if math.Clamp(-20.0, -10.0, -1.0) != -10.0
        t.Errorf("Expected Clamp(-20.0, -10.0, -1.0) = -10.0, got {math.Clamp(-20.0, -10.0, -1.0)}")
