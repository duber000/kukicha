# Tests for Kukicha Standard Library - Math Package

petiole math_test

import "stdlib/math"
import "stdlib/test"
import "testing"

# --- FloatCase (single float64 in/out) ---
type FloatCase
    name string
    val  float64
    want float64

# --- FloatPairCase (two inputs, one output) ---
type FloatPairCase
    name string
    a    float64
    b    float64
    want float64

# --- ClampCase ---
type ClampCase
    name string
    val  float64
    lo   float64
    hi   float64
    want float64

# --- TestAbs ---
func TestAbs(t reference testing.T)
    cases := list of FloatCase{
        FloatCase{name: "negative", val: -5.0, want: 5.0},
        FloatCase{name: "positive", val: 5.0, want: 5.0},
        FloatCase{name: "zero", val: 0.0, want: 0.0},
        FloatCase{name: "small negative", val: -0.001, want: 0.001},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := math.Abs(tc.val)
            test.AssertEqual(t, got, tc.want)
        )

# --- TestRound ---
func TestRound(t reference testing.T)
    cases := list of FloatCase{
        FloatCase{name: "round up", val: 3.7, want: 4.0},
        FloatCase{name: "round down", val: 3.2, want: 3.0},
        FloatCase{name: "halfway up", val: 3.5, want: 4.0},
        FloatCase{name: "negative halfway", val: -3.5, want: -4.0},
        FloatCase{name: "zero", val: 0.0, want: 0.0},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := math.Round(tc.val)
            test.AssertEqual(t, got, tc.want)
        )

# --- TestFloor ---
func TestFloor(t reference testing.T)
    cases := list of FloatCase{
        FloatCase{name: "fractional", val: 3.9, want: 3.0},
        FloatCase{name: "whole", val: 3.0, want: 3.0},
        FloatCase{name: "negative fractional", val: -1.1, want: -2.0},
        FloatCase{name: "negative whole", val: -1.0, want: -1.0},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := math.Floor(tc.val)
            test.AssertEqual(t, got, tc.want)
        )

# --- TestCeil ---
func TestCeil(t reference testing.T)
    cases := list of FloatCase{
        FloatCase{name: "fractional", val: 3.1, want: 4.0},
        FloatCase{name: "whole", val: 3.0, want: 3.0},
        FloatCase{name: "negative fractional", val: -1.9, want: -1.0},
        FloatCase{name: "negative whole", val: -1.0, want: -1.0},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := math.Ceil(tc.val)
            test.AssertEqual(t, got, tc.want)
        )

# --- TestSqrt ---
func TestSqrt(t reference testing.T)
    cases := list of FloatCase{
        FloatCase{name: "nine", val: 9.0, want: 3.0},
        FloatCase{name: "zero", val: 0.0, want: 0.0},
        FloatCase{name: "one", val: 1.0, want: 1.0},
        FloatCase{name: "four", val: 4.0, want: 2.0},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := math.Sqrt(tc.val)
            test.AssertEqual(t, got, tc.want)
        )
    # Approximate check for irrational
    t.Run("sqrt 2 approx", (t reference testing.T) =>
        result := math.Sqrt(2.0)
        if result < 1.41 or result > 1.42
            t.Errorf("Expected Sqrt(2.0) ≈ 1.41421, got {result}")
    )

# --- TestMinMax ---
func TestMinMax(t reference testing.T)
    cases := list of FloatPairCase{
        FloatPairCase{name: "min smaller first", a: 3.0, b: 7.0, want: 3.0},
        FloatPairCase{name: "min larger first", a: 7.0, b: 3.0, want: 3.0},
        FloatPairCase{name: "min equal", a: 5.0, b: 5.0, want: 5.0},
    }
    for tc in cases
        t.Run("Min/{tc.name}", (t reference testing.T) =>
            got := math.Min(tc.a, tc.b)
            test.AssertEqual(t, got, tc.want)
        )

    maxCases := list of FloatPairCase{
        FloatPairCase{name: "max smaller first", a: 3.0, b: 7.0, want: 7.0},
        FloatPairCase{name: "max larger first", a: 7.0, b: 3.0, want: 7.0},
        FloatPairCase{name: "max equal", a: 5.0, b: 5.0, want: 5.0},
    }
    for tc in maxCases
        t.Run("Max/{tc.name}", (t reference testing.T) =>
            got := math.Max(tc.a, tc.b)
            test.AssertEqual(t, got, tc.want)
        )

# --- TestPow ---
func TestPow(t reference testing.T)
    cases := list of FloatPairCase{
        FloatPairCase{name: "2^8", a: 2.0, b: 8.0, want: 256.0},
        FloatPairCase{name: "3^3", a: 3.0, b: 3.0, want: 27.0},
        FloatPairCase{name: "5^0", a: 5.0, b: 0.0, want: 1.0},
        FloatPairCase{name: "1^100", a: 1.0, b: 100.0, want: 1.0},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := math.Pow(tc.a, tc.b)
            test.AssertEqual(t, got, tc.want)
        )

# --- TestLog ---
func TestLog(t reference testing.T)
    t.Run("log 1 equals 0", (t reference testing.T) =>
        test.AssertEqual(t, math.Log(1.0), 0.0)
    )
    t.Run("log E approx 1", (t reference testing.T) =>
        e := math.E()
        result := math.Log(e)
        if result < 0.99 or result > 1.01
            t.Errorf("Expected Log(E) ≈ 1.0, got {result}")
    )

# --- TestLog2 ---
func TestLog2(t reference testing.T)
    cases := list of FloatCase{
        FloatCase{name: "log2(1)", val: 1.0, want: 0.0},
        FloatCase{name: "log2(2)", val: 2.0, want: 1.0},
        FloatCase{name: "log2(8)", val: 8.0, want: 3.0},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := math.Log2(tc.val)
            test.AssertEqual(t, got, tc.want)
        )

# --- TestLog10 ---
func TestLog10(t reference testing.T)
    cases := list of FloatCase{
        FloatCase{name: "log10(1)", val: 1.0, want: 0.0},
        FloatCase{name: "log10(10)", val: 10.0, want: 1.0},
        FloatCase{name: "log10(1000)", val: 1000.0, want: 3.0},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := math.Log10(tc.val)
            test.AssertEqual(t, got, tc.want)
        )

# --- TestConstants ---
func TestConstants(t reference testing.T)
    t.Run("Pi approx", (t reference testing.T) =>
        pi := math.Pi()
        if pi < 3.14 or pi > 3.15
            t.Errorf("Expected Pi ≈ 3.14159, got {pi}")
    )
    t.Run("E approx", (t reference testing.T) =>
        e := math.E()
        if e < 2.71 or e > 2.72
            t.Errorf("Expected E ≈ 2.71828, got {e}")
    )
    t.Run("Pi and E distinct", (t reference testing.T) =>
        pi := math.Pi()
        e := math.E()
        if pi == e
            t.Error("Expected Pi and E to be different constants")
    )

# --- TestClamp ---
func TestClamp(t reference testing.T)
    cases := list of ClampCase{
        ClampCase{name: "within range", val: 5.0, lo: 0.0, hi: 10.0, want: 5.0},
        ClampCase{name: "below min", val: -5.0, lo: 0.0, hi: 10.0, want: 0.0},
        ClampCase{name: "above max", val: 15.0, lo: 0.0, hi: 10.0, want: 10.0},
        ClampCase{name: "at lower boundary", val: 0.0, lo: 0.0, hi: 10.0, want: 0.0},
        ClampCase{name: "at upper boundary", val: 10.0, lo: 0.0, hi: 10.0, want: 10.0},
        ClampCase{name: "negative range clamped high", val: 0.0, lo: -10.0, hi: -1.0, want: -1.0},
        ClampCase{name: "negative range clamped low", val: -20.0, lo: -10.0, hi: -1.0, want: -10.0},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := math.Clamp(tc.val, tc.lo, tc.hi)
            test.AssertEqual(t, got, tc.want)
        )
