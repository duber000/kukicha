# Kukicha Standard Library - Shell (Command Execution)

petiole shell

import "os/exec"
import "os"
import "context"
import "time"
import "bytes"

# Command represents a command builder for shell execution
type Command
    name string
    args list of string
    dir string
    timeout int  # seconds, 0 means no timeout
    env map of string to string

# Result represents the result of a shell command execution
type Result
    stdout list of byte
    stderr list of byte
    exitCode int
    err error

# Builder Pattern Functions

# New creates a new Command builder
# Example: cmd := shell.New("git", "status")
func New(name string, many args string) Command
    return Command{name: name, args: args, dir: "", timeout: 0, env: make(map of string to string)}

# Dir sets the working directory for the command
# Example: cmd |> shell.Dir("./myproject")
func Dir(cmd Command, path string) Command
    cmd.dir = path
    return cmd

# Timeout sets the timeout in seconds for the command
# Example: cmd |> shell.Timeout(30)
func SetTimeout(cmd Command, seconds int) Command
    cmd.timeout = seconds
    return cmd

# Env adds an environment variable to the command
# Example: cmd |> shell.Env("DEBUG", "true")
func Env(cmd Command, key string, value string) Command
    cmd.env[key] = value
    return cmd

# Execute runs the command and returns a Result
# Example: result := cmd |> shell.Execute()
func Execute(cmd Command) Result
    # Build the exec.Cmd
    execCmd := buildExecCmd(cmd)

    # Set working directory if specified
    if cmd.dir != ""
        execCmd.Dir = cmd.dir

    # Add environment variables
    if len(cmd.env) > 0
        env := os.Environ()
        for key, value in cmd.env
            env = append(env, "{key}={value}")
        execCmd.Env = env

    # Capture stdout and stderr
    stdoutBuf := bytes.Buffer{}
    stderrBuf := bytes.Buffer{}
    execCmd.Stdout = reference of stdoutBuf
    execCmd.Stderr = reference of stderrBuf

    # Run the command
    err := execCmd.Run()

    # Get exit code
    exitCode := getExitCode(err)

    return Result{stdout: stdoutBuf.Bytes(), stderr: stderrBuf.Bytes(), exitCode: exitCode, err: err}

# buildExecCmd creates an exec.Cmd with optional timeout
func buildExecCmd(cmd Command) reference exec.Cmd
    if cmd.timeout > 0
        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(cmd.timeout) * time.Second)
        defer cancel()
        return exec.CommandContext(ctx, cmd.name, many cmd.args)

    return exec.Command(cmd.name, many cmd.args)

# getExitCode extracts the exit code from an error
func getExitCode(err error) int
    if err == empty
        return 0

    exitErr, ok := err as reference exec.ExitError
    if ok
        return exitErr.ExitCode()

    return 1

# Result Helper Functions

# Success returns true if the command succeeded (exit code 0)
# Example: if shell.Success(result) ...
func Success(result Result) bool
    return result.exitCode == 0 and result.err == empty

# Output returns the stdout as bytes
# Example: output := shell.Output(result)
func GetOutput(result Result) list of byte
    return result.stdout

# Error returns the stderr as bytes
# Example: errorOutput := shell.Error(result)
func GetError(result Result) list of byte
    return result.stderr

# ExitCode returns the exit code
# Example: code := shell.ExitCode(result)
func ExitCode(result Result) int
    return result.exitCode

# Direct Execution Functions (legacy, use builder pattern instead)

# Run executes a command with arguments and returns the output as bytes
# Returns stdout and error
# Example: shell.Run("ls", "-la", "/tmp")
func Run(name string, many args string) (list of byte, error)
    cmd := exec.Command(name, many args)
    output, err := cmd.Output()
    if err != empty
        return empty, err
    return output, err

# RunSimple executes a command with no arguments
# Returns stdout as bytes and error
# Example: shell.RunSimple("pwd")
func RunSimple(name string) (list of byte, error)
    cmd := exec.Command(name)
    output, err := cmd.Output()
    if err != empty
        return empty, err
    return output, err

# RunWithDir executes a command in a specific directory
# Returns stdout as bytes and error
# Example: shell.RunWithDir("ls", "/tmp", "-la")
func RunWithDir(name string, dir string, many args string) (list of byte, error)
    cmd := exec.Command(name, many args)
    cmd.Dir = dir
    output, err := cmd.Output()
    if err != empty
        return empty, err
    return output, err

# RunWithOutput - simplified stub due to buffer assignment limitations
# Use Go interop for capturing both stdout and stderr
func RunWithOutput(name string, arg1 string) (list of byte, list of byte, error)
    return empty, empty, error "use Go interop - buffer assignment requires pointers"

# RunWithTimeout executes a command with a timeout
# Example: shell.RunWithTimeout("sleep", 2, "10")
func RunWithTimeout(name string, timeoutSeconds int, arg1 string) (list of byte, error)
    # 1. Creation Phase: Standard tuple assignment (Kukicha supports this!)
    # We must do this to capture 'cancel' for the defer
    ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeoutSeconds) * time.Second)
    defer cancel()

    # 2. Execution Phase: Level 2 Smart Pipe
    # The compiler injects 'ctx' into exec.CommandContext(ctx, ...) automatically
    output := ctx |> exec.CommandContext(name, arg1) |> .Output() onerr return empty, error "command failed"
    
    return output, empty

# Which checks if a command exists in the system PATH
# Returns true if the command is found, false otherwise
# Example: if shell.Which("git") ...
func Which(name string) bool
    _, err := exec.LookPath(name)
    return err == empty

# Output runs a command and returns just the output as bytes
# Returns empty on error
# Example: output := shell.Output("echo", "hello")
func Output(name string, arg1 string) list of byte
    cmd := exec.Command(name, arg1)
    output, err := cmd.Output()
    if err != empty
        return empty
    return output

# CombinedOutput runs a command and returns combined stdout and stderr as bytes
# Note: Returns output even on error (combined stdout+stderr)
# Example: output := shell.CombinedOutput("ls", "/nonexistent")
func CombinedOutput(name string, arg1 string) (list of byte, error)
    cmd := exec.Command(name, arg1)
    output, err := cmd.CombinedOutput()
    return output, err

# IsSuccessful runs a command and returns true if it succeeds
# Example: if shell.IsSuccessful("git", "status") ...
# Note: Use builder pattern instead: shell.New("git", "status") |> shell.Execute() |> shell.Success()
func IsSuccessful(name string, many args string) bool
    cmd := exec.Command(name, many args)
    err := cmd.Run()
    return err == empty

# Getenv returns the value of an environment variable
# Example: home := shell.Getenv("HOME")
func Getenv(key string) string
    return os.Getenv(key)

# Setenv sets the value of an environment variable
# Example: shell.Setenv("DEBUG", "true")
func Setenv(key string, value string) error
    return os.Setenv(key, value)

# Unsetenv removes an environment variable
# Example: shell.Unsetenv("DEBUG")
func Unsetenv(key string) error
    return os.Unsetenv(key)

# Environ returns all environment variables as a list of strings
# Each string is in the form "key=value"
# Example: envs := shell.Environ()
func Environ() list of string
    return os.Environ()
