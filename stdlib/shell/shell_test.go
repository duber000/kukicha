// Generated by Kukicha v1.0.0 (requires Go 1.26+)
//
// Performance: GOEXPERIMENT=jsonv2 enables faster JSON parsing (2-10x improvement)

package shell_test

import (
	"fmt"
	"github.com/duber000/kukicha/stdlib/shell"
	kukistring "github.com/duber000/kukicha/stdlib/string"
	"testing"
)

func TestExecute(t *testing.T) {
	cmd := shell.New("echo", "hello world")
	result := shell.Execute(cmd)
	if !shell.Success(result) {
		errStr := string(shell.GetError(result))
		t.Errorf("shell.Execute failed: %v", errStr)
	}
	output := string(shell.GetOutput(result))
	expected := "hello world\n"
	if output != expected {
		t.Error("Expected 'hello world\\n', got different output")
	}
}

func TestExecuteWithDir(t *testing.T) {
	cmd := shell.Dir(shell.New("pwd"), "/tmp")
	result := shell.Execute(cmd)
	if !shell.Success(result) {
		errStr := string(shell.GetError(result))
		t.Errorf("shell.Execute with Dir failed: %v", errStr)
	}
	output := string(shell.GetOutput(result))
	if !kukistring.Contains(output, "tmp") {
		t.Error("Expected output to contain 'tmp'")
	}
}

func TestExecuteWithEnv(t *testing.T) {
	cmd := shell.Env(shell.New("sh", "-c", "echo $TEST_VAR"), "TEST_VAR", "hello")
	result := shell.Execute(cmd)
	if !shell.Success(result) {
		errStr := string(shell.GetError(result))
		t.Errorf("shell.Execute with Env failed: %v", errStr)
	}
	output := string(shell.GetOutput(result))
	if !kukistring.Contains(output, "hello") {
		t.Error("Expected output to contain 'hello'")
	}
}

func TestExecuteFailed(t *testing.T) {
	cmd := shell.New("false")
	result := shell.Execute(cmd)
	if shell.Success(result) {
		t.Error("Expected 'false' command to fail")
	}
	exitCode := shell.ExitCode(result)
	if exitCode == 0 {
		t.Errorf("Expected non-zero exit code, got %v", exitCode)
	}
}

func TestWhich(t *testing.T) {
	if !shell.Which("ls") {
		t.Error("Expected 'ls' to be found")
	}
	if shell.Which("nonexistent-command-xyz") {
		t.Error("Did not expect to find nonexistent-command-xyz")
	}
}

func TestEnv(t *testing.T) {
	key := "KUKICHA_TEST_VAR"
	val := "test_value"
	err := shell.Setenv(key, val)
	if err != nil {
		t.Fatalf("Setenv failed: %v", err)
	}
	got := shell.Getenv(key)
	if got != val {
		t.Errorf("Expected %v, got %v", val, got)
	}
	found := false
	envs := shell.Environ()
	for _, e := range envs {
		if e == fmt.Sprintf("%v=%v", key, val) {
			found = true
			break
		}
	}
	if !found {
		t.Error("Expected to find variable in Environ()")
	}
	shell.Unsetenv(key)
	if shell.Getenv(key) != "" {
		t.Error("Expected variable to be unset")
	}
}
