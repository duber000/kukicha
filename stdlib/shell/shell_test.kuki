# Shell Package Tests

petiole shell_test

import "stdlib/shell"
import "stdlib/test"
import "stdlib/string"
import "testing"

# --- TestExecute ---
type ExecuteCase
    name string

func TestExecute(t reference testing.T)
    cases := list of ExecuteCase{
        ExecuteCase{name: "basic"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            cmd := shell.New("echo", "hello world")
            result := shell.Execute(cmd)

            test.AssertTrue(t, shell.Success(result))

            output := shell.GetOutput(result) as string
            expected := "hello world\n"
            test.AssertEqual(t, output, expected)
        )

# --- TestExecuteWithDir ---
type ExecuteWithDirCase
    name string

func TestExecuteWithDir(t reference testing.T)
    cases := list of ExecuteWithDirCase{
        ExecuteWithDirCase{name: "with dir"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            cmd := shell.New("pwd") |> shell.Dir("/tmp")
            result := shell.Execute(cmd)

            test.AssertTrue(t, shell.Success(result))

            output := shell.GetOutput(result) as string
            test.AssertTrue(t, string.Contains(output, "tmp"))
        )

# --- TestExecuteWithEnv ---
type ExecuteWithEnvCase
    name string

func TestExecuteWithEnv(t reference testing.T)
    cases := list of ExecuteWithEnvCase{
        ExecuteWithEnvCase{name: "with env"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            cmd := shell.New("sh", "-c", "echo $TEST_VAR") |> shell.Env("TEST_VAR", "hello")
            result := shell.Execute(cmd)

            test.AssertTrue(t, shell.Success(result))

            output := shell.GetOutput(result) as string
            test.AssertTrue(t, string.Contains(output, "hello"))
        )

# --- TestExecuteFailed ---
type ExecuteFailedCase
    name string

func TestExecuteFailed(t reference testing.T)
    cases := list of ExecuteFailedCase{
        ExecuteFailedCase{name: "failed"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            cmd := shell.New("false")
            result := shell.Execute(cmd)

            test.AssertFalse(t, shell.Success(result))

            exitCode := shell.ExitCode(result)
            if exitCode == 0
                t.Errorf("Expected non-zero exit code, got {exitCode}")
        )

# --- TestWhich ---
type WhichCase
    name string

func TestWhich(t reference testing.T)
    cases := list of WhichCase{
        WhichCase{name: "which"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            test.AssertTrue(t, shell.Which("ls"))
            test.AssertFalse(t, shell.Which("nonexistent-command-xyz"))
        )

# --- TestEnv ---
type EnvCase
    name string

func TestEnv(t reference testing.T)
    cases := list of EnvCase{
        EnvCase{name: "env operations"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            key := "KUKICHA_TEST_VAR"
            val := "test_value"

            err := shell.Setenv(key, val)
            test.AssertNoError(t, err)

            got := shell.Getenv(key)
            test.AssertEqual(t, got, val)

            found := false
            envs := shell.Environ()
            for e in envs
                if e == "{key}={val}"
                    found = true
                    break

            test.AssertTrue(t, found)

            shell.Unsetenv(key)
            test.AssertEqual(t, shell.Getenv(key), "")
        )
