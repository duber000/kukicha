# Shell Package Tests

petiole shell_test

import "stdlib/shell"
import "testing"
import "os"

# Test Run
func TestRun(t reference testing.T)
    output, err := shell.Run("echo", "hello world")
    if err != empty
        t.Errorf("shell.Run failed: {err}")
    
    expected := "hello world\n"
    if (output as string) != expected
        t.Errorf("Expected '{expected}', got '{output as string}'")

# Test RunSimple
func TestRunSimple(t reference testing.T)
    # We can use a command that is likely to exist and produce output
    # 'whoami' or 'hostname' are generally safe
    output, err := shell.RunSimple("echo")
    if err != empty
        t.Errorf("shell.RunSimple failed: {err}")
    
    if len(output) == 0
        t.Error("Expected some output from echo")

# Test Which
func TestWhich(t reference testing.T)
    if not shell.Which("ls")
        t.Error("Expected 'ls' to be found")
    
    if shell.Which("nonexistent-command-xyz")
        t.Error("Did not expect to find nonexistent-command-xyz")

# Test Success
func TestSuccess(t reference testing.T)
    if not shell.Success("true")
        t.Error("Expected 'true' command to succeed")
    
    if shell.Success("false")
        t.Error("Expected 'false' command to fail")

# Test Environment 
func TestEnv(t reference testing.T)
    key := "KUKICHA_TEST_VAR"
    val := "test_value"
    
    err := shell.Setenv(key, val)
    if err != empty
        t.Fatalf("Setenv failed: {err}")
    
    got := shell.Getenv(key)
    if got != val
        t.Errorf("Expected {val}, got {got}")
    
    found := false
    envs := shell.Environ()
    for e in envs
        if e == "{key}={val}"
            found = true
            break
    
    if not found
        t.Error("Expected to find variable in Environ()")
    
    shell.Unsetenv(key)
    if shell.Getenv(key) != ""
        t.Error("Expected variable to be unset")
