// Generated by Kukicha v0.0.1 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package shell

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"time"
)

type Command struct {
	name    string
	args    []string
	dir     string
	timeout int
	env     map[string]string
}

type Result struct {
	stdout   []byte
	stderr   []byte
	exitCode int
	err      error
}

func Output(name string, args ...string) (string, error) {
	cmd := New(name, args...)
	result := Execute(cmd)
	if !Success(result) {
		errStr := string(GetError(result))
		return "", errors.New(fmt.Sprintf("%v", errStr))
	}
	return string(GetOutput(result)), nil
}

func New(name string, args ...string) Command {
	return Command{name: name, args: args, dir: "", timeout: 0, env: make(map[string]string)}
}

func Dir(cmd Command, path string) Command {
	cmd.dir = path
	return cmd
}

func SetTimeout(cmd Command, seconds int) Command {
	cmd.timeout = seconds
	return cmd
}

func Env(cmd Command, key string, value string) Command {
	cmd.env[key] = value
	return cmd
}

func Execute(cmd Command) Result {
	execCmd := buildExecCmd(cmd)
	if cmd.dir != "" {
		execCmd.Dir = cmd.dir
	}
	if len(cmd.env) > 0 {
		env := os.Environ()
		for key, value := range cmd.env {
			env = append(env, fmt.Sprintf("%v=%v", key, value))
		}
		execCmd.Env = env
	}
	stdoutBuf := bytes.Buffer{}
	stderrBuf := bytes.Buffer{}
	execCmd.Stdout = &stdoutBuf
	execCmd.Stderr = &stderrBuf
	err := execCmd.Run()
	exitCode := getExitCode(err)
	return Result{stdout: stdoutBuf.Bytes(), stderr: stderrBuf.Bytes(), exitCode: exitCode, err: err}
}

func buildExecCmd(cmd Command) *exec.Cmd {
	if cmd.timeout > 0 {
		ctx, cancel := context.WithTimeout(context.Background(), (time.Duration(cmd.timeout) * time.Second))
		defer cancel()
		return exec.CommandContext(ctx, cmd.name, cmd.args...)
	}
	return exec.Command(cmd.name, cmd.args...)
}

func getExitCode(err error) int {
	if err == nil {
		return 0
	}
	exitErr, ok := err.(*exec.ExitError)
	if ok {
		return exitErr.ExitCode()
	}
	return 1
}

func Success(result Result) bool {
	return ((result.exitCode == 0) && (result.err == nil))
}

func GetOutput(result Result) []byte {
	return result.stdout
}

func GetError(result Result) []byte {
	return result.stderr
}

func ExitCode(result Result) int {
	return result.exitCode
}

func Which(name string) bool {
	_, err := exec.LookPath(name)
	return (err == nil)
}

func Getenv(key string) string {
	return os.Getenv(key)
}

func Setenv(key string, value string) error {
	return os.Setenv(key, value)
}

func Unsetenv(key string) error {
	return os.Unsetenv(key)
}

func Environ() []string {
	return os.Environ()
}
