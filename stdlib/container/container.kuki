# Kukicha Standard Library - Container (Docker/Podman Client)
# Provides a pipe-friendly wrapper around the Docker SDK with Podman auto-detection.
#
# Examples:
#   # Simple connection (auto-detects Docker or Podman socket)
#   engine := container.Connect() onerr panic "not running: {error}"
#   defer container.Close(engine)
#
#   # Builder pattern
#   engine := container.New()
#       |> container.Host("unix:///var/run/docker.sock")
#       |> container.Open()
#       onerr panic "{error}"
#
#   # List images
#   images := engine |> container.ListImages() onerr panic "{error}"
#   for img in images
#       print("{container.ImageID(img)}: {container.ImageTags(img)}")

petiole container

import "bufio"
import "bytes"
import "fmt"
import "io"
import "os"
import "path/filepath"
import "time"
import "stdlib/ctx" as ctxpkg
import "stdlib/errors"
import "stdlib/json"
import "stdlib/string"
import "encoding/base64"
import "github.com/docker/docker/client"
import "github.com/docker/docker/api/types" as dockertypes
import "github.com/docker/docker/api/types/container" as dockercontainer
import "github.com/docker/docker/api/types/image" as dockerimage
import "github.com/docker/docker/api/types/events" as dockerevents
import "github.com/docker/docker/pkg/stdcopy"

# Engine wraps a Docker/Podman client connection
type Engine
    cli reference client.Client

# Config is a builder for connection options
type Config
    host string
    apiVersion string

# ContainerInfo holds information about a container
type ContainerInfo
    id string
    image string
    status string
    state string
    names list of string

# ImageInfo holds information about an image
type ImageInfo
    id string
    tags list of string
    size int64

# BuildOutput holds the result of an image build
type BuildOutput
    imageID string
    output string

# Auth holds registry authentication credentials
type Auth
    username string
    password string
    serverAddress string

# pullStatusMsg is used for JSON decode of Docker pull progress messages.
type pullStatusMsg
    Status string json:"status"
    ID string json:"id"

# buildStreamMsg is used for JSON decode of Docker build progress messages.
type buildStreamMsg
    Stream string json:"stream"
    Aux buildStreamAux json:"aux"
    Error string json:"error"

# buildStreamAux holds the image ID returned in build stream aux messages.
type buildStreamAux
    ID string json:"ID"

# dockerAuthEntry represents a single registry auth entry from Docker config.
type dockerAuthEntry
    Auth string json:"auth"

# dockerConfig represents the structure of ~/.docker/config.json.
type dockerConfig
    Auths map of string to dockerAuthEntry json:"auths"

# ContainerEvent represents a container runtime event.
type ContainerEvent
    id string
    resource string
    action string
    actor string
    time string

# New starts a configuration builder.
func New() Config
    return Config{}

# Host sets the Docker host URL on the config builder.
func Host(cfg Config, host string) Config
    cfg.host = host
    return cfg

# APIVersion sets an explicit API version on the config builder.
func APIVersion(cfg Config, version string) Config
    cfg.apiVersion = version
    return cfg

# Close closes the Docker client connection.
func Close(engine Engine) error
    return engine.cli.Close()

# ListContainers lists all containers (including stopped).
func ListContainers(engine Engine) (list of ContainerInfo, error)
    bg := ctxpkg.Background()
    containers, err := engine.cli.ContainerList(ctxpkg.Value(bg), dockercontainer.ListOptions{All: true})
    if err != empty
        return empty, errors.Wrap(err, "container list")
    result := make(list of ContainerInfo, len(containers))
    for i, c in containers
        result[i] = ContainerInfo{
            id: c.ID,
            image: c.Image,
            status: c.Status,
            state: c.State,
            names: c.Names,
        }
    return result, empty

# ListImages lists all images on the host.
func ListImages(engine Engine) (list of ImageInfo, error)
    bg := ctxpkg.Background()
    images, err := engine.cli.ImageList(ctxpkg.Value(bg), dockerimage.ListOptions{All: true})
    if err != empty
        return empty, errors.Wrap(err, "container list images")
    result := make(list of ImageInfo, len(images))
    for i, img in images
        result[i] = ImageInfo{
            id: img.ID,
            tags: img.RepoTags,
            size: img.Size,
        }
    return result, empty

# Stop stops a running container.
func Stop(engine Engine, containerID string) error
    bg := ctxpkg.Background()
    err := engine.cli.ContainerStop(ctxpkg.Value(bg), containerID, dockercontainer.StopOptions{})
    if err != empty
        return errors.Wrap(err, "container stop")
    return empty

# Remove removes a container.
func Remove(engine Engine, containerID string) error
    bg := ctxpkg.Background()
    err := engine.cli.ContainerRemove(ctxpkg.Value(bg), containerID, dockercontainer.RemoveOptions{})
    if err != empty
        return errors.Wrap(err, "container remove")
    return empty

# Login creates an Auth with the given credentials.
func Login(username string, password string, server string) Auth
    return Auth{username: username, password: password, serverAddress: server}

# AuthEncode encodes auth credentials as a base64 JSON string for Docker registry headers.
func AuthEncode(auth Auth) string
    authJSON, _ := json.Marshal(map of string to string{
        "username": auth.username,
        "password": auth.password,
        "serveraddress": auth.serverAddress,
    })
    return base64.URLEncoding.EncodeToString(authJSON)

# ContainerID returns the container's ID.
func ContainerID(c ContainerInfo) string
    return c.id

# ContainerImage returns the container's image name.
func ContainerImage(c ContainerInfo) string
    return c.image

# ContainerStatus returns the container's status string.
func ContainerStatus(c ContainerInfo) string
    return c.status

# ContainerState returns the container's state (running, exited, etc.).
func ContainerState(c ContainerInfo) string
    return c.state

# ContainerNames returns the container's names.
func ContainerNames(c ContainerInfo) list of string
    return c.names

# ImageID returns the image's ID.
func ImageID(img ImageInfo) string
    return img.id

# ImageTags returns the image's tags.
func ImageTags(img ImageInfo) list of string
    return img.tags

# ImageSize returns the image's size in bytes.
func ImageSize(img ImageInfo) int64
    return img.size

# BuildImageID returns the image ID from a build result.
func BuildImageID(b BuildOutput) string
    return b.imageID

# BuildLog returns the build output log.
func BuildLog(b BuildOutput) string
    return b.output

# EventID returns the container ID for the event.
func EventID(event ContainerEvent) string
    return event.id

# EventResource returns the resource type (container, image, network, etc).
func EventResource(event ContainerEvent) string
    return event.resource

# EventAction returns the event action (start, stop, die, pull, etc).
func EventAction(event ContainerEvent) string
    return event.action

# EventActor returns the actor name for the event, when available.
func EventActor(event ContainerEvent) string
    return event.actor

# EventTime returns the RFC3339 timestamp for the event.
func EventTime(event ContainerEvent) string
    return event.time

# --- Functions migrated from container_helper.go ---

# containerLogs retrieves logs using stdcopy.StdCopy to demux stdout/stderr.
# The tail parameter controls how many lines to return ("" for all, or a number string).
func containerLogs(cli reference client.Client, containerID string, tail string) (string, error)
    bg := ctxpkg.Background()
    opts := dockercontainer.LogsOptions{ShowStdout: true, ShowStderr: true}
    if tail != ""
        opts.Tail = tail
    reader, err := cli.ContainerLogs(ctxpkg.Value(bg), containerID, opts)
    if err != empty
        return "", errors.Wrap(err, "container logs")
    defer reader.Close()
    stdout := bytes.Buffer{}
    stderr := bytes.Buffer{}
    _, copyErr := stdcopy.StdCopy(reference of stdout, reference of stderr, reader)
    if copyErr != empty
        raw, readErr := io.ReadAll(reader)
        if readErr != empty
            return "", errors.Wrap(copyErr, "container logs")
        return raw as string, empty
    combined := stdout.String()
    if stderr.Len() > 0
        combined = combined + stderr.String()
    return combined, empty

# Logs retrieves all logs from a container.
func Logs(engine Engine, containerID string) (string, error)
    return containerLogs(engine.cli, containerID, "")

# LogsTail retrieves the last N lines of logs from a container.
func LogsTail(engine Engine, containerID string, lines int64) (string, error)
    return containerLogs(engine.cli, containerID, fmt.Sprintf("%d", lines))

# Run creates and starts a container. Returns the container ID.
func Run(engine Engine, img string, cmd list of string) (string, error)
    bg := ctxpkg.Background()
    resp, err := engine.cli.ContainerCreate(ctxpkg.Value(bg), reference of dockercontainer.Config{
        Image: img,
        Cmd: cmd,
    }, empty, empty, empty, "")
    if err != empty
        return "", errors.Wrap(err, "container run create")
    startErr := engine.cli.ContainerStart(ctxpkg.Value(bg), resp.ID, dockercontainer.StartOptions{})
    if startErr != empty
        return "", errors.Wrap(startErr, "container run start")
    return resp.ID, empty

# Inspect returns high-level container metadata.
func Inspect(engine Engine, containerID string) (ContainerInfo, error)
    bg := ctxpkg.Background()
    info, err := engine.cli.ContainerInspect(ctxpkg.Value(bg), containerID)
    if err != empty
        return ContainerInfo{}, errors.Wrap(err, "container inspect")
    names := make(list of string, 0)
    if info.Name != ""
        names = append(names, string.TrimPrefix(info.Name, "/"))
    status := ""
    state := ""
    if info.State != empty
        status = info.State.Status
        state = info.State.Status
    return ContainerInfo{
        id: info.ID,
        image: info.Config.Image,
        status: status,
        state: state,
        names: names,
    }, empty

# Exec runs a command in an existing container and returns combined stdout/stderr.
# An optional ctx.Handle can be passed for cancellation support.
func Exec(engine Engine, containerID string, cmd list of string, many handles ctxpkg.Handle) (string, error)
    ctx := ctxpkg.Background()
    if len(handles) > 0
        ctx = handles[0]
    createResp, err := engine.cli.ContainerExecCreate(ctxpkg.Value(ctx), containerID, dockertypes.ExecConfig{
        Cmd: cmd,
        AttachStdout: true,
        AttachStderr: true,
    })
    if err != empty
        return "", errors.Wrap(err, "container exec create")
    attachResp, attachErr := engine.cli.ContainerExecAttach(ctxpkg.Value(ctx), createResp.ID, dockertypes.ExecStartCheck{})
    if attachErr != empty
        return "", errors.Wrap(attachErr, "container exec attach")
    defer attachResp.Close()
    stdout := bytes.Buffer{}
    stderr := bytes.Buffer{}
    _, copyErr := stdcopy.StdCopy(reference of stdout, reference of stderr, attachResp.Reader)
    if copyErr != empty
        raw, readErr := io.ReadAll(attachResp.Reader)
        if readErr != empty
            return "", errors.Wrap(copyErr, "container exec read")
        return raw as string, empty
    inspectResult, inspectErr := engine.cli.ContainerExecInspect(ctxpkg.Value(ctx), createResp.ID)
    if inspectErr != empty
        return "", errors.Wrap(inspectErr, "container exec inspect")
    combined := stdout.String()
    if stderr.Len() > 0
        combined = combined + stderr.String()
    if inspectResult.ExitCode != 0
        return combined, error "container exec exit {inspectResult.ExitCode}"
    return combined, empty

# --- Wait ---

# Wait blocks until a container exits and returns its exit code.
# timeoutSeconds <= 0 waits indefinitely.
func Wait(engine Engine, containerID string, timeoutSeconds int64) (int64, error)
    h := ctxpkg.Background()
    if timeoutSeconds > 0
        h = h |> ctxpkg.WithTimeout(timeoutSeconds)
    defer ctxpkg.Cancel(h)
    goCtx := ctxpkg.Value(h)
    waitCh, errCh := engine.cli.ContainerWait(goCtx, containerID, dockercontainer.WaitConditionNotRunning)
    select
        when err := receive from errCh
            if err != empty
                return -1, fmt.Errorf("container wait: %w", err)
            return -1, error "container wait: unknown wait error"
        when res := receive from waitCh
            return res.StatusCode, empty

# WaitCtx blocks until a container exits or the provided context is canceled.
func WaitCtx(engine Engine, h ctxpkg.Handle, containerID string) (int64, error)
    goCtx := ctxpkg.Value(h)
    waitCh, errCh := engine.cli.ContainerWait(goCtx, containerID, dockercontainer.WaitConditionNotRunning)
    select
        when err := receive from errCh
            if err != empty
                return -1, fmt.Errorf("container wait: %w", err)
            return -1, error "container wait: unknown wait error"
        when res := receive from waitCh
            return res.StatusCode, empty

# --- Events ---

# convertEvent converts a Docker events.Message to a ContainerEvent.
func convertEvent(msg dockerevents.Message) ContainerEvent
    ts := time.Unix(msg.Time, 0).UTC().Format(time.RFC3339)
    actor := msg.Actor.ID
    name, ok := msg.Actor.Attributes["name"]
    if ok and name != ""
        actor = name
    return ContainerEvent{
        id: msg.ID,
        resource: msg.Type as string,
        action: msg.Action as string,
        actor: actor,
        time: ts,
    }

# eventsWithContext collects runtime events until the context is canceled.
func eventsWithContext(engine Engine, h ctxpkg.Handle) (list of ContainerEvent, error)
    goCtx := ctxpkg.Value(h)
    msgCh, errCh := engine.cli.Events(goCtx, dockertypes.EventsOptions{})
    events := make(list of ContainerEvent, 0)
    for
        select
            when receive from goCtx.Done()
                return events, empty
            when err := receive from errCh
                if err == empty or goCtx.Err() != empty
                    return events, empty
                return events, fmt.Errorf("container events: %w", err)
            when msg, ok := receive from msgCh
                if not ok
                    return events, empty
                events = append(events, convertEvent(msg))
    return events, empty

# Events collects runtime events for a bounded duration.
# timeoutSeconds <= 0 defaults to 15 seconds.
func Events(engine Engine, timeoutSeconds int64) (list of ContainerEvent, error)
    if timeoutSeconds <= 0
        timeoutSeconds = 15
    h := ctxpkg.Background() |> ctxpkg.WithTimeout(timeoutSeconds)
    defer ctxpkg.Cancel(h)
    return eventsWithContext(engine, h)

# EventsCtx collects runtime events until the provided context is canceled.
func EventsCtx(engine Engine, h ctxpkg.Handle) (list of ContainerEvent, error)
    return eventsWithContext(engine, h)

# --- Functions migrated from container_helper.go (anonymous struct workaround) ---

# Pull pulls an image from a registry. Returns the image digest.
# An optional ctx.Handle can be passed for cancellation support.
func Pull(engine Engine, ref string, many handles ctxpkg.Handle) (string, error)
    bg := ctxpkg.Background()
    if len(handles) > 0
        bg = handles[0]
    reader, err := engine.cli.ImagePull(ctxpkg.Value(bg), ref, dockerimage.PullOptions{})
    if err != empty
        return "", fmt.Errorf("container pull: %w", err)
    defer reader.Close()
    digest := ""
    scanner := bufio.NewScanner(reader)
    for scanner.Scan()
        msg := pullStatusMsg{}
        unmarshalErr := json.Unmarshal(scanner.Bytes(), reference of msg)
        if unmarshalErr == empty
            if string.HasPrefix(msg.Status, "Digest:")
                digest = string.TrimPrefix(msg.Status, "Digest: ")
    if digest == ""
        digest = ref
    return digest, empty

# PullAuth pulls an image using registry credentials.
func PullAuth(engine Engine, ref string, auth Auth) (string, error)
    authJSON, jsonErr := json.Marshal(map of string to string{
        "username": auth.username,
        "password": auth.password,
        "serveraddress": auth.serverAddress,
    })
    if jsonErr != empty
        return "", fmt.Errorf("container pull auth: %w", jsonErr)
    encoded := base64.URLEncoding.EncodeToString(authJSON)
    reader, err := engine.cli.ImagePull(ctxpkg.Value(ctxpkg.Background()), ref, dockerimage.PullOptions{
        RegistryAuth: encoded,
    })
    if err != empty
        return "", fmt.Errorf("container pull: %w", err)
    defer reader.Close()
    digest := ""
    scanner := bufio.NewScanner(reader)
    for scanner.Scan()
        msg := pullStatusMsg{}
        unmarshalErr := json.Unmarshal(scanner.Bytes(), reference of msg)
        if unmarshalErr == empty
            if string.HasPrefix(msg.Status, "Digest:")
                digest = string.TrimPrefix(msg.Status, "Digest: ")
    if digest == ""
        digest = ref
    return digest, empty

# loadDockerAuth reads ~/.docker/config.json and resolves credentials
# for the given registry server address.
# Returns (username, password, serverAddress, error).
func loadDockerAuth(serverAddress string) (string, string, string, error)
    home, homeErr := os.UserHomeDir()
    if homeErr != empty
        return "", "", "", fmt.Errorf("container auth: %w", homeErr)
    configPath := filepath.Join(home, ".docker", "config.json")
    data, readErr := os.ReadFile(configPath)
    if readErr != empty
        return "", "", "", fmt.Errorf("container auth: %w", readErr)
    config := dockerConfig{}
    unmarshalErr := json.Unmarshal(data, reference of config)
    if unmarshalErr != empty
        return "", "", "", fmt.Errorf("container auth parse: %w", unmarshalErr)
    authEntry, ok := config.Auths[serverAddress]
    if not ok
        variations := list of string{
            "https://" + serverAddress,
            "http://" + serverAddress,
            string.TrimPrefix(serverAddress, "https://"),
            string.TrimPrefix(serverAddress, "http://"),
        }
        for v in variations
            a, found := config.Auths[v]
            if found
                authEntry = a
                ok = true
                break
    if not ok
        return "", "", "", fmt.Errorf("container auth: no credentials found for %s", serverAddress)
    if authEntry.Auth == ""
        return "", "", "", fmt.Errorf("container auth: empty credentials for %s", serverAddress)
    decoded, decodeErr := base64.StdEncoding.DecodeString(authEntry.Auth)
    if decodeErr != empty
        return "", "", "", fmt.Errorf("container auth decode: %w", decodeErr)
    parts := string.SplitN(decoded as string, ":", 2)
    if len(parts) != 2
        return "", "", "", fmt.Errorf("container auth: invalid credential format for %s", serverAddress)
    return parts[0], parts[1], serverAddress, empty

# LoginFromConfig loads registry credentials from ~/.docker/config.json.
func LoginFromConfig(server string) (Auth, error)
    username, password, addr, err := loadDockerAuth(server)
    if err != empty
        return Auth{}, err
    return Auth{username: username, password: password, serverAddress: addr}, empty
