// Generated by Kukicha v0.0.5 (requires Go 1.26+)
//
// Performance: GOEXPERIMENT=jsonv2 enables faster JSON parsing (2-10x improvement)

package container

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	dockertypes "github.com/docker/docker/api/types"
	dockercontainer "github.com/docker/docker/api/types/container"
	dockerevents "github.com/docker/docker/api/types/events"
	dockerimage "github.com/docker/docker/api/types/image"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/stdcopy"
	ctxpkg "github.com/duber000/kukicha/stdlib/ctx"
	kukierrors "github.com/duber000/kukicha/stdlib/errors"
	"github.com/duber000/kukicha/stdlib/json"
	kukistring "github.com/duber000/kukicha/stdlib/string"
	"io"
	"os"
	"path/filepath"
	"time"
)

//line /home/user/kukicha/stdlib/container/container.kuki:42
type Engine struct {
	cli *client.Client
}

//line /home/user/kukicha/stdlib/container/container.kuki:46
type Config struct {
	host       string
	apiVersion string
}

//line /home/user/kukicha/stdlib/container/container.kuki:51
type ContainerInfo struct {
	id     string
	image  string
	status string
	state  string
	names  []string
}

//line /home/user/kukicha/stdlib/container/container.kuki:59
type ImageInfo struct {
	id   string
	tags []string
	size int64
}

//line /home/user/kukicha/stdlib/container/container.kuki:65
type BuildOutput struct {
	imageID string
	output  string
}

//line /home/user/kukicha/stdlib/container/container.kuki:70
type Auth struct {
	username      string
	password      string
	serverAddress string
}

//line /home/user/kukicha/stdlib/container/container.kuki:76
type pullStatusMsg struct {
	Status string `json:"status"`
	ID     string `json:"id"`
}

//line /home/user/kukicha/stdlib/container/container.kuki:81
type buildStreamMsg struct {
	Stream string         `json:"stream"`
	Aux    buildStreamAux `json:"aux"`
	Error  string         `json:"error"`
}

//line /home/user/kukicha/stdlib/container/container.kuki:87
type buildStreamAux struct {
	ID string `json:"ID"`
}

//line /home/user/kukicha/stdlib/container/container.kuki:91
type dockerAuthEntry struct {
	Auth string `json:"auth"`
}

//line /home/user/kukicha/stdlib/container/container.kuki:95
type dockerConfig struct {
	Auths map[string]dockerAuthEntry `json:"auths"`
}

//line /home/user/kukicha/stdlib/container/container.kuki:99
type ContainerEvent struct {
	id       string
	resource string
	action   string
	actor    string
	time     string
}

//line /home/user/kukicha/stdlib/container/container.kuki:107
func New() Config {
//line /home/user/kukicha/stdlib/container/container.kuki:108
	return Config{}
}

//line /home/user/kukicha/stdlib/container/container.kuki:111
func Host(cfg Config, host string) Config {
//line /home/user/kukicha/stdlib/container/container.kuki:112
	cfg.host = host
//line /home/user/kukicha/stdlib/container/container.kuki:113
	return cfg
}

//line /home/user/kukicha/stdlib/container/container.kuki:116
func APIVersion(cfg Config, version string) Config {
//line /home/user/kukicha/stdlib/container/container.kuki:117
	cfg.apiVersion = version
//line /home/user/kukicha/stdlib/container/container.kuki:118
	return cfg
}

//line /home/user/kukicha/stdlib/container/container.kuki:121
func Close(engine Engine) error {
//line /home/user/kukicha/stdlib/container/container.kuki:122
	return engine.cli.Close()
}

//line /home/user/kukicha/stdlib/container/container.kuki:125
func ListContainers(engine Engine) ([]ContainerInfo, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:126
	bg := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:127
	containers, err := engine.cli.ContainerList(ctxpkg.Value(bg), dockercontainer.ListOptions{All: true})
//line /home/user/kukicha/stdlib/container/container.kuki:128
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:129
		return nil, kukierrors.Wrap(err, "container list")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:130
	result := make([]ContainerInfo, len(containers))
//line /home/user/kukicha/stdlib/container/container.kuki:131
	for i, c := range containers {
//line /home/user/kukicha/stdlib/container/container.kuki:138
		result[i] = ContainerInfo{id: c.ID, image: c.Image, status: c.Status, state: c.State, names: c.Names}
	}
//line /home/user/kukicha/stdlib/container/container.kuki:139
	return result, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:142
func ListImages(engine Engine) ([]ImageInfo, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:143
	bg := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:144
	images, err := engine.cli.ImageList(ctxpkg.Value(bg), dockerimage.ListOptions{All: true})
//line /home/user/kukicha/stdlib/container/container.kuki:145
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:146
		return nil, kukierrors.Wrap(err, "container list images")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:147
	result := make([]ImageInfo, len(images))
//line /home/user/kukicha/stdlib/container/container.kuki:148
	for i, img := range images {
//line /home/user/kukicha/stdlib/container/container.kuki:153
		result[i] = ImageInfo{id: img.ID, tags: img.RepoTags, size: img.Size}
	}
//line /home/user/kukicha/stdlib/container/container.kuki:154
	return result, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:157
func Stop(engine Engine, containerID string) error {
//line /home/user/kukicha/stdlib/container/container.kuki:158
	bg := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:159
	err := engine.cli.ContainerStop(ctxpkg.Value(bg), containerID, dockercontainer.StopOptions{})
//line /home/user/kukicha/stdlib/container/container.kuki:160
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:161
		return kukierrors.Wrap(err, "container stop")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:162
	return nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:165
func Remove(engine Engine, containerID string) error {
//line /home/user/kukicha/stdlib/container/container.kuki:166
	bg := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:167
	err := engine.cli.ContainerRemove(ctxpkg.Value(bg), containerID, dockercontainer.RemoveOptions{})
//line /home/user/kukicha/stdlib/container/container.kuki:168
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:169
		return kukierrors.Wrap(err, "container remove")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:170
	return nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:173
func Login(username string, password string, server string) Auth {
//line /home/user/kukicha/stdlib/container/container.kuki:174
	return Auth{username: username, password: password, serverAddress: server}
}

//line /home/user/kukicha/stdlib/container/container.kuki:177
func AuthEncode(auth Auth) string {
//line /home/user/kukicha/stdlib/container/container.kuki:182
	authJSON, _ := json.Marshal(map[string]string{"username": auth.username, "password": auth.password, "serveraddress": auth.serverAddress})
//line /home/user/kukicha/stdlib/container/container.kuki:183
	return base64.URLEncoding.EncodeToString(authJSON)
}

//line /home/user/kukicha/stdlib/container/container.kuki:186
func ContainerID(c ContainerInfo) string {
//line /home/user/kukicha/stdlib/container/container.kuki:187
	return c.id
}

//line /home/user/kukicha/stdlib/container/container.kuki:190
func ContainerImage(c ContainerInfo) string {
//line /home/user/kukicha/stdlib/container/container.kuki:191
	return c.image
}

//line /home/user/kukicha/stdlib/container/container.kuki:194
func ContainerStatus(c ContainerInfo) string {
//line /home/user/kukicha/stdlib/container/container.kuki:195
	return c.status
}

//line /home/user/kukicha/stdlib/container/container.kuki:198
func ContainerState(c ContainerInfo) string {
//line /home/user/kukicha/stdlib/container/container.kuki:199
	return c.state
}

//line /home/user/kukicha/stdlib/container/container.kuki:202
func ContainerNames(c ContainerInfo) []string {
//line /home/user/kukicha/stdlib/container/container.kuki:203
	return c.names
}

//line /home/user/kukicha/stdlib/container/container.kuki:206
func ImageID(img ImageInfo) string {
//line /home/user/kukicha/stdlib/container/container.kuki:207
	return img.id
}

//line /home/user/kukicha/stdlib/container/container.kuki:210
func ImageTags(img ImageInfo) []string {
//line /home/user/kukicha/stdlib/container/container.kuki:211
	return img.tags
}

//line /home/user/kukicha/stdlib/container/container.kuki:214
func ImageSize(img ImageInfo) int64 {
//line /home/user/kukicha/stdlib/container/container.kuki:215
	return img.size
}

//line /home/user/kukicha/stdlib/container/container.kuki:218
func BuildImageID(b BuildOutput) string {
//line /home/user/kukicha/stdlib/container/container.kuki:219
	return b.imageID
}

//line /home/user/kukicha/stdlib/container/container.kuki:222
func BuildLog(b BuildOutput) string {
//line /home/user/kukicha/stdlib/container/container.kuki:223
	return b.output
}

//line /home/user/kukicha/stdlib/container/container.kuki:226
func EventID(event ContainerEvent) string {
//line /home/user/kukicha/stdlib/container/container.kuki:227
	return event.id
}

//line /home/user/kukicha/stdlib/container/container.kuki:230
func EventResource(event ContainerEvent) string {
//line /home/user/kukicha/stdlib/container/container.kuki:231
	return event.resource
}

//line /home/user/kukicha/stdlib/container/container.kuki:234
func EventAction(event ContainerEvent) string {
//line /home/user/kukicha/stdlib/container/container.kuki:235
	return event.action
}

//line /home/user/kukicha/stdlib/container/container.kuki:238
func EventActor(event ContainerEvent) string {
//line /home/user/kukicha/stdlib/container/container.kuki:239
	return event.actor
}

//line /home/user/kukicha/stdlib/container/container.kuki:242
func EventTime(event ContainerEvent) string {
//line /home/user/kukicha/stdlib/container/container.kuki:243
	return event.time
}

//line /home/user/kukicha/stdlib/container/container.kuki:249
func containerLogs(cli *client.Client, containerID string, tail string) (string, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:250
	bg := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:251
	opts := dockercontainer.LogsOptions{ShowStdout: true, ShowStderr: true}
//line /home/user/kukicha/stdlib/container/container.kuki:252
	if tail != "" {
//line /home/user/kukicha/stdlib/container/container.kuki:253
		opts.Tail = tail
	}
//line /home/user/kukicha/stdlib/container/container.kuki:254
	reader, err := cli.ContainerLogs(ctxpkg.Value(bg), containerID, opts)
//line /home/user/kukicha/stdlib/container/container.kuki:255
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:256
		return "", kukierrors.Wrap(err, "container logs")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:257
	defer reader.Close()
//line /home/user/kukicha/stdlib/container/container.kuki:258
	stdout := bytes.Buffer{}
//line /home/user/kukicha/stdlib/container/container.kuki:259
	stderr := bytes.Buffer{}
//line /home/user/kukicha/stdlib/container/container.kuki:260
	_, copyErr := stdcopy.StdCopy(&stdout, &stderr, reader)
//line /home/user/kukicha/stdlib/container/container.kuki:261
	if copyErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:262
		raw, readErr := io.ReadAll(reader)
//line /home/user/kukicha/stdlib/container/container.kuki:263
		if readErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:264
			return "", kukierrors.Wrap(copyErr, "container logs")
		}
//line /home/user/kukicha/stdlib/container/container.kuki:265
		return string(raw), nil
	}
//line /home/user/kukicha/stdlib/container/container.kuki:266
	combined := stdout.String()
//line /home/user/kukicha/stdlib/container/container.kuki:267
	if stderr.Len() > 0 {
//line /home/user/kukicha/stdlib/container/container.kuki:268
		combined = (combined + stderr.String())
	}
//line /home/user/kukicha/stdlib/container/container.kuki:269
	return combined, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:272
func Logs(engine Engine, containerID string) (string, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:273
	return containerLogs(engine.cli, containerID, "")
}

//line /home/user/kukicha/stdlib/container/container.kuki:276
func LogsTail(engine Engine, containerID string, lines int64) (string, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:277
	return containerLogs(engine.cli, containerID, fmt.Sprintf("%d", lines))
}

//line /home/user/kukicha/stdlib/container/container.kuki:280
func Run(engine Engine, img string, cmd []string) (string, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:281
	bg := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:285
	resp, err := engine.cli.ContainerCreate(ctxpkg.Value(bg), &dockercontainer.Config{Image: img, Cmd: cmd}, nil, nil, nil, "")
//line /home/user/kukicha/stdlib/container/container.kuki:286
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:287
		return "", kukierrors.Wrap(err, "container run create")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:288
	startErr := engine.cli.ContainerStart(ctxpkg.Value(bg), resp.ID, dockercontainer.StartOptions{})
//line /home/user/kukicha/stdlib/container/container.kuki:289
	if startErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:290
		return "", kukierrors.Wrap(startErr, "container run start")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:291
	return resp.ID, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:294
func Inspect(engine Engine, containerID string) (ContainerInfo, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:295
	bg := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:296
	info, err := engine.cli.ContainerInspect(ctxpkg.Value(bg), containerID)
//line /home/user/kukicha/stdlib/container/container.kuki:297
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:298
		return ContainerInfo{}, kukierrors.Wrap(err, "container inspect")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:299
	names := make([]string, 0)
//line /home/user/kukicha/stdlib/container/container.kuki:300
	if info.Name != "" {
//line /home/user/kukicha/stdlib/container/container.kuki:301
		names = append(names, kukistring.TrimPrefix(info.Name, "/"))
	}
//line /home/user/kukicha/stdlib/container/container.kuki:302
	status := ""
//line /home/user/kukicha/stdlib/container/container.kuki:303
	state := ""
//line /home/user/kukicha/stdlib/container/container.kuki:304
	if info.State != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:305
		status = info.State.Status
//line /home/user/kukicha/stdlib/container/container.kuki:306
		state = info.State.Status
	}
//line /home/user/kukicha/stdlib/container/container.kuki:307
	return ContainerInfo{id: info.ID, image: info.Config.Image, status: status, state: state, names: names}, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:317
func Exec(engine Engine, containerID string, cmd []string, handles ...ctxpkg.Handle) (string, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:318
	ctx := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:319
	if len(handles) > 0 {
//line /home/user/kukicha/stdlib/container/container.kuki:320
		ctx = handles[0]
	}
//line /home/user/kukicha/stdlib/container/container.kuki:325
	createResp, err := engine.cli.ContainerExecCreate(ctxpkg.Value(ctx), containerID, dockertypes.ExecConfig{Cmd: cmd, AttachStdout: true, AttachStderr: true})
//line /home/user/kukicha/stdlib/container/container.kuki:326
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:327
		return "", kukierrors.Wrap(err, "container exec create")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:328
	attachResp, attachErr := engine.cli.ContainerExecAttach(ctxpkg.Value(ctx), createResp.ID, dockertypes.ExecStartCheck{})
//line /home/user/kukicha/stdlib/container/container.kuki:329
	if attachErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:330
		return "", kukierrors.Wrap(attachErr, "container exec attach")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:331
	defer attachResp.Close()
//line /home/user/kukicha/stdlib/container/container.kuki:332
	stdout := bytes.Buffer{}
//line /home/user/kukicha/stdlib/container/container.kuki:333
	stderr := bytes.Buffer{}
//line /home/user/kukicha/stdlib/container/container.kuki:334
	_, copyErr := stdcopy.StdCopy(&stdout, &stderr, attachResp.Reader)
//line /home/user/kukicha/stdlib/container/container.kuki:335
	if copyErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:336
		raw, readErr := io.ReadAll(attachResp.Reader)
//line /home/user/kukicha/stdlib/container/container.kuki:337
		if readErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:338
			return "", kukierrors.Wrap(copyErr, "container exec read")
		}
//line /home/user/kukicha/stdlib/container/container.kuki:339
		return string(raw), nil
	}
//line /home/user/kukicha/stdlib/container/container.kuki:340
	inspectResult, inspectErr := engine.cli.ContainerExecInspect(ctxpkg.Value(ctx), createResp.ID)
//line /home/user/kukicha/stdlib/container/container.kuki:341
	if inspectErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:342
		return "", kukierrors.Wrap(inspectErr, "container exec inspect")
	}
//line /home/user/kukicha/stdlib/container/container.kuki:343
	combined := stdout.String()
//line /home/user/kukicha/stdlib/container/container.kuki:344
	if stderr.Len() > 0 {
//line /home/user/kukicha/stdlib/container/container.kuki:345
		combined = (combined + stderr.String())
	}
//line /home/user/kukicha/stdlib/container/container.kuki:346
	if inspectResult.ExitCode != 0 {
//line /home/user/kukicha/stdlib/container/container.kuki:347
		return combined, errors.New(fmt.Sprintf("container exec exit %v", inspectResult.ExitCode))
	}
//line /home/user/kukicha/stdlib/container/container.kuki:348
	return combined, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:354
func Wait(engine Engine, containerID string, timeoutSeconds int64) (int64, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:355
	h := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:356
	if timeoutSeconds > 0 {
//line /home/user/kukicha/stdlib/container/container.kuki:357
		h = ctxpkg.WithTimeout(h, timeoutSeconds)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:358
	defer ctxpkg.Cancel(h)
//line /home/user/kukicha/stdlib/container/container.kuki:359
	goCtx := ctxpkg.Value(h)
//line /home/user/kukicha/stdlib/container/container.kuki:360
	waitCh, errCh := engine.cli.ContainerWait(goCtx, containerID, dockercontainer.WaitConditionNotRunning)
//line /home/user/kukicha/stdlib/container/container.kuki:361
	select {
	case err := <-errCh:
//line /home/user/kukicha/stdlib/container/container.kuki:363
		if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:364
			return -1, fmt.Errorf("container wait: %w", err)
		}
//line /home/user/kukicha/stdlib/container/container.kuki:365
		return -1, errors.New("container wait: unknown wait error")
	case res := <-waitCh:
//line /home/user/kukicha/stdlib/container/container.kuki:367
		return res.StatusCode, nil
	}
}

//line /home/user/kukicha/stdlib/container/container.kuki:370
func WaitCtx(engine Engine, h ctxpkg.Handle, containerID string) (int64, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:371
	goCtx := ctxpkg.Value(h)
//line /home/user/kukicha/stdlib/container/container.kuki:372
	waitCh, errCh := engine.cli.ContainerWait(goCtx, containerID, dockercontainer.WaitConditionNotRunning)
//line /home/user/kukicha/stdlib/container/container.kuki:373
	select {
	case err := <-errCh:
//line /home/user/kukicha/stdlib/container/container.kuki:375
		if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:376
			return -1, fmt.Errorf("container wait: %w", err)
		}
//line /home/user/kukicha/stdlib/container/container.kuki:377
		return -1, errors.New("container wait: unknown wait error")
	case res := <-waitCh:
//line /home/user/kukicha/stdlib/container/container.kuki:379
		return res.StatusCode, nil
	}
}

//line /home/user/kukicha/stdlib/container/container.kuki:384
func convertEvent(msg dockerevents.Message) ContainerEvent {
//line /home/user/kukicha/stdlib/container/container.kuki:385
	ts := time.Unix(msg.Time, 0).UTC().Format(time.RFC3339)
//line /home/user/kukicha/stdlib/container/container.kuki:386
	actor := msg.Actor.ID
//line /home/user/kukicha/stdlib/container/container.kuki:387
	name, ok := msg.Actor.Attributes["name"]
//line /home/user/kukicha/stdlib/container/container.kuki:388
	if ok && (name != "") {
//line /home/user/kukicha/stdlib/container/container.kuki:389
		actor = name
	}
//line /home/user/kukicha/stdlib/container/container.kuki:390
	return ContainerEvent{id: msg.ID, resource: string(msg.Type), action: string(msg.Action), actor: actor, time: ts}
}

//line /home/user/kukicha/stdlib/container/container.kuki:399
func eventsWithContext(engine Engine, h ctxpkg.Handle) ([]ContainerEvent, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:400
	goCtx := ctxpkg.Value(h)
//line /home/user/kukicha/stdlib/container/container.kuki:401
	msgCh, errCh := engine.cli.Events(goCtx, dockertypes.EventsOptions{})
//line /home/user/kukicha/stdlib/container/container.kuki:402
	events := make([]ContainerEvent, 0)
//line /home/user/kukicha/stdlib/container/container.kuki:403
	for {
//line /home/user/kukicha/stdlib/container/container.kuki:404
		select {
		case <-goCtx.Done():
//line /home/user/kukicha/stdlib/container/container.kuki:406
			return events, nil
		case err := <-errCh:
//line /home/user/kukicha/stdlib/container/container.kuki:408
			if (err == nil) || (goCtx.Err() != nil) {
//line /home/user/kukicha/stdlib/container/container.kuki:409
				return events, nil
			}
//line /home/user/kukicha/stdlib/container/container.kuki:410
			return events, fmt.Errorf("container events: %w", err)
		case msg, ok := <-msgCh:
//line /home/user/kukicha/stdlib/container/container.kuki:412
			if !ok {
//line /home/user/kukicha/stdlib/container/container.kuki:413
				return events, nil
			}
//line /home/user/kukicha/stdlib/container/container.kuki:414
			events = append(events, convertEvent(msg))
		}
	}
//line /home/user/kukicha/stdlib/container/container.kuki:415
	return events, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:419
func Events(engine Engine, timeoutSeconds int64) ([]ContainerEvent, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:420
	if timeoutSeconds <= 0 {
//line /home/user/kukicha/stdlib/container/container.kuki:421
		timeoutSeconds = 15
	}
//line /home/user/kukicha/stdlib/container/container.kuki:422
	h := ctxpkg.WithTimeout(ctxpkg.Background(), timeoutSeconds)
//line /home/user/kukicha/stdlib/container/container.kuki:423
	defer ctxpkg.Cancel(h)
//line /home/user/kukicha/stdlib/container/container.kuki:424
	return eventsWithContext(engine, h)
}

//line /home/user/kukicha/stdlib/container/container.kuki:427
func EventsCtx(engine Engine, h ctxpkg.Handle) ([]ContainerEvent, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:428
	return eventsWithContext(engine, h)
}

//line /home/user/kukicha/stdlib/container/container.kuki:434
func Pull(engine Engine, ref string, handles ...ctxpkg.Handle) (string, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:435
	bg := ctxpkg.Background()
//line /home/user/kukicha/stdlib/container/container.kuki:436
	if len(handles) > 0 {
//line /home/user/kukicha/stdlib/container/container.kuki:437
		bg = handles[0]
	}
//line /home/user/kukicha/stdlib/container/container.kuki:438
	reader, err := engine.cli.ImagePull(ctxpkg.Value(bg), ref, dockerimage.PullOptions{})
//line /home/user/kukicha/stdlib/container/container.kuki:439
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:440
		return "", fmt.Errorf("container pull: %w", err)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:441
	defer reader.Close()
//line /home/user/kukicha/stdlib/container/container.kuki:442
	digest := ""
//line /home/user/kukicha/stdlib/container/container.kuki:443
	scanner := bufio.NewScanner(reader)
//line /home/user/kukicha/stdlib/container/container.kuki:444
	for scanner.Scan() {
//line /home/user/kukicha/stdlib/container/container.kuki:445
		msg := pullStatusMsg{}
//line /home/user/kukicha/stdlib/container/container.kuki:446
		unmarshalErr := json.Unmarshal(scanner.Bytes(), &msg)
//line /home/user/kukicha/stdlib/container/container.kuki:447
		if unmarshalErr == nil {
//line /home/user/kukicha/stdlib/container/container.kuki:448
			if kukistring.HasPrefix(msg.Status, "Digest:") {
//line /home/user/kukicha/stdlib/container/container.kuki:449
				digest = kukistring.TrimPrefix(msg.Status, "Digest: ")
			}
		}
	}
//line /home/user/kukicha/stdlib/container/container.kuki:450
	if digest == "" {
//line /home/user/kukicha/stdlib/container/container.kuki:451
		digest = ref
	}
//line /home/user/kukicha/stdlib/container/container.kuki:452
	return digest, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:455
func PullAuth(engine Engine, ref string, auth Auth) (string, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:460
	authJSON, jsonErr := json.Marshal(map[string]string{"username": auth.username, "password": auth.password, "serveraddress": auth.serverAddress})
//line /home/user/kukicha/stdlib/container/container.kuki:461
	if jsonErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:462
		return "", fmt.Errorf("container pull auth: %w", jsonErr)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:463
	encoded := base64.URLEncoding.EncodeToString(authJSON)
//line /home/user/kukicha/stdlib/container/container.kuki:466
	reader, err := engine.cli.ImagePull(ctxpkg.Value(ctxpkg.Background()), ref, dockerimage.PullOptions{RegistryAuth: encoded})
//line /home/user/kukicha/stdlib/container/container.kuki:467
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:468
		return "", fmt.Errorf("container pull: %w", err)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:469
	defer reader.Close()
//line /home/user/kukicha/stdlib/container/container.kuki:470
	digest := ""
//line /home/user/kukicha/stdlib/container/container.kuki:471
	scanner := bufio.NewScanner(reader)
//line /home/user/kukicha/stdlib/container/container.kuki:472
	for scanner.Scan() {
//line /home/user/kukicha/stdlib/container/container.kuki:473
		msg := pullStatusMsg{}
//line /home/user/kukicha/stdlib/container/container.kuki:474
		unmarshalErr := json.Unmarshal(scanner.Bytes(), &msg)
//line /home/user/kukicha/stdlib/container/container.kuki:475
		if unmarshalErr == nil {
//line /home/user/kukicha/stdlib/container/container.kuki:476
			if kukistring.HasPrefix(msg.Status, "Digest:") {
//line /home/user/kukicha/stdlib/container/container.kuki:477
				digest = kukistring.TrimPrefix(msg.Status, "Digest: ")
			}
		}
	}
//line /home/user/kukicha/stdlib/container/container.kuki:478
	if digest == "" {
//line /home/user/kukicha/stdlib/container/container.kuki:479
		digest = ref
	}
//line /home/user/kukicha/stdlib/container/container.kuki:480
	return digest, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:485
func loadDockerAuth(serverAddress string) (string, string, string, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:486
	home, homeErr := os.UserHomeDir()
//line /home/user/kukicha/stdlib/container/container.kuki:487
	if homeErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:488
		return "", "", "", fmt.Errorf("container auth: %w", homeErr)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:489
	configPath := filepath.Join(home, ".docker", "config.json")
//line /home/user/kukicha/stdlib/container/container.kuki:490
	data, readErr := os.ReadFile(configPath)
//line /home/user/kukicha/stdlib/container/container.kuki:491
	if readErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:492
		return "", "", "", fmt.Errorf("container auth: %w", readErr)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:493
	config := dockerConfig{}
//line /home/user/kukicha/stdlib/container/container.kuki:494
	unmarshalErr := json.Unmarshal(data, &config)
//line /home/user/kukicha/stdlib/container/container.kuki:495
	if unmarshalErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:496
		return "", "", "", fmt.Errorf("container auth parse: %w", unmarshalErr)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:497
	authEntry, ok := config.Auths[serverAddress]
//line /home/user/kukicha/stdlib/container/container.kuki:498
	if !ok {
//line /home/user/kukicha/stdlib/container/container.kuki:504
		variations := []string{("https://" + serverAddress), ("http://" + serverAddress), kukistring.TrimPrefix(serverAddress, "https://"), kukistring.TrimPrefix(serverAddress, "http://")}
//line /home/user/kukicha/stdlib/container/container.kuki:505
		for _, v := range variations {
//line /home/user/kukicha/stdlib/container/container.kuki:506
			a, found := config.Auths[v]
//line /home/user/kukicha/stdlib/container/container.kuki:507
			if found {
//line /home/user/kukicha/stdlib/container/container.kuki:508
				authEntry = a
//line /home/user/kukicha/stdlib/container/container.kuki:509
				ok = true
//line /home/user/kukicha/stdlib/container/container.kuki:510
				break
			}
		}
	}
//line /home/user/kukicha/stdlib/container/container.kuki:511
	if !ok {
//line /home/user/kukicha/stdlib/container/container.kuki:512
		return "", "", "", fmt.Errorf("container auth: no credentials found for %s", serverAddress)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:513
	if authEntry.Auth == "" {
//line /home/user/kukicha/stdlib/container/container.kuki:514
		return "", "", "", fmt.Errorf("container auth: empty credentials for %s", serverAddress)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:515
	decoded, decodeErr := base64.StdEncoding.DecodeString(authEntry.Auth)
//line /home/user/kukicha/stdlib/container/container.kuki:516
	if decodeErr != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:517
		return "", "", "", fmt.Errorf("container auth decode: %w", decodeErr)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:518
	parts := kukistring.SplitN(string(decoded), ":", 2)
//line /home/user/kukicha/stdlib/container/container.kuki:519
	if len(parts) != 2 {
//line /home/user/kukicha/stdlib/container/container.kuki:520
		return "", "", "", fmt.Errorf("container auth: invalid credential format for %s", serverAddress)
	}
//line /home/user/kukicha/stdlib/container/container.kuki:521
	return parts[0], parts[1], serverAddress, nil
}

//line /home/user/kukicha/stdlib/container/container.kuki:524
func LoginFromConfig(server string) (Auth, error) {
//line /home/user/kukicha/stdlib/container/container.kuki:525
	username, password, addr, err := loadDockerAuth(server)
//line /home/user/kukicha/stdlib/container/container.kuki:526
	if err != nil {
//line /home/user/kukicha/stdlib/container/container.kuki:527
		return Auth{}, err
	}
//line /home/user/kukicha/stdlib/container/container.kuki:528
	return Auth{username: username, password: password, serverAddress: addr}, nil
}
