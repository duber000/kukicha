# Kukicha Standard Library - A2A Client Wrapper

petiole a2a

import "net/http"
import "stdlib/ctx" as ctxpkg
import "stdlib/retry"
import "stdlib/string"
import "github.com/a2aproject/a2a-go/a2a"
import "github.com/a2aproject/a2a-go/a2aclient"
import "github.com/a2aproject/a2a-go/a2aclient/agentcard"

# TextHandler is a callback for streaming text chunks.
type TextHandler func(string)

# StatusHandler is a callback for streaming status updates.
type StatusHandler func(StatusUpdate)

# Agent wraps a resolved agent card and its corresponding client.
type Agent
    Card reference a2a.AgentCard
    Client reference a2aclient.Client

# Request is a builder struct for constructing A2A requests via pipe-chaining.
type Request
    agent Agent
    text string
    contextID string
    onText TextHandler
    onStatus StatusHandler
    retryMaxAttempts int
    retryDelayMs int

# Task represents a simplified A2A task result
type Task
    ID string
    ContextID string
    State string
    Text string
    Artifacts list of Artifact

# Artifact represents a named text artifact from a task
type Artifact
    Name string
    Text string

# StatusUpdate represents a streaming status callback payload
type StatusUpdate
    TaskID string
    State string
    Message string
    Final bool

# Skill represents an agent skill from its card
type Skill
    Name string
    Description string
    Examples list of string

# Discover resolves an agent card from a URL and creates a client.
func Discover(url string) (Agent, error)
    bg := ctxpkg.Background()
    card := agentcard.DefaultResolver.Resolve(ctxpkg.Value(bg), url) onerr explain "a2a discover"
    client := a2aclient.NewFromCard(ctxpkg.Value(bg), card) onerr explain "a2a client"
    return Agent{Card: card, Client: client}, empty

# DiscoverGuarded resolves an agent card and creates a client using a custom HTTP client.
func DiscoverGuarded(url string, httpClient reference http.Client) (Agent, error)
    bg := ctxpkg.Background()
    resolver := agentcard.NewResolver(httpClient)
    card := resolver.Resolve(ctxpkg.Value(bg), url) onerr explain "a2a discover"
    client := a2aclient.NewFromCard(ctxpkg.Value(bg), card, a2aclient.WithJSONRPCTransport(httpClient)) onerr explain "a2a client"
    return Agent{Card: card, Client: client}, empty

# New starts a new request builder for the given agent.
func New(agent Agent) Request
    return Request{agent: agent}

# Text sets the message text on the request builder.
func Text(req Request, text string) Request
    req.text = text
    return req

# Context sets the context ID for multi-turn conversations.
func Context(req Request, id string) Request
    req.contextID = id
    return req

# OnText sets a callback for streaming text chunks.
func OnText(req Request, handler TextHandler) Request
    req.onText = handler
    return req

# OnStatus sets a callback for streaming status updates.
func OnStatus(req Request, handler StatusHandler) Request
    req.onStatus = handler
    return req

# Retry configures automatic retry on transient A2A errors.
# maxAttempts is total attempts; delayMs is the initial backoff in milliseconds.
# Example: a2a.New(agent) |> a2a.Text("hello") |> a2a.Retry(3, 500) |> a2a.Send()
func Retry(req Request, maxAttempts int, delayMs int) Request
    req.retryMaxAttempts = maxAttempts
    req.retryDelayMs = delayMs
    return req

# Close destroys the client resources for the agent.
func Close(agent Agent) error
    return agent.Client.Destroy()

# Skills returns the list of skills from the agent's card.
func Skills(agent Agent) list of Skill
    skills := make(list of Skill, len(agent.Card.Skills))
    for i, s in agent.Card.Skills
        skills[i] = Skill{Name: s.Name, Description: s.Description, Examples: s.Examples}
    return skills

# Send executes a blocking request and returns the task result.
# If Retry() was configured, automatically retries on transient errors.
func Send(req Request) (Task, error)
    if req.retryMaxAttempts <= 1
        return sendRequest(req.agent, req.text, req.contextID)

    delayMs := req.retryDelayMs
    if delayMs <= 0
        delayMs = 1000
    cfg := retry.Config{MaxAttempts: req.retryMaxAttempts, InitialDelay: delayMs, Strategy: 1}
    attempt := 0
    lastErr := error "no attempts made"
    for attempt < cfg.MaxAttempts
        task, err := sendRequest(req.agent, req.text, req.contextID)
        if err == empty
            return task, empty
        lastErr = err
        retry.Sleep(cfg, attempt)
        attempt = attempt + 1
    return empty Task, lastErr

# Stream executes a streaming request with callbacks.
func Stream(req Request) (Task, error)
    return streamRequest(req.agent, req.text, req.contextID, req.onText, req.onStatus)

# Ask is a one-shot convenience: send text and get the reply text back.
func Ask(agent Agent, text string) (string, error)
    task := sendRequest(agent, text, "") onerr explain "a2a ask"
    return task.Text, empty

# GetTask queries a task by ID from the agent.
func GetTask(agent Agent, taskID string) (Task, error)
    bg := ctxpkg.Background()
    params := a2a.TaskQueryParams{ID: a2a.TaskID(taskID)}
    t := agent.Client.GetTask(ctxpkg.Value(bg), reference of params) onerr explain "a2a get task"
    return taskFromA2A(t), empty

# Cancel cancels a task by ID.
func Cancel(agent Agent, taskID string) (Task, error)
    bg := ctxpkg.Background()
    params := a2a.TaskIDParams{ID: a2a.TaskID(taskID)}
    t := agent.Client.CancelTask(ctxpkg.Value(bg), reference of params) onerr explain "a2a cancel"
    return taskFromA2A(t), empty

# sendRequest sends a blocking message to an agent and returns a simplified Task.
func sendRequest(agent Agent, text string, contextID string) (Task, error)
    bg := ctxpkg.Background()
    msg := a2a.NewMessage(a2a.MessageRoleUser, a2a.TextPart{Text: text})
    if contextID != ""
        msg.ContextID = contextID
    params := a2a.MessageSendParams{Message: msg}
    resp := agent.Client.SendMessage(ctxpkg.Value(bg), reference of params) onerr explain "a2a send"
    return resultToTask(resp), empty

# streamRequest sends a streaming message to an agent, dispatching to callbacks.
func streamRequest(agent Agent, text string, contextID string, onText TextHandler, onStatus StatusHandler) (Task, error)
    bg := ctxpkg.Background()
    msg := a2a.NewMessage(a2a.MessageRoleUser, a2a.TextPart{Text: text})
    if contextID != ""
        msg.ContextID = contextID

    result := empty Task
    params := a2a.MessageSendParams{Message: msg}
    for event, err in agent.Client.SendStreamingMessage(ctxpkg.Value(bg), reference of params)
        if err != empty
            return result, error("a2a stream: {err}")
        switch event as e
            when reference a2a.TaskStatusUpdateEvent
                if onStatus != empty
                    statusMsg := ""
                    if e.Status.Message != empty
                        statusMsg = extractPartsText(e.Status.Message.Parts)
                    onStatus(StatusUpdate{TaskID: e.TaskID as string, State: e.Status.State as string, Message: statusMsg, Final: e.Final})
                result.ID = e.TaskID as string
                result.ContextID = e.ContextID
                result.State = e.Status.State as string
            when reference a2a.TaskArtifactUpdateEvent
                if e.Artifact != empty
                    artText := extractPartsText(e.Artifact.Parts)
                    if onText != empty and artText != ""
                        onText(artText)
                    result.Artifacts = append(result.Artifacts, Artifact{Name: e.Artifact.Name, Text: artText})
                result.ID = e.TaskID as string
                result.ContextID = e.ContextID
            when reference a2a.Task
                result = taskFromA2A(e)
            when reference a2a.Message
                msgText := extractPartsText(e.Parts)
                if onText != empty and msgText != ""
                    onText(msgText)
                result.Text = msgText
    return result, empty

# resultToTask converts a SendMessageResult (union of *Task or *Message) to our simplified Task.
func resultToTask(result a2a.SendMessageResult) Task
    switch result as r
        when reference a2a.Task
            return taskFromA2A(r)
        when reference a2a.Message
            return Task{ID: r.TaskID as string, ContextID: r.ContextID, Text: extractPartsText(r.Parts)}
        otherwise
            return empty Task

# taskFromA2A converts an a2a.Task to our simplified Task type.
func taskFromA2A(t reference a2a.Task) Task
    result := Task{ID: t.ID as string, ContextID: t.ContextID, State: t.Status.State as string}

    for _, art in t.Artifacts
        artText := extractPartsText(art.Parts)
        result.Artifacts = append(result.Artifacts, Artifact{Name: art.Name, Text: artText})

    texts := empty list of string
    if t.Status.Message != empty
        msg := extractPartsText(t.Status.Message.Parts)
        if msg != ""
            texts = append(texts, msg)
    for _, art in result.Artifacts
        if art.Text != ""
            texts = append(texts, art.Text)
    result.Text = string.Join(texts, "\n")

    return result

# extractPartsText concatenates all TextPart content from a list of parts.
func extractPartsText(parts list of a2a.Part) string
    texts := empty list of string
    for _, p in parts
        switch p as tp
            when a2a.TextPart
                texts = append(texts, tp.Text)
    return string.Join(texts, "")
