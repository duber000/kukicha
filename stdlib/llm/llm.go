// Generated by Kukicha v0.0.1 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package llm

import (
	"bufio"
	"errors"
	"fmt"
	"github.com/duber000/kukicha/stdlib/env"
	"github.com/duber000/kukicha/stdlib/fetch"
	"github.com/duber000/kukicha/stdlib/json"
	kukistring "github.com/duber000/kukicha/stdlib/string"
)

type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type ToolFunction struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Parameters  any    `json:"parameters"`
}

type Tool struct {
	Type     string       `json:"type"`
	Function ToolFunction `json:"function"`
}

type ToolCall struct {
	ID       string           `json:"id"`
	Type     string           `json:"type"`
	Function ToolCallFunction `json:"function"`
}

type ToolCallFunction struct {
	Name      string `json:"name"`
	Arguments string `json:"arguments"`
}

type Choice struct {
	Index        int             `json:"index"`
	Message      ResponseMessage `json:"message"`
	FinishReason string          `json:"finish_reason"`
}

type ResponseMessage struct {
	Role      string     `json:"role"`
	Content   string     `json:"content"`
	ToolCalls []ToolCall `json:"tool_calls,omitzero"`
}

type Usage struct {
	PromptTokens     int `json:"prompt_tokens"`
	CompletionTokens int `json:"completion_tokens"`
	TotalTokens      int `json:"total_tokens"`
}

type Completion struct {
	ID      string   `json:"id"`
	Object  string   `json:"object"`
	Created int      `json:"created"`
	Model   string   `json:"model"`
	Choices []Choice `json:"choices"`
	Usage   Usage    `json:"usage"`
}

type ChunkDelta struct {
	Role    string `json:"role,omitzero"`
	Content string `json:"content,omitzero"`
}

type ChunkChoice struct {
	Index        int        `json:"index"`
	Delta        ChunkDelta `json:"delta"`
	FinishReason string     `json:"finish_reason,omitzero"`
}

type Chunk struct {
	ID      string        `json:"id"`
	Object  string        `json:"object"`
	Created int           `json:"created"`
	Model   string        `json:"model"`
	Choices []ChunkChoice `json:"choices"`
}

type CompletionRequest struct {
	Model            string    `json:"model"`
	Messages         []Message `json:"messages"`
	Temperature      float64   `json:"temperature,omitzero"`
	MaxTokens        int       `json:"max_tokens,omitzero"`
	TopP             float64   `json:"top_p,omitzero"`
	N                int       `json:"n,omitzero"`
	Stop             []string  `json:"stop,omitzero"`
	PresencePenalty  float64   `json:"presence_penalty,omitzero"`
	FrequencyPenalty float64   `json:"frequency_penalty,omitzero"`
	Seed             int       `json:"seed,omitzero"`
	User             string    `json:"user,omitzero"`
	Stream           bool      `json:"stream,omitzero"`
	Tools            []Tool    `json:"tools,omitzero"`
	ToolChoice       any       `json:"tool_choice,omitzero"`
	ResponseFormat   any       `json:"response_format,omitzero"`
}

type Client struct {
	model            string
	provider         string
	baseURL          string
	path             string
	apiKey           string
	messages         []Message
	temperature      float64
	maxTokens        int
	topP             float64
	n                int
	stop             []string
	presencePenalty  float64
	frequencyPenalty float64
	seed             int
	user             string
	tools            []Tool
	toolChoice       any
	responseFormat   any
	streamHandler    func(string)
}

func New(model string) Client {
	c := Client{}
	c.messages = nil
	c.tools = nil
	c.temperature = 0.000000
	c.maxTokens = 0
	c.topP = 0.000000
	c.n = 0
	c.seed = 0
	c.presencePenalty = 0.000000
	c.frequencyPenalty = 0.000000
	if kukistring.Contains(model, ":") {
		parts := kukistring.SplitN(model, ":", 2)
		c.provider = parts[0]
		c.model = parts[1]
	} else {
		c.model = model
		c.provider = ""
	}
	c.baseURL = ""
	c.path = ""
	c.apiKey = ""
	c.user = ""
	c.streamHandler = nil
	c.toolChoice = nil
	c.responseFormat = nil
	return c
}

func Provider(c Client, provider string) Client {
	c.provider = provider
	return c
}

func Gateway(c Client, url string) Client {
	c.baseURL = url
	return c
}

func BaseURL(c Client, url string) Client {
	c.baseURL = url
	return c
}

func Path(c Client, path string) Client {
	c.path = path
	return c
}

func APIKey(c Client, key string) Client {
	c.apiKey = key
	return c
}

func System(c Client, content string) Client {
	msg := Message{Role: "system", Content: content}
	c.messages = append(c.messages, msg)
	return c
}

func User(c Client, content string) Client {
	msg := Message{Role: "user", Content: content}
	c.messages = append(c.messages, msg)
	return c
}

func Assistant(c Client, content string) Client {
	msg := Message{Role: "assistant", Content: content}
	c.messages = append(c.messages, msg)
	return c
}

func AddMessage(c Client, role string, content string) Client {
	msg := Message{Role: role, Content: content}
	c.messages = append(c.messages, msg)
	return c
}

func Messages(c Client, msgs []Message) Client {
	c.messages = msgs
	return c
}

func Temperature(c Client, temp float64) Client {
	c.temperature = temp
	return c
}

func MaxTokens(c Client, max int) Client {
	c.maxTokens = max
	return c
}

func TopP(c Client, p float64) Client {
	c.topP = p
	return c
}

func Stop(c Client, sequences []string) Client {
	c.stop = sequences
	return c
}

func PresencePenalty(c Client, penalty float64) Client {
	c.presencePenalty = penalty
	return c
}

func FrequencyPenalty(c Client, penalty float64) Client {
	c.frequencyPenalty = penalty
	return c
}

func Seed(c Client, seed int) Client {
	c.seed = seed
	return c
}

func SetUser(c Client, user string) Client {
	c.user = user
	return c
}

func AddTool(c Client, name string, description string, parameters any) Client {
	fn := ToolFunction{Name: name, Description: description, Parameters: parameters}
	tool := Tool{Type: "function", Function: fn}
	c.tools = append(c.tools, tool)
	return c
}

func ToolChoiceAuto(c Client) Client {
	c.toolChoice = "auto"
	return c
}

func ToolChoiceRequired(c Client) Client {
	c.toolChoice = "required"
	return c
}

func ToolChoiceNone(c Client) Client {
	c.toolChoice = "none"
	return c
}

func JSONMode(c Client) Client {
	c.responseFormat = map[string]string{"type": "json_object"}
	return c
}

func Stream(c Client, handler func(string)) Client {
	c.streamHandler = handler
	return c
}

func Ask(c Client, prompt string) (string, error) {
	c = User(c, prompt)
	return execute(c)
}

func Send(c Client) (string, error) {
	return execute(c)
}

func SendRaw(c Client) (Completion, error) {
	return executeRaw(c)
}

func Complete(model string, prompt string) (string, error) {
	c := New(model)
	return Ask(c, prompt)
}

func CompleteWithSystem(model string, systemPrompt string, prompt string) (string, error) {
	c := New(model)
	c = System(c, systemPrompt)
	return Ask(c, prompt)
}

func GetContent(comp Completion) string {
	if len(comp.Choices) == 0 {
		return ""
	}
	return comp.Choices[0].Message.Content
}

func GetToolCalls(comp Completion) []ToolCall {
	if len(comp.Choices) == 0 {
		return nil
	}
	return comp.Choices[0].Message.ToolCalls
}

func HasToolCalls(comp Completion) bool {
	calls := GetToolCalls(comp)
	return (len(calls) > 0)
}

func resolveAPIKey(c Client) string {
	if c.apiKey != "" {
		return c.apiKey
	}
	if c.provider == "openai" {
		key := env.GetOr("OPENAI_API_KEY", "")
		return key
	}
	if c.provider == "anthropic" {
		key := env.GetOr("ANTHROPIC_API_KEY", "")
		return key
	}
	if c.provider == "mistral" {
		key := env.GetOr("MISTRAL_API_KEY", "")
		return key
	}
	if c.provider == "groq" {
		key := env.GetOr("GROQ_API_KEY", "")
		return key
	}
	if c.provider == "together" {
		key := env.GetOr("TOGETHER_API_KEY", "")
		return key
	}
	if c.provider == "deepseek" {
		key := env.GetOr("DEEPSEEK_API_KEY", "")
		return key
	}
	if c.provider == "xai" {
		key := env.GetOr("XAI_API_KEY", "")
		return key
	}
	key := env.GetOr("LLM_API_KEY", "")
	return key
}

func resolveBaseURL(c Client) string {
	if c.baseURL != "" {
		return c.baseURL
	}
	if c.provider == "openai" {
		return "https://api.openai.com"
	}
	if c.provider == "anthropic" {
		return "https://api.anthropic.com"
	}
	if c.provider == "mistral" {
		return "https://api.mistral.ai"
	}
	if c.provider == "groq" {
		return "https://api.groq.com/openai"
	}
	if c.provider == "together" {
		return "https://api.together.xyz"
	}
	if c.provider == "deepseek" {
		return "https://api.deepseek.com"
	}
	if c.provider == "xai" {
		return "https://api.x.ai"
	}
	if c.provider == "ollama" {
		return "http://localhost:11434"
	}
	return "http://localhost:8000"
}

func resolvePath(c Client) string {
	if c.path != "" {
		return c.path
	}
	return "/v1/chat/completions"
}

func buildRequest(c Client) CompletionRequest {
	req := CompletionRequest{}
	req.Model = c.model
	req.Messages = c.messages
	if c.temperature != 0.000000 {
		req.Temperature = c.temperature
	}
	if c.maxTokens != 0 {
		req.MaxTokens = c.maxTokens
	}
	if c.topP != 0.000000 {
		req.TopP = c.topP
	}
	if c.n != 0 {
		req.N = c.n
	}
	if c.seed != 0 {
		req.Seed = c.seed
	}
	if c.presencePenalty != 0.000000 {
		req.PresencePenalty = c.presencePenalty
	}
	if c.frequencyPenalty != 0.000000 {
		req.FrequencyPenalty = c.frequencyPenalty
	}
	if c.user != "" {
		req.User = c.user
	}
	if len(c.stop) > 0 {
		req.Stop = c.stop
	}
	if len(c.tools) > 0 {
		req.Tools = c.tools
	}
	if c.toolChoice != nil {
		req.ToolChoice = c.toolChoice
	}
	if c.responseFormat != nil {
		req.ResponseFormat = c.responseFormat
	}
	if c.streamHandler != nil {
		req.Stream = true
	}
	return req
}

func execute(c Client) (string, error) {
	if c.streamHandler != nil {
		return executeStream(c)
	}
	comp, err := executeRaw(c)
	if err != nil {
		return "", err
	}
	return GetContent(comp), nil
}

func executeRaw(c Client) (Completion, error) {
	baseURL := resolveBaseURL(c)
	apiKey := resolveAPIKey(c)
	chatPath := resolvePath(c)
	url := fmt.Sprintf("%v%v", baseURL, chatPath)
	body := buildRequest(c)
	req := fetch.Body(fetch.Header(fetch.Method(fetch.New(url), "POST"), "Content-Type", "application/json"), body)
	if apiKey != "" {
		req = fetch.Header(req, "Authorization", fmt.Sprintf("Bearer %v", apiKey))
	}
	resp, err := fetch.Do(req)
	if err != nil {
		return Completion{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, readErr := fetch.Bytes(resp)
		if readErr != nil {
			return Completion{}, errors.New(fmt.Sprintf("API request failed with status %v", resp.StatusCode))
		}
		return Completion{}, errors.New(fmt.Sprintf("API request failed (%v): %v", resp.StatusCode, string(errBody)))
	}
	comp := Completion{}
	jsonErr := json.UnmarshalRead(resp.Body, &comp)
	if jsonErr != nil {
		return Completion{}, jsonErr
	}
	return comp, nil
}

func executeStream(c Client) (string, error) {
	baseURL := resolveBaseURL(c)
	apiKey := resolveAPIKey(c)
	chatPath := resolvePath(c)
	url := fmt.Sprintf("%v%v", baseURL, chatPath)
	body := buildRequest(c)
	req := fetch.Body(fetch.Header(fetch.Header(fetch.Method(fetch.New(url), "POST"), "Content-Type", "application/json"), "Accept", "text/event-stream"), body)
	if apiKey != "" {
		req = fetch.Header(req, "Authorization", fmt.Sprintf("Bearer %v", apiKey))
	}
	resp, err := fetch.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, readErr := fetch.Bytes(resp)
		if readErr != nil {
			return "", errors.New(fmt.Sprintf("API request failed with status %v", resp.StatusCode))
		}
		return "", errors.New(fmt.Sprintf("API request failed (%v): %v", resp.StatusCode, string(errBody)))
	}
	fullContent := ""
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		line := scanner.Text()
		if (line == "") || kukistring.HasPrefix(line, ":") {
			continue
		}
		if line == "data: [DONE]" {
			break
		}
		if kukistring.HasPrefix(line, "data: ") {
			data := kukistring.TrimPrefix(line, "data: ")
			chunk := Chunk{}
			parseErr := json.Unmarshal([]byte(data), &chunk)
			if parseErr != nil {
				continue
			}
			if len(chunk.Choices) > 0 {
				content := chunk.Choices[0].Delta.Content
				if content != "" {
					fullContent = (fullContent + content)
					c.streamHandler(content)
				}
			}
		}
	}
	scanErr := scanner.Err()
	if scanErr != nil {
		return fullContent, scanErr
	}
	return fullContent, nil
}

type InputTextContent struct {
	Type string `json:"type"`
	Text string `json:"text"`
}

type OutputTextContent struct {
	Type        string `json:"type"`
	Text        string `json:"text"`
	Annotations []any  `json:"annotations,omitzero"`
}

type RefusalContent struct {
	Type    string `json:"type"`
	Refusal string `json:"refusal"`
}

type InputItem struct {
	Type      string `json:"type"`
	ID        string `json:"id,omitzero"`
	Role      string `json:"role,omitzero"`
	Content   any    `json:"content,omitzero"`
	Status    string `json:"status,omitzero"`
	CallID    string `json:"call_id,omitzero"`
	Name      string `json:"name,omitzero"`
	Arguments string `json:"arguments,omitzero"`
	Output    string `json:"output,omitzero"`
}

type OutputItem struct {
	Type      string `json:"type"`
	ID        string `json:"id,omitzero"`
	Role      string `json:"role,omitzero"`
	Content   []any  `json:"content,omitzero"`
	Status    string `json:"status,omitzero"`
	CallID    string `json:"call_id,omitzero"`
	Name      string `json:"name,omitzero"`
	Arguments string `json:"arguments,omitzero"`
	Summary   []any  `json:"summary,omitzero"`
}

type ResponseUsage struct {
	InputTokens  int `json:"input_tokens"`
	OutputTokens int `json:"output_tokens"`
	TotalTokens  int `json:"total_tokens"`
}

type ResponseError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

type Response struct {
	ID                 string            `json:"id"`
	Object             string            `json:"object"`
	CreatedAt          int               `json:"created_at"`
	CompletedAt        int               `json:"completed_at,omitzero"`
	Status             string            `json:"status"`
	Model              string            `json:"model"`
	Output             []OutputItem      `json:"output"`
	Error              ResponseError     `json:"error,omitzero"`
	PreviousResponseID string            `json:"previous_response_id,omitzero"`
	Instructions       string            `json:"instructions,omitzero"`
	Temperature        float64           `json:"temperature,omitzero"`
	TopP               float64           `json:"top_p,omitzero"`
	MaxOutputTokens    int               `json:"max_output_tokens,omitzero"`
	Usage              ResponseUsage     `json:"usage,omitzero"`
	Tools              []any             `json:"tools,omitzero"`
	ToolChoice         any               `json:"tool_choice,omitzero"`
	Truncation         string            `json:"truncation,omitzero"`
	Store              bool              `json:"store,omitzero"`
	Metadata           map[string]string `json:"metadata,omitzero"`
}

type ResponseRequest struct {
	Model              string            `json:"model"`
	Input              any               `json:"input"`
	Instructions       string            `json:"instructions,omitzero"`
	PreviousResponseID string            `json:"previous_response_id,omitzero"`
	Temperature        float64           `json:"temperature,omitzero"`
	TopP               float64           `json:"top_p,omitzero"`
	MaxOutputTokens    int               `json:"max_output_tokens,omitzero"`
	PresencePenalty    float64           `json:"presence_penalty,omitzero"`
	FrequencyPenalty   float64           `json:"frequency_penalty,omitzero"`
	Tools              []Tool            `json:"tools,omitzero"`
	ToolChoice         any               `json:"tool_choice,omitzero"`
	Stream             bool              `json:"stream,omitzero"`
	Store              bool              `json:"store,omitzero"`
	Truncation         string            `json:"truncation,omitzero"`
	Metadata           map[string]string `json:"metadata,omitzero"`
	Text               any               `json:"text,omitzero"`
}

type StreamEvent struct {
	Type           string     `json:"type"`
	SequenceNumber int        `json:"sequence_number"`
	Response       Response   `json:"response,omitzero"`
	OutputIndex    int        `json:"output_index,omitzero"`
	ContentIndex   int        `json:"content_index,omitzero"`
	ItemID         string     `json:"item_id,omitzero"`
	Item           OutputItem `json:"item,omitzero"`
	Delta          string     `json:"delta,omitzero"`
	Text           string     `json:"text,omitzero"`
	Part           any        `json:"part,omitzero"`
	Name           string     `json:"name,omitzero"`
	Arguments      string     `json:"arguments,omitzero"`
	Code           string     `json:"code,omitzero"`
	Message        string     `json:"message,omitzero"`
}

type ResponseClient struct {
	model              string
	provider           string
	baseURL            string
	path               string
	apiKey             string
	input              []InputItem
	instructions       string
	previousResponseID string
	temperature        float64
	topP               float64
	maxOutputTokens    int
	presencePenalty    float64
	frequencyPenalty   float64
	tools              []Tool
	toolChoice         any
	store              bool
	truncation         string
	metadata           map[string]string
	textFormat         any
	streamHandler      func(string)
	eventHandler       func(StreamEvent)
}

func NewResponse(model string) ResponseClient {
	c := ResponseClient{}
	c.input = nil
	c.tools = nil
	c.temperature = 0.000000
	c.topP = 0.000000
	c.maxOutputTokens = 0
	c.presencePenalty = 0.000000
	c.frequencyPenalty = 0.000000
	c.store = false
	c.truncation = ""
	c.instructions = ""
	c.previousResponseID = ""
	if kukistring.Contains(model, ":") {
		parts := kukistring.SplitN(model, ":", 2)
		c.provider = parts[0]
		c.model = parts[1]
	} else {
		c.model = model
		c.provider = ""
	}
	c.baseURL = ""
	c.path = ""
	c.apiKey = ""
	c.streamHandler = nil
	c.eventHandler = nil
	c.toolChoice = nil
	c.textFormat = nil
	c.metadata = nil
	return c
}

func RProvider(c ResponseClient, provider string) ResponseClient {
	c.provider = provider
	return c
}

func RBaseURL(c ResponseClient, url string) ResponseClient {
	c.baseURL = url
	return c
}

func RPath(c ResponseClient, path string) ResponseClient {
	c.path = path
	return c
}

func RAPIKey(c ResponseClient, key string) ResponseClient {
	c.apiKey = key
	return c
}

func Instructions(c ResponseClient, instructions string) ResponseClient {
	c.instructions = instructions
	return c
}

func PreviousResponse(c ResponseClient, id string) ResponseClient {
	c.previousResponseID = id
	return c
}

func RUserMessage(c ResponseClient, content string) ResponseClient {
	item := InputItem{}
	item.Type = "message"
	item.Role = "user"
	item.Content = content
	c.input = append(c.input, item)
	return c
}

func RSystemMessage(c ResponseClient, content string) ResponseClient {
	item := InputItem{}
	item.Type = "message"
	item.Role = "system"
	item.Content = content
	c.input = append(c.input, item)
	return c
}

func RDeveloperMessage(c ResponseClient, content string) ResponseClient {
	item := InputItem{}
	item.Type = "message"
	item.Role = "developer"
	item.Content = content
	c.input = append(c.input, item)
	return c
}

func RAssistantMessage(c ResponseClient, content string) ResponseClient {
	item := InputItem{}
	item.Type = "message"
	item.Role = "assistant"
	item.Content = content
	c.input = append(c.input, item)
	return c
}

func RAddInput(c ResponseClient, item InputItem) ResponseClient {
	c.input = append(c.input, item)
	return c
}

func FunctionCallOutput(c ResponseClient, callID string, output string) ResponseClient {
	item := InputItem{}
	item.Type = "function_call_output"
	item.CallID = callID
	item.Output = output
	c.input = append(c.input, item)
	return c
}

func RTemperature(c ResponseClient, temp float64) ResponseClient {
	c.temperature = temp
	return c
}

func RTopP(c ResponseClient, p float64) ResponseClient {
	c.topP = p
	return c
}

func RMaxOutputTokens(c ResponseClient, max int) ResponseClient {
	c.maxOutputTokens = max
	return c
}

func RPresencePenalty(c ResponseClient, penalty float64) ResponseClient {
	c.presencePenalty = penalty
	return c
}

func RFrequencyPenalty(c ResponseClient, penalty float64) ResponseClient {
	c.frequencyPenalty = penalty
	return c
}

func RAddTool(c ResponseClient, name string, description string, parameters any) ResponseClient {
	fn := ToolFunction{Name: name, Description: description, Parameters: parameters}
	tool := Tool{Type: "function", Function: fn}
	c.tools = append(c.tools, tool)
	return c
}

func RToolChoiceAuto(c ResponseClient) ResponseClient {
	c.toolChoice = "auto"
	return c
}

func RToolChoiceRequired(c ResponseClient) ResponseClient {
	c.toolChoice = "required"
	return c
}

func RToolChoiceNone(c ResponseClient) ResponseClient {
	c.toolChoice = "none"
	return c
}

func RJSONMode(c ResponseClient) ResponseClient {
	c.textFormat = map[string]string{"type": "json_object"}
	return c
}

func RJSONSchema(c ResponseClient, name string, schema any) ResponseClient {
	c.textFormat = map[string]any{"type": "json_schema", "name": name, "schema": schema, "strict": true}
	return c
}

func RStore(c ResponseClient) ResponseClient {
	c.store = true
	return c
}

func RTruncation(c ResponseClient, mode string) ResponseClient {
	c.truncation = mode
	return c
}

func RMetadata(c ResponseClient, meta map[string]string) ResponseClient {
	c.metadata = meta
	return c
}

func RStream(c ResponseClient, handler func(string)) ResponseClient {
	c.streamHandler = handler
	return c
}

func RStreamEvents(c ResponseClient, handler func(StreamEvent)) ResponseClient {
	c.eventHandler = handler
	return c
}

func RAsk(c ResponseClient, prompt string) (string, error) {
	c = RUserMessage(c, prompt)
	return rExecute(c)
}

func RSend(c ResponseClient) (string, error) {
	return rExecute(c)
}

func RAskRaw(c ResponseClient, prompt string) (Response, error) {
	c = RUserMessage(c, prompt)
	return rExecuteRaw(c)
}

func RSendRaw(c ResponseClient) (Response, error) {
	return rExecuteRaw(c)
}

func Respond(model string, prompt string) (string, error) {
	c := NewResponse(model)
	return RAsk(c, prompt)
}

func RespondWithInstructions(model string, instructions string, prompt string) (string, error) {
	c := NewResponse(model)
	c = Instructions(c, instructions)
	return RAsk(c, prompt)
}

func GetResponseText(resp Response) string {
	for _, item := range resp.Output {
		if item.Type == "message" {
			for _, content := range item.Content {
				contentMap, ok := content.(map[string]any)
				if ok {
					contentType, hasType := contentMap["type"]
					if hasType {
						contentTypeStr, isStr := contentType.(string)
						if isStr && (contentTypeStr == "output_text") {
							text, hasText := contentMap["text"]
							if hasText {
								textStr, _ := text.(string)
								return textStr
							}
						}
					}
				}
			}
		}
	}
	return ""
}

func GetFunctionCalls(resp Response) []OutputItem {
	calls := []OutputItem{}
	for _, item := range resp.Output {
		if item.Type == "function_call" {
			calls = append(calls, item)
		}
	}
	return calls
}

func HasFunctionCalls(resp Response) bool {
	calls := GetFunctionCalls(resp)
	return (len(calls) > 0)
}

func rResolveAPIKey(c ResponseClient) string {
	if c.apiKey != "" {
		return c.apiKey
	}
	if c.provider == "openai" {
		return env.GetOr("OPENAI_API_KEY", "")
	}
	if c.provider == "anthropic" {
		return env.GetOr("ANTHROPIC_API_KEY", "")
	}
	if c.provider == "mistral" {
		return env.GetOr("MISTRAL_API_KEY", "")
	}
	if c.provider == "groq" {
		return env.GetOr("GROQ_API_KEY", "")
	}
	if c.provider == "together" {
		return env.GetOr("TOGETHER_API_KEY", "")
	}
	if c.provider == "deepseek" {
		return env.GetOr("DEEPSEEK_API_KEY", "")
	}
	if c.provider == "xai" {
		return env.GetOr("XAI_API_KEY", "")
	}
	return env.GetOr("LLM_API_KEY", "")
}

func rResolveBaseURL(c ResponseClient) string {
	if c.baseURL != "" {
		return c.baseURL
	}
	if c.provider == "openai" {
		return "https://api.openai.com"
	}
	if c.provider == "anthropic" {
		return "https://api.anthropic.com"
	}
	if c.provider == "mistral" {
		return "https://api.mistral.ai"
	}
	if c.provider == "groq" {
		return "https://api.groq.com/openai"
	}
	if c.provider == "together" {
		return "https://api.together.xyz"
	}
	if c.provider == "deepseek" {
		return "https://api.deepseek.com"
	}
	if c.provider == "xai" {
		return "https://api.x.ai"
	}
	if c.provider == "ollama" {
		return "http://localhost:11434"
	}
	return "http://localhost:8000"
}

func rResolvePath(c ResponseClient) string {
	if c.path != "" {
		return c.path
	}
	return "/v1/responses"
}

func rBuildRequest(c ResponseClient) ResponseRequest {
	req := ResponseRequest{}
	req.Model = c.model
	if ((len(c.input) == 1) && (c.input[0].Type == "message")) && (c.input[0].Role == "user") {
		req.Input = c.input
	} else {
		req.Input = c.input
	}
	if c.instructions != "" {
		req.Instructions = c.instructions
	}
	if c.previousResponseID != "" {
		req.PreviousResponseID = c.previousResponseID
	}
	if c.temperature != 0.000000 {
		req.Temperature = c.temperature
	}
	if c.topP != 0.000000 {
		req.TopP = c.topP
	}
	if c.maxOutputTokens != 0 {
		req.MaxOutputTokens = c.maxOutputTokens
	}
	if c.presencePenalty != 0.000000 {
		req.PresencePenalty = c.presencePenalty
	}
	if c.frequencyPenalty != 0.000000 {
		req.FrequencyPenalty = c.frequencyPenalty
	}
	if len(c.tools) > 0 {
		req.Tools = c.tools
	}
	if c.toolChoice != nil {
		req.ToolChoice = c.toolChoice
	}
	if c.store {
		req.Store = true
	}
	if c.truncation != "" {
		req.Truncation = c.truncation
	}
	if len(c.metadata) > 0 {
		req.Metadata = c.metadata
	}
	if c.textFormat != nil {
		req.Text = c.textFormat
	}
	if (c.streamHandler != nil) || (c.eventHandler != nil) {
		req.Stream = true
	}
	return req
}

func rExecute(c ResponseClient) (string, error) {
	if (c.streamHandler != nil) || (c.eventHandler != nil) {
		return rExecuteStream(c)
	}
	resp, err := rExecuteRaw(c)
	if err != nil {
		return "", err
	}
	return GetResponseText(resp), nil
}

func rExecuteRaw(c ResponseClient) (Response, error) {
	baseURL := rResolveBaseURL(c)
	apiKey := rResolveAPIKey(c)
	responsePath := rResolvePath(c)
	url := fmt.Sprintf("%v%v", baseURL, responsePath)
	body := rBuildRequest(c)
	req := fetch.Body(fetch.Header(fetch.Method(fetch.New(url), "POST"), "Content-Type", "application/json"), body)
	if apiKey != "" {
		req = fetch.Header(req, "Authorization", fmt.Sprintf("Bearer %v", apiKey))
	}
	resp, err := fetch.Do(req)
	if err != nil {
		return Response{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, readErr := fetch.Bytes(resp)
		if readErr != nil {
			return Response{}, errors.New(fmt.Sprintf("API request failed with status %v", resp.StatusCode))
		}
		return Response{}, errors.New(fmt.Sprintf("API request failed (%v): %v", resp.StatusCode, string(errBody)))
	}
	result := Response{}
	jsonErr := json.UnmarshalRead(resp.Body, &result)
	if jsonErr != nil {
		return Response{}, jsonErr
	}
	return result, nil
}

func rExecuteStream(c ResponseClient) (string, error) {
	baseURL := rResolveBaseURL(c)
	apiKey := rResolveAPIKey(c)
	responsePath := rResolvePath(c)
	url := fmt.Sprintf("%v%v", baseURL, responsePath)
	body := rBuildRequest(c)
	req := fetch.Body(fetch.Header(fetch.Header(fetch.Method(fetch.New(url), "POST"), "Content-Type", "application/json"), "Accept", "text/event-stream"), body)
	if apiKey != "" {
		req = fetch.Header(req, "Authorization", fmt.Sprintf("Bearer %v", apiKey))
	}
	resp, err := fetch.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, readErr := fetch.Bytes(resp)
		if readErr != nil {
			return "", errors.New(fmt.Sprintf("API request failed with status %v", resp.StatusCode))
		}
		return "", errors.New(fmt.Sprintf("API request failed (%v): %v", resp.StatusCode, string(errBody)))
	}
	fullContent := ""
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		line := scanner.Text()
		if (line == "") || kukistring.HasPrefix(line, ":") {
			continue
		}
		if line == "data: [DONE]" {
			break
		}
		if kukistring.HasPrefix(line, "data: ") {
			data := kukistring.TrimPrefix(line, "data: ")
			evt := StreamEvent{}
			parseErr := json.Unmarshal([]byte(data), &evt)
			if parseErr != nil {
				continue
			}
			if c.eventHandler != nil {
				c.eventHandler(evt)
			}
			if evt.Type == "response.output_text.delta" {
				if evt.Delta != "" {
					fullContent = (fullContent + evt.Delta)
					if c.streamHandler != nil {
						c.streamHandler(evt.Delta)
					}
				}
			}
			if evt.Type == "error" {
				errMsg := evt.Message
				if errMsg == "" {
					errMsg = fmt.Sprintf("streaming error: %v", evt.Code)
				}
				return fullContent, errors.New(errMsg)
			}
		}
	}
	scanErr := scanner.Err()
	if scanErr != nil {
		return fullContent, scanErr
	}
	return fullContent, nil
}

type ContentBlock struct {
	Type      string `json:"type"`
	Text      string `json:"text,omitzero"`
	Thinking  string `json:"thinking,omitzero"`
	ID        string `json:"id,omitzero"`
	Name      string `json:"name,omitzero"`
	Input     any    `json:"input,omitzero"`
	ToolUseID string `json:"tool_use_id,omitzero"`
	Content   any    `json:"content,omitzero"`
	Source    any    `json:"source,omitzero"`
}

type ThinkingConfig struct {
	Type         string `json:"type"`
	BudgetTokens int    `json:"budget_tokens,omitzero"`
}

type OutputConfig struct {
	Format any `json:"format,omitzero"`
}

type AnthropicMessage struct {
	Role    string `json:"role"`
	Content any    `json:"content"`
}

type AnthropicTool struct {
	Name        string `json:"name"`
	Description string `json:"description,omitzero"`
	InputSchema any    `json:"input_schema"`
}

type AnthropicToolChoice struct {
	Type string `json:"type"`
	Name string `json:"name,omitzero"`
}

type AnthropicUsage struct {
	InputTokens              int `json:"input_tokens"`
	OutputTokens             int `json:"output_tokens"`
	CacheCreationInputTokens int `json:"cache_creation_input_tokens,omitzero"`
	CacheReadInputTokens     int `json:"cache_read_input_tokens,omitzero"`
}

type AnthropicResponse struct {
	ID           string         `json:"id"`
	Type         string         `json:"type"`
	Role         string         `json:"role"`
	Content      []ContentBlock `json:"content"`
	Model        string         `json:"model"`
	StopReason   string         `json:"stop_reason"`
	StopSequence string         `json:"stop_sequence,omitzero"`
	Usage        AnthropicUsage `json:"usage"`
}

type MessagesRequest struct {
	Model         string             `json:"model"`
	Messages      []AnthropicMessage `json:"messages"`
	MaxTokens     int                `json:"max_tokens"`
	System        string             `json:"system,omitzero"`
	Temperature   float64            `json:"temperature,omitzero"`
	TopP          float64            `json:"top_p,omitzero"`
	TopK          int                `json:"top_k,omitzero"`
	StopSequences []string           `json:"stop_sequences,omitzero"`
	Stream        bool               `json:"stream,omitzero"`
	Tools         []AnthropicTool    `json:"tools,omitzero"`
	ToolChoice    any                `json:"tool_choice,omitzero"`
	Metadata      any                `json:"metadata,omitzero"`
	Thinking      any                `json:"thinking,omitzero"`
	Effort        string             `json:"effort,omitzero"`
	OutputConfig  any                `json:"output_config,omitzero"`
	InferenceGeo  string             `json:"inference_geo,omitzero"`
}

type AnthropicStreamEvent struct {
	Type         string            `json:"type"`
	Index        int               `json:"index,omitzero"`
	Message      AnthropicResponse `json:"message,omitzero"`
	ContentBlock ContentBlock      `json:"content_block,omitzero"`
	Delta        AnthropicDelta    `json:"delta,omitzero"`
	Usage        AnthropicUsage    `json:"usage,omitzero"`
}

type AnthropicDelta struct {
	Type         string `json:"type,omitzero"`
	Text         string `json:"text,omitzero"`
	Thinking     string `json:"thinking,omitzero"`
	PartialJSON  string `json:"partial_json,omitzero"`
	StopReason   string `json:"stop_reason,omitzero"`
	StopSequence string `json:"stop_sequence,omitzero"`
}

type MessagesClient struct {
	model         string
	baseURL       string
	path          string
	apiKey        string
	apiVersion    string
	system        string
	messages      []AnthropicMessage
	maxTokens     int
	temperature   float64
	topP          float64
	topK          int
	stopSequences []string
	tools         []AnthropicTool
	toolChoice    any
	metadata      any
	thinking      any
	effort        string
	outputConfig  any
	inferenceGeo  string
	streamHandler func(string)
	eventHandler  func(AnthropicStreamEvent)
}

func NewMessages(model string) MessagesClient {
	c := MessagesClient{}
	c.model = model
	c.baseURL = ""
	c.path = ""
	c.apiKey = ""
	c.apiVersion = "2023-06-01"
	c.system = ""
	c.messages = nil
	c.maxTokens = 1024
	c.temperature = 0.000000
	c.topP = 0.000000
	c.topK = 0
	c.stopSequences = nil
	c.tools = nil
	c.toolChoice = nil
	c.metadata = nil
	c.thinking = nil
	c.effort = ""
	c.outputConfig = nil
	c.inferenceGeo = ""
	c.streamHandler = nil
	c.eventHandler = nil
	return c
}

func MBaseURL(c MessagesClient, url string) MessagesClient {
	c.baseURL = url
	return c
}

func MPath(c MessagesClient, path string) MessagesClient {
	c.path = path
	return c
}

func MAPIKey(c MessagesClient, key string) MessagesClient {
	c.apiKey = key
	return c
}

func MAPIVersion(c MessagesClient, version string) MessagesClient {
	c.apiVersion = version
	return c
}

func MSystem(c MessagesClient, system string) MessagesClient {
	c.system = system
	return c
}

func MUser(c MessagesClient, content string) MessagesClient {
	msg := AnthropicMessage{Role: "user", Content: content}
	c.messages = append(c.messages, msg)
	return c
}

func MAssistant(c MessagesClient, content string) MessagesClient {
	msg := AnthropicMessage{Role: "assistant", Content: content}
	c.messages = append(c.messages, msg)
	return c
}

func MAddMessage(c MessagesClient, role string, content any) MessagesClient {
	msg := AnthropicMessage{Role: role, Content: content}
	c.messages = append(c.messages, msg)
	return c
}

func MToolResult(c MessagesClient, toolUseID string, result string) MessagesClient {
	block := ContentBlock{}
	block.Type = "tool_result"
	block.ToolUseID = toolUseID
	block.Content = result
	blocks := []ContentBlock{block}
	msg := AnthropicMessage{Role: "user", Content: blocks}
	c.messages = append(c.messages, msg)
	return c
}

func MMaxTokens(c MessagesClient, max int) MessagesClient {
	c.maxTokens = max
	return c
}

func MTemperature(c MessagesClient, temp float64) MessagesClient {
	c.temperature = temp
	return c
}

func MTopP(c MessagesClient, p float64) MessagesClient {
	c.topP = p
	return c
}

func MTopK(c MessagesClient, k int) MessagesClient {
	c.topK = k
	return c
}

func MStopSequences(c MessagesClient, sequences []string) MessagesClient {
	c.stopSequences = sequences
	return c
}

func MAdaptiveThinking(c MessagesClient) MessagesClient {
	c.thinking = ThinkingConfig{Type: "adaptive"}
	return c
}

func MThinking(c MessagesClient, budgetTokens int) MessagesClient {
	c.thinking = ThinkingConfig{Type: "enabled", BudgetTokens: budgetTokens}
	return c
}

func MEffort(c MessagesClient, effort string) MessagesClient {
	c.effort = effort
	return c
}

func MOutputFormat(c MessagesClient, format any) MessagesClient {
	c.outputConfig = OutputConfig{Format: format}
	return c
}

func MInferenceGeo(c MessagesClient, geo string) MessagesClient {
	c.inferenceGeo = geo
	return c
}

func MAddTool(c MessagesClient, name string, description string, inputSchema any) MessagesClient {
	tool := AnthropicTool{Name: name, Description: description, InputSchema: inputSchema}
	c.tools = append(c.tools, tool)
	return c
}

func MToolChoiceAuto(c MessagesClient) MessagesClient {
	c.toolChoice = AnthropicToolChoice{Type: "auto"}
	return c
}

func MToolChoiceAny(c MessagesClient) MessagesClient {
	c.toolChoice = AnthropicToolChoice{Type: "any"}
	return c
}

func MToolChoiceTool(c MessagesClient, name string) MessagesClient {
	c.toolChoice = AnthropicToolChoice{Type: "tool", Name: name}
	return c
}

func MStream(c MessagesClient, handler func(string)) MessagesClient {
	c.streamHandler = handler
	return c
}

func MStreamEvents(c MessagesClient, handler func(AnthropicStreamEvent)) MessagesClient {
	c.eventHandler = handler
	return c
}

func MAsk(c MessagesClient, prompt string) (string, error) {
	c = MUser(c, prompt)
	return mExecute(c)
}

func MSend(c MessagesClient) (string, error) {
	return mExecute(c)
}

func MAskRaw(c MessagesClient, prompt string) (AnthropicResponse, error) {
	c = MUser(c, prompt)
	return mExecuteRaw(c)
}

func MSendRaw(c MessagesClient) (AnthropicResponse, error) {
	return mExecuteRaw(c)
}

func AnthropicComplete(model string, prompt string) (string, error) {
	c := NewMessages(model)
	return MAsk(c, prompt)
}

func AnthropicCompleteWithSystem(model string, system string, prompt string) (string, error) {
	c := NewMessages(model)
	c = MSystem(c, system)
	return MAsk(c, prompt)
}

func GetAnthropicText(resp AnthropicResponse) string {
	result := ""
	for _, block := range resp.Content {
		if block.Type == "text" {
			result = (result + block.Text)
		}
	}
	return result
}

func GetThinking(resp AnthropicResponse) string {
	result := ""
	for _, block := range resp.Content {
		if block.Type == "thinking" {
			result = (result + block.Thinking)
		}
	}
	return result
}

func GetToolUses(resp AnthropicResponse) []ContentBlock {
	uses := []ContentBlock{}
	for _, block := range resp.Content {
		if block.Type == "tool_use" {
			uses = append(uses, block)
		}
	}
	return uses
}

func HasToolUses(resp AnthropicResponse) bool {
	return (resp.StopReason == "tool_use")
}

func mResolveAPIKey(c MessagesClient) string {
	if c.apiKey != "" {
		return c.apiKey
	}
	return env.GetOr("ANTHROPIC_API_KEY", "")
}

func mResolveBaseURL(c MessagesClient) string {
	if c.baseURL != "" {
		return c.baseURL
	}
	return "https://api.anthropic.com"
}

func mResolvePath(c MessagesClient) string {
	if c.path != "" {
		return c.path
	}
	return "/v1/messages"
}

func mBuildRequest(c MessagesClient) MessagesRequest {
	req := MessagesRequest{}
	req.Model = c.model
	req.Messages = c.messages
	req.MaxTokens = c.maxTokens
	if c.system != "" {
		req.System = c.system
	}
	if c.temperature != 0.000000 {
		req.Temperature = c.temperature
	}
	if c.topP != 0.000000 {
		req.TopP = c.topP
	}
	if c.topK != 0 {
		req.TopK = c.topK
	}
	if len(c.stopSequences) > 0 {
		req.StopSequences = c.stopSequences
	}
	if len(c.tools) > 0 {
		req.Tools = c.tools
	}
	if c.toolChoice != nil {
		req.ToolChoice = c.toolChoice
	}
	if c.metadata != nil {
		req.Metadata = c.metadata
	}
	if c.thinking != nil {
		req.Thinking = c.thinking
	}
	if c.effort != "" {
		req.Effort = c.effort
	}
	if c.outputConfig != nil {
		req.OutputConfig = c.outputConfig
	}
	if c.inferenceGeo != "" {
		req.InferenceGeo = c.inferenceGeo
	}
	if (c.streamHandler != nil) || (c.eventHandler != nil) {
		req.Stream = true
	}
	return req
}

func mExecute(c MessagesClient) (string, error) {
	if (c.streamHandler != nil) || (c.eventHandler != nil) {
		return mExecuteStream(c)
	}
	resp, err := mExecuteRaw(c)
	if err != nil {
		return "", err
	}
	return GetAnthropicText(resp), nil
}

func mExecuteRaw(c MessagesClient) (AnthropicResponse, error) {
	baseURL := mResolveBaseURL(c)
	apiKey := mResolveAPIKey(c)
	msgPath := mResolvePath(c)
	url := fmt.Sprintf("%v%v", baseURL, msgPath)
	body := mBuildRequest(c)
	req := fetch.Header(fetch.Header(fetch.Method(fetch.New(url), "POST"), "Content-Type", "application/json"), "anthropic-version", c.apiVersion)
	if apiKey != "" {
		req = fetch.Header(req, "x-api-key", apiKey)
	}
	req = fetch.Body(req, body)
	resp, err := fetch.Do(req)
	if err != nil {
		return AnthropicResponse{}, err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, readErr := fetch.Bytes(resp)
		if readErr != nil {
			return AnthropicResponse{}, errors.New(fmt.Sprintf("Anthropic API request failed with status %v", resp.StatusCode))
		}
		return AnthropicResponse{}, errors.New(fmt.Sprintf("Anthropic API request failed (%v): %v", resp.StatusCode, string(errBody)))
	}
	result := AnthropicResponse{}
	jsonErr := json.UnmarshalRead(resp.Body, &result)
	if jsonErr != nil {
		return AnthropicResponse{}, jsonErr
	}
	return result, nil
}

func mExecuteStream(c MessagesClient) (string, error) {
	baseURL := mResolveBaseURL(c)
	apiKey := mResolveAPIKey(c)
	msgPath := mResolvePath(c)
	url := fmt.Sprintf("%v%v", baseURL, msgPath)
	body := mBuildRequest(c)
	req := fetch.Header(fetch.Header(fetch.Header(fetch.Method(fetch.New(url), "POST"), "Content-Type", "application/json"), "Accept", "text/event-stream"), "anthropic-version", c.apiVersion)
	if apiKey != "" {
		req = fetch.Header(req, "x-api-key", apiKey)
	}
	req = fetch.Body(req, body)
	resp, err := fetch.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		errBody, readErr := fetch.Bytes(resp)
		if readErr != nil {
			return "", errors.New(fmt.Sprintf("Anthropic API request failed with status %v", resp.StatusCode))
		}
		return "", errors.New(fmt.Sprintf("Anthropic API request failed (%v): %v", resp.StatusCode, string(errBody)))
	}
	fullContent := ""
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		line := scanner.Text()
		if ((line == "") || kukistring.HasPrefix(line, "event:")) || kukistring.HasPrefix(line, ":") {
			continue
		}
		if kukistring.HasPrefix(line, "data: ") {
			data := kukistring.TrimPrefix(line, "data: ")
			evt := AnthropicStreamEvent{}
			parseErr := json.Unmarshal([]byte(data), &evt)
			if parseErr != nil {
				continue
			}
			if c.eventHandler != nil {
				c.eventHandler(evt)
			}
			if evt.Type == "content_block_delta" {
				if (evt.Delta.Type == "text_delta") && (evt.Delta.Text != "") {
					fullContent = (fullContent + evt.Delta.Text)
					if c.streamHandler != nil {
						c.streamHandler(evt.Delta.Text)
					}
				}
			}
			if evt.Type == "error" {
				return fullContent, errors.New("Anthropic streaming error")
			}
		}
	}
	scanErr := scanner.Err()
	if scanErr != nil {
		return fullContent, scanErr
	}
	return fullContent, nil
}
