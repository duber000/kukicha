# Kukicha Standard Library - PG (PostgreSQL Client)
# Provides a pipe-friendly wrapper around pgx/pgxpool for database access.
#
# Examples:
#   # Simple connection â€” always load credentials from the environment, never hardcode them
#   url := env.Get("DATABASE_URL") onerr panic "set DATABASE_URL env var"
#   pool := pg.Connect(url) onerr panic "db: {error}"
#   defer pg.ClosePool(pool)
#
#   # Builder pattern
#   url := env.Get("DATABASE_URL") onerr panic "set DATABASE_URL env var"
#   pool := pg.New(url)
#       |> pg.MaxConns(20)
#       |> pg.MinConns(5)
#       |> pg.Open()
#       onerr panic "db: {error}"
#
#   # Query
#   rows := pg.Query(pool, "SELECT name FROM users WHERE active = $1", true) onerr panic "{error}"
#   defer pg.Close(rows)
#   for pg.Next(rows)
#       name := pg.ScanString(pg.QueryRow(pool, "SELECT name FROM users LIMIT 1")) onerr continue

petiole pg

import "time"
import "stdlib/ctx" as ctxpkg
import "stdlib/errors"
import "stdlib/retry"
import "github.com/jackc/pgx/v5" as pgx
import "github.com/jackc/pgx/v5/pgxpool"
import "github.com/jackc/pgx/v5/pgconn"

# Pool wraps a pgxpool.Pool for connection pooling
type Pool
    pool reference pgxpool.Pool

# Row wraps a single-row query result for scanning
type Row
    scanFn any

# Rows wraps a multi-row query result for iteration
type Rows
    rows any

# Tx wraps a database transaction
type Tx
    tx any

# Result wraps a command tag from INSERT/UPDATE/DELETE
type Result
    tag pgconn.CommandTag

# Config is a builder for pool configuration
type Config
    url string
    maxConns int32
    minConns int32
    maxConnLifetimeNs int64
    maxConnIdleTimeNs int64
    retryMaxAttempts int
    retryDelayMs int

# Connect creates a new connection pool from a URL string.
func Connect(url string) (Pool, error)
    bg := ctxpkg.Background()
    pool, err := pgxpool.New(ctxpkg.Value(bg), url)
    if err != empty
        return Pool{}, errors.Wrap(err, "pg connect")
    return Pool{pool: pool}, empty

# New starts a configuration builder with the given connection URL.
func New(url string) Config
    return Config{url: url}

# MaxConns sets the maximum number of connections in the pool.
func MaxConns(cfg Config, n int32) Config
    cfg.maxConns = n
    return cfg

# MinConns sets the minimum number of idle connections in the pool.
func MinConns(cfg Config, n int32) Config
    cfg.minConns = n
    return cfg

# MaxConnLifetime sets the maximum lifetime of a connection (nanoseconds).
func MaxConnLifetime(cfg Config, d int64) Config
    cfg.maxConnLifetimeNs = d
    return cfg

# MaxConnIdleTime sets the maximum idle time for a connection (nanoseconds).
func MaxConnIdleTime(cfg Config, d int64) Config
    cfg.maxConnIdleTimeNs = d
    return cfg

# Retry configures automatic retry when opening the connection pool fails.
# Useful for startup race conditions where the database isn't ready yet.
# Example: pg.New(url) |> pg.Retry(5, 500) |> pg.Open()
func Retry(cfg Config, maxAttempts int, delayMs int) Config
    cfg.retryMaxAttempts = maxAttempts
    cfg.retryDelayMs = delayMs
    return cfg

# Open creates a connection pool from the builder configuration.
func Open(cfg Config) (Pool, error)
    poolCfg, err := pgxpool.ParseConfig(cfg.url)
    if err != empty
        return Pool{}, errors.Wrap(err, "pg config")
    if cfg.maxConns > 0
        poolCfg.MaxConns = cfg.maxConns
    if cfg.minConns > 0
        poolCfg.MinConns = cfg.minConns
    if cfg.maxConnLifetimeNs > 0
        poolCfg.MaxConnLifetime = time.Duration(cfg.maxConnLifetimeNs)
    if cfg.maxConnIdleTimeNs > 0
        poolCfg.MaxConnIdleTime = time.Duration(cfg.maxConnIdleTimeNs)

    bg := ctxpkg.Background()
    if cfg.retryMaxAttempts <= 1
        pool, openErr := pgxpool.NewWithConfig(ctxpkg.Value(bg), poolCfg)
        if openErr != empty
            return Pool{}, errors.Wrap(openErr, "pg open")
        return Pool{pool: pool}, empty

    delayMs := cfg.retryDelayMs
    if delayMs <= 0
        delayMs = 500
    retryCfg := retry.Config{MaxAttempts: cfg.retryMaxAttempts, InitialDelay: delayMs, Strategy: 1}
    attempt := 0
    lastErr := error "no attempts made"
    for attempt < retryCfg.MaxAttempts
        pool, openErr := pgxpool.NewWithConfig(ctxpkg.Value(bg), poolCfg)
        if openErr == empty
            return Pool{pool: pool}, empty
        lastErr = errors.Wrap(openErr, "pg open")
        retry.Sleep(retryCfg, attempt)
        attempt = attempt + 1
    return Pool{}, lastErr

# Query executes a query that returns multiple rows.
func Query(p Pool, sql string, many args any) (Rows, error)
    bg := ctxpkg.Background()
    rows, err := p.pool.Query(ctxpkg.Value(bg), sql, many args)
    if err != empty
        return Rows{}, errors.Wrap(err, "pg query")
    return Rows{rows: rows}, empty

# QueryRow executes a query that returns at most one row.
func QueryRow(p Pool, sql string, many args any) (Row, error)
    bg := ctxpkg.Background()
    row := p.pool.QueryRow(ctxpkg.Value(bg), sql, many args)
    return Row{scanFn: row}, empty

# Exec executes a query that doesn't return rows (INSERT, UPDATE, DELETE).
func Exec(p Pool, sql string, many args any) (Result, error)
    bg := ctxpkg.Background()
    tag, err := p.pool.Exec(ctxpkg.Value(bg), sql, many args)
    if err != empty
        return Result{}, errors.Wrap(err, "pg exec")
    return Result{tag: tag}, empty

# Scan scans values from a Row into destination pointers.
func Scan(r Row, many dest any) error
    row := r.scanFn.(pgx.Row)
    err := row.Scan(many dest)
    if err != empty
        return errors.Wrap(err, "pg scan")
    return empty

# ScanString scans a single string value from a Row.
func ScanString(r Row) (string, error)
    row := r.scanFn.(pgx.Row)
    v := ""
    err := row.Scan(reference of v)
    if err != empty
        return "", errors.Wrap(err, "pg scan string")
    return v, empty

# ScanInt scans a single int value from a Row.
func ScanInt(r Row) (int, error)
    row := r.scanFn.(pgx.Row)
    v := 0
    err := row.Scan(reference of v)
    if err != empty
        return 0, errors.Wrap(err, "pg scan int")
    return v, empty

# ScanInt64 scans a single int64 value from a Row.
func ScanInt64(r Row) (int64, error)
    row := r.scanFn.(pgx.Row)
    v := 0 as int64
    err := row.Scan(reference of v)
    if err != empty
        return 0, errors.Wrap(err, "pg scan int64")
    return v, empty

# ScanBool scans a single bool value from a Row.
func ScanBool(r Row) (bool, error)
    row := r.scanFn.(pgx.Row)
    v := false
    err := row.Scan(reference of v)
    if err != empty
        return false, errors.Wrap(err, "pg scan bool")
    return v, empty

# ScanFloat64 scans a single float64 value from a Row.
func ScanFloat64(r Row) (float64, error)
    row := r.scanFn.(pgx.Row)
    v := 0.0
    err := row.Scan(reference of v)
    if err != empty
        return 0.0, errors.Wrap(err, "pg scan float64")
    return v, empty

# Next advances the Rows cursor to the next row.
func Next(r Rows) bool
    rows := r.rows.(pgx.Rows)
    return rows.Next()

# ScanRow scans values from the current row in Rows into destination pointers.
func ScanRow(r Rows, many dest any) error
    rows := r.rows.(pgx.Rows)
    err := rows.Scan(many dest)
    if err != empty
        return errors.Wrap(err, "pg scan row")
    return empty

# Close closes the Rows cursor, releasing resources.
func Close(r Rows)
    rows := r.rows.(pgx.Rows)
    rows.Close()

# CollectRows reads all remaining rows into a list of maps.
func CollectRows(r Rows) (list of map of string to any, error)
    rows := r.rows.(pgx.Rows)
    defer rows.Close()
    descs := rows.FieldDescriptions()
    results := make(list of map of string to any, 0)
    for rows.Next()
        values, err := rows.Values()
        if err != empty
            return empty, errors.Wrap(err, "pg collect rows")
        row := make(map of string to any, len(descs))
        for i, desc in descs
            row[desc.Name] = values[i]
        results = append(results, row)
    rowsErr := rows.Err()
    if rowsErr != empty
        return empty, errors.Wrap(rowsErr, "pg collect rows")
    return results, empty

# Begin starts a new transaction.
func Begin(p Pool) (Tx, error)
    bg := ctxpkg.Background()
    tx, err := p.pool.Begin(ctxpkg.Value(bg))
    if err != empty
        return Tx{}, errors.Wrap(err, "pg begin")
    return Tx{tx: tx}, empty

# TxQuery executes a query within a transaction that returns multiple rows.
func TxQuery(t Tx, sql string, many args any) (Rows, error)
    bg := ctxpkg.Background()
    tx := t.tx.(pgx.Tx)
    rows, err := tx.Query(ctxpkg.Value(bg), sql, many args)
    if err != empty
        return Rows{}, errors.Wrap(err, "pg tx query")
    return Rows{rows: rows}, empty

# TxQueryRow executes a query within a transaction that returns at most one row.
func TxQueryRow(t Tx, sql string, many args any) (Row, error)
    bg := ctxpkg.Background()
    tx := t.tx.(pgx.Tx)
    row := tx.QueryRow(ctxpkg.Value(bg), sql, many args)
    return Row{scanFn: row}, empty

# TxExec executes a query within a transaction that doesn't return rows.
func TxExec(t Tx, sql string, many args any) (Result, error)
    bg := ctxpkg.Background()
    tx := t.tx.(pgx.Tx)
    tag, err := tx.Exec(ctxpkg.Value(bg), sql, many args)
    if err != empty
        return Result{}, errors.Wrap(err, "pg tx exec")
    return Result{tag: tag}, empty

# Commit commits the transaction.
func Commit(t Tx) error
    bg := ctxpkg.Background()
    tx := t.tx.(pgx.Tx)
    err := tx.Commit(ctxpkg.Value(bg))
    if err != empty
        return errors.Wrap(err, "pg commit")
    return empty

# Rollback aborts the transaction.
func Rollback(t Tx) error
    bg := ctxpkg.Background()
    tx := t.tx.(pgx.Tx)
    err := tx.Rollback(ctxpkg.Value(bg))
    if err != empty
        return errors.Wrap(err, "pg rollback")
    return empty

# RowsAffected returns the number of rows affected by an INSERT, UPDATE, or DELETE.
func RowsAffected(r Result) int64
    return r.tag.RowsAffected()

# ClosePool closes all connections in the pool.
func ClosePool(p Pool)
    p.pool.Close()
