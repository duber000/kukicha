// Generated by Kukicha v0.0.1 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package datetime

import (
	"errors"
	"time"
)

func Format(t time.Time, format string) string {
	layout := getLayout(format)
	return t.Format(layout)
}

func Parse(value string, format string) (time.Time, error) {
	layout := getLayout(format)
	return time.Parse(layout, value)
}

func ParseInLocation(value string, format string, location string) (time.Time, error) {
	layout := getLayout(format)
	loc, err := time.LoadLocation(location)
	if err != nil {
		return time.Time{}, err
	}
	return time.ParseInLocation(layout, value, loc)
}

func Now() time.Time {
	return time.Now()
}

func Today() time.Time {
	now := time.Now()
	return time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
}

func Tomorrow() time.Time {
	return Today().AddDate(0, 0, 1)
}

func Yesterday() time.Time {
	return Today().AddDate(0, 0, -1)
}

func Nanoseconds(n int64) time.Duration {
	return (n * 1)
}

func Microseconds(n int64) time.Duration {
	return (n * 1000)
}

func Milliseconds(n int64) time.Duration {
	return (n * 1000000)
}

func Seconds(n int64) time.Duration {
	return (n * 1000000000)
}

func Minutes(n int64) time.Duration {
	return (n * 60000000000)
}

func Hours(n int64) time.Duration {
	return (n * 3600000000000)
}

func Days(n int64) time.Duration {
	return (n * 86400000000000)
}

func Weeks(n int64) time.Duration {
	return (n * 604800000000000)
}

func AddDays(t time.Time, days int) time.Time {
	return t.AddDate(0, 0, days)
}

func AddWeeks(t time.Time, weeks int) time.Time {
	return t.AddDate(0, 0, (weeks * 7))
}

func AddMonths(t time.Time, months int) time.Time {
	return t.AddDate(0, months, 0)
}

func AddYears(t time.Time, years int) time.Time {
	return t.AddDate(years, 0, 0)
}

func SubDays(t time.Time, days int) time.Time {
	return t.AddDate(0, 0, -days)
}

func SubWeeks(t time.Time, weeks int) time.Time {
	return t.AddDate(0, 0, (-weeks * 7))
}

func SubMonths(t time.Time, months int) time.Time {
	return t.AddDate(0, -months, 0)
}

func SubYears(t time.Time, years int) time.Time {
	return t.AddDate(-years, 0, 0)
}

func IsBefore(t1 time.Time, t2 time.Time) bool {
	return t1.Before(t2)
}

func IsAfter(t1 time.Time, t2 time.Time) bool {
	return t1.After(t2)
}

func IsBetween(t time.Time, start time.Time, end time.Time) bool {
	atOrAfterStart := t.Equal(start)
	afterStart := t.After(start)
	atOrBeforeEnd := t.Equal(end)
	beforeEnd := t.Before(end)
	return ((atOrAfterStart || afterStart) && (atOrBeforeEnd || beforeEnd))
}

func IsSameDay(t1 time.Time, t2 time.Time) bool {
	y1 := t1.Year()
	m1 := t1.Month()
	d1 := t1.Day()
	y2 := t2.Year()
	m2 := t2.Month()
	d2 := t2.Day()
	return (((y1 == y2) && (m1 == m2)) && (d1 == d2))
}

func IsToday(t time.Time) bool {
	return IsSameDay(t, time.Now())
}

func IsYesterday(t time.Time) bool {
	return IsSameDay(t, Yesterday())
}

func IsTomorrow(t time.Time) bool {
	return IsSameDay(t, Tomorrow())
}

func IsPast(t time.Time) bool {
	return t.Before(time.Now())
}

func IsFuture(t time.Time) bool {
	return t.After(time.Now())
}

func Year(t time.Time) int {
	return t.Year()
}

func Month(t time.Time) int {
	return int(t.Month())
}

func Day(t time.Time) int {
	return t.Day()
}

func Hour(t time.Time) int {
	return t.Hour()
}

func Minute(t time.Time) int {
	return t.Minute()
}

func Second(t time.Time) int {
	return t.Second()
}

func Weekday(t time.Time) int {
	return int(t.Weekday())
}

func WeekdayName(t time.Time) string {
	return t.Weekday().String()
}

func Unix(t time.Time) int64 {
	return t.Unix()
}

func UnixMilli(t time.Time) int64 {
	return t.UnixMilli()
}

func FromUnix(sec int64) time.Time {
	return time.Unix(sec, 0)
}

func FromUnixMilli(msec int64) time.Time {
	return time.UnixMilli(msec)
}

func Sleep(d time.Duration) {
	time.Sleep(d)
}

func SleepSeconds(n int64) {
	time.Sleep((time.Duration(n) * time.Second))
}

func SleepMilliseconds(n int64) {
	time.Sleep((time.Duration(n) * time.Millisecond))
}

func InUTC(t time.Time) time.Time {
	return t.UTC()
}

func InLocal(t time.Time) time.Time {
	return t.Local()
}

func InLocation(t time.Time, location string) (time.Time, error) {
	loc, err := time.LoadLocation(location)
	if err != nil {
		return t, err
	}
	return t.In(loc), nil
}

func getLayout(format string) string {
	if (format == "iso8601") || (format == "ISO8601") {
		return "2006-01-02T15:04:05Z07:00"
	}
	if (format == "rfc3339") || (format == "RFC3339") {
		return time.RFC3339
	}
	if (format == "rfc3339nano") || (format == "RFC3339Nano") {
		return time.RFC3339Nano
	}
	if format == "date" {
		return "2006-01-02"
	}
	if format == "time" {
		return "15:04:05"
	}
	if format == "datetime" {
		return "2006-01-02 15:04:05"
	}
	if format == "dateTimeT" {
		return "2006-01-02T15:04:05"
	}
	if format == "kitchen" {
		return time.Kitchen
	}
	if format == "stamp" {
		return time.Stamp
	}
	if format == "rfc822" {
		return time.RFC822
	}
	if format == "rfc1123" {
		return time.RFC1123
	}
	if format == "ansic" {
		return time.ANSIC
	}
	if format == "unixdate" {
		return time.UnixDate
	}
	return format
}
