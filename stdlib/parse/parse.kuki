# Kukicha Standard Library - Parse (Data Format Parsing)
# Simplified version compatible with current Kukicha compiler limitations

petiole parse

import "encoding/json"
import "encoding/csv"
import "strings"
import "gopkg.in/yaml.v3"

# Json parses a JSON string into a value
# Note: Currently requires Go interop - see package documentation
# Example: Use json.Unmarshal directly in Go code
func Json(data string) (list of byte, error)
    return empty, error "use Go interop - json.Unmarshal requires pointer to result"

# JsonLines parses newline-delimited JSON (NDJSON format)
# Note: Currently requires Go interop - see package documentation
func JsonLines(data string) (list of string, error)
    return empty, error "use Go interop - json.Unmarshal requires pointer to result"

# JsonPretty formats a value as indented JSON bytes
# Example: config |> parse.JsonPretty()
func JsonPretty(value any) (list of byte, error)
    jsonData, err := json.MarshalIndent(value, "", "  ")
    if err != empty
        return empty, err
    return jsonData, err

# Csv parses a CSV string into a list of records
# Each record is a list of strings representing the columns
# Returns the parsed records and any error that occurred
# Example: csvStr |> parse.Csv()
func Csv(data string) (list of list of string, error)
    reader := csv.NewReader(strings.NewReader(data))
    records, err := reader.ReadAll()
    if err != empty
        return empty, err
    return records, empty

# CsvWithHeader parses a CSV string with headers
# Returns a list of maps where keys are column headers
# The first row is treated as the header row
# Returns the parsed records and any error that occurred
# Example: csvStr |> parse.CsvWithHeader()
func CsvWithHeader(data string) (list of map of string to string, error)
    reader := csv.NewReader(strings.NewReader(data))
    records, err := reader.ReadAll()
    if err != empty
        return empty, err

    if len(records) == 0
        return empty, error "no data in CSV"

    headers := records[0]
    result := make(list of map of string to string, 0, len(records)-1)

    # Process each row starting from index 1
    numRecords := len(records)
    i := 1
    for i < numRecords
        row := records[i]
        rowMap := make(map of string to string)

        # Process each column
        numHeaders := len(headers)
        numCols := len(row)
        maxCols := numHeaders
        if numCols < maxCols
            maxCols = numCols

        j := 0
        for j < maxCols
            rowMap[headers[j]] = row[j]
            j = j + 1

        result = append(result, rowMap)
        i = i + 1

    return result, empty

# Yaml parses a YAML string into a value
# Note: Currently requires Go interop - see package documentation
func Yaml(data string) (list of byte, error)
    return empty, error "use Go interop - yaml.Unmarshal requires pointer to result"
