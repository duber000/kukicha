# Kukicha Standard Library - Parse (Data Format Parsing)
# Simplified version compatible with current Kukicha compiler limitations

petiole parse

import "stdlib/json"
import "stdlib/string"
import "encoding/csv"
import "strings"
import "gopkg.in/yaml.v3"

# Json parses a JSON string into a value
# This is a convenience wrapper around json.Unmarshal
# Example: jsonData |> parse.Json() |> json.Unmarshal(reference config)
func Json(data string) (list of byte, error)
    return data as list of byte, empty

# JsonLines parses newline-delimited JSON (NDJSON format)
# Returns a list of JSON strings, one for each line
# Example: ndjsonData |> parse.JsonLines() |> slice.Map(parse.Json) |> slice.Map(parseToType)
func JsonLines(data string) (list of string, error)
    lines := string.Split(data, "\n")
    result := make(list of string, 0, len(lines))
    for line in lines
        line = string.TrimSpace(line)
        if len(line) > 0
            result = append(result, line)
    return result, empty

# JsonPretty formats a value as indented JSON bytes
# Uses encoding/json MarshalIndent for pretty-printing
# Example: config |> parse.JsonPretty()
func JsonPretty(value any) (list of byte, error)
    bytes, err := json.MarshalPretty(value)
    return bytes, err

# Csv parses a CSV string into a list of records
# Each record is a list of strings representing the columns
# Returns the parsed records and any error that occurred
# Example: csvStr |> parse.Csv()
func Csv(data string) (list of list of string, error)
    reader := csv.NewReader(strings.NewReader(data))
    records, err := reader.ReadAll()
    if err != empty
        return empty, err
    return records, empty

# CsvWithHeader parses a CSV string with headers
# Returns a list of maps where keys are column headers
# The first row is treated as the header row
# Returns the parsed records and any error that occurred
# Example: csvStr |> parse.CsvWithHeader()
func CsvWithHeader(data string) (list of map of string to string, error)
    reader := csv.NewReader(strings.NewReader(data))
    records, err := reader.ReadAll()
    if err != empty
        return empty, err

    if len(records) == 0
        return empty, error "no data in CSV"

    headers := records[0]
    result := make(list of map of string to string, 0, len(records)-1)

    # Process each row starting from index 1
    numRecords := len(records)
    i := 1
    for i < numRecords
        row := records[i]
        rowMap := make(map of string to string)

        # Process each column
        numHeaders := len(headers)
        numCols := len(row)
        maxCols := numHeaders
        if numCols < maxCols
            maxCols = numCols

        j := 0
        for j < maxCols
            rowMap[headers[j]] = row[j]
            j = j + 1

        result = append(result, rowMap)
        i = i + 1

    return result, empty

# Yaml parses a YAML string into a value
# Returns the YAML data as bytes for use with yaml.Unmarshal
# Example: yamlData |> parse.Yaml() |> yaml.Unmarshal(reference config)
func Yaml(data string) (list of byte, error)
    return data as list of byte, empty

# YamlPretty formats a value as YAML bytes
# Example: config |> parse.YamlPretty()
func YamlPretty(value any) (list of byte, error)
    yamlData, err := yaml.Marshal(value)
    if err != empty
        return empty, err
    return yamlData, empty
