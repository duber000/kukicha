# Kukicha Standard Library - Parse (Data Format Parsing)

petiole parse

import "encoding/json/v2"
import "encoding/csv"
import "strings"
import "gopkg.in/yaml.v3"
import "io"
import "bytes"

# Json parses a JSON string into a value
# Use type assertion to specify the expected type
# Returns the parsed value and any error that occurred
# Example: jsonStr |> parse.Json() as Config
func Json(data string) (any, error)
    result := any
    err := json.UnmarshalRead(strings.NewReader(data), reference result)
    if err != empty
        return empty, err
    return result, empty

# JsonFromReader parses JSON directly from a reader (streaming, memory efficient)
# Useful for large JSON files or HTTP response bodies
# Example: file |> parse.JsonFromReader() as Config
func JsonFromReader(reader reference io.Reader) (any, error)
    result := any
    err := json.UnmarshalRead(reader, reference result)
    if err != empty
        return empty, err
    return result, empty

# JsonLines parses newline-delimited JSON (NDJSON format)
# Each line is parsed as a separate JSON object
# Example: logData |> parse.JsonLines() as list of LogEntry
func JsonLines(data string) (list of any, error)
    lines := strings.Split(data, "\n")
    results := make(list of any, 0, len(lines))

    for line in lines
        if strings.TrimSpace(line) equals ""
            continue

        item := any
        err := json.UnmarshalRead(strings.NewReader(line), reference item)
        if err != empty
            return empty, err
        results = append(results, item)

    return results, empty

# JsonPretty formats a value as indented JSON string
# Example: config |> parse.JsonPretty()
func JsonPretty(value any) (string, error)
    var buf bytes.Buffer
    err := json.MarshalWrite(reference buf, value, json.Indent("  "))
    if err != empty
        return "", err
    return buf.String(), empty

# Csv parses a CSV string into a list of records
# Each record is a list of strings representing the columns
# Returns the parsed records and any error that occurred
# Example: csvStr |> parse.Csv()
func Csv(data string) (list of list of string, error)
    reader := csv.NewReader(strings.NewReader(data))
    records, err := reader.ReadAll()
    if err != empty
        return empty, err
    return records, empty

# CsvWithHeader parses a CSV string with headers
# Returns a list of maps where keys are column headers
# The first row is treated as the header row
# Returns the parsed records and any error that occurred
# Example: csvStr |> parse.CsvWithHeader()
func CsvWithHeader(data string) (list of map of string to string, error)
    reader := csv.NewReader(strings.NewReader(data))
    records, err := reader.ReadAll()
    if err != empty
        return empty, err

    if len(records) == 0
        return empty, error "no data in CSV"

    headers := records[0]
    result := make(list of map of string to string, 0, len(records)-1)

    for i := 1; i < len(records); i++
        row := records[i]
        rowMap := make(map of string to string)

        for j := 0; j < len(headers) and j < len(row); j++
            rowMap[headers[j]] = row[j]

        result = append(result, rowMap)

    return result, empty

# Yaml parses a YAML string into a value
# Use type assertion to specify the expected type
# Returns the parsed value and any error that occurred
# Example: yamlStr |> parse.Yaml() as Config
func Yaml(data string) (any, error)
    result := any
    err := yaml.Unmarshal(list of byte(data), reference result)
    if err != empty
        return empty, err
    return result, empty
