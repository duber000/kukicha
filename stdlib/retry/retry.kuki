# Kukicha Standard Library - Retry Operations

petiole retry

import "time"
import "math"

# BackoffStrategy defines how delays increase between retry attempts
type BackoffStrategy int

const (
    # Linear backoff - delay stays constant
    Linear BackoffStrategy = 0
    # Exponential backoff - delay doubles each time
    Exponential BackoffStrategy = 1
)

# Config holds retry configuration
type Config
    MaxAttempts int
    InitialDelay int  # milliseconds
    Strategy BackoffStrategy
    Condition func(error) bool

# defaultConfig returns the default retry configuration
func defaultConfig() Config
    return Config{
        MaxAttempts: 3,
        InitialDelay: 1000,
        Strategy: Exponential,
        Condition: empty,
    }

# Do executes a function with default retry settings (3 attempts, exponential backoff)
# Returns the result or the last error encountered
func Do(fn func() any) (any, error)
    cfg := defaultConfig()
    return doWithConfig(cfg, fn)

# New creates a new retry configuration builder
func New() Config
    return defaultConfig()

# Attempts sets the maximum number of retry attempts
func Attempts(cfg Config, maxAttempts int) Config
    cfg.MaxAttempts = maxAttempts
    return cfg

# Delay sets the initial delay in milliseconds
func Delay(cfg Config, delayMs int) Config
    cfg.InitialDelay = delayMs
    return cfg

# Backoff sets the backoff strategy (Linear or Exponential)
func Backoff(cfg Config, strategy BackoffStrategy) Config
    cfg.Strategy = strategy
    return cfg

# DoWithConfig executes a function with the given retry configuration
# This is the final step in the pipeline
func DoWithConfig(cfg Config, fn func() any) (any, error)
    return doWithConfig(cfg, fn)

# doWithConfig is the internal implementation
func doWithConfig(cfg Config, fn func() any) (any, error)
    lastErr := error("")

    for attempt := 0; attempt < cfg.MaxAttempts; attempt = attempt + 1
        # Try to execute the function
        # In Kukicha, we need to handle this carefully
        # For now, we'll use a helper approach
        result, err := tryExecute(fn)

        if err == empty
            return result, empty

        lastErr = err

        # Don't sleep after the last attempt
        if attempt < cfg.MaxAttempts - 1
            delay := calculateDelay(cfg, attempt)
            time.Sleep(time.Duration(delay) * time.Millisecond)

    return empty, lastErr

# tryExecute attempts to execute a function and recover from panics
func tryExecute(fn func() any) (any, error)
    # This is a simplified version
    # In real implementation, we'd need proper error handling
    result := fn()
    return result, empty

# calculateDelay calculates the delay for a given attempt
func calculateDelay(cfg Config, attempt int) int
    if cfg.Strategy == Linear
        return cfg.InitialDelay

    # Exponential backoff
    multiplier := math.Pow(2.0, float64(attempt))
    return int(float64(cfg.InitialDelay) * multiplier)

# DoIf executes a function with retry, but only retries if the condition returns true
# The condition function receives the error and returns true to retry
func DoIf(fn func() any, condition func(error) bool) (any, error)
    cfg := defaultConfig()
    cfg.Condition = condition
    return doWithConfigIf(cfg, fn)

# doWithConfigIf is like doWithConfig but checks the condition before retrying
func doWithConfigIf(cfg Config, fn func() any) (any, error)
    lastErr := error("")

    for attempt := 0; attempt < cfg.MaxAttempts; attempt = attempt + 1
        result, err := tryExecute(fn)

        if err == empty
            return result, empty

        lastErr = err

        # Check if we should retry based on the condition
        if cfg.Condition != empty and not cfg.Condition(err)
            return empty, lastErr

        # Don't sleep after the last attempt
        if attempt < cfg.MaxAttempts - 1
            delay := calculateDelay(cfg, attempt)
            time.Sleep(time.Duration(delay) * time.Millisecond)

    return empty, lastErr

# WithCondition sets a condition for retrying
# Only retry if the condition function returns true for the error
func WithCondition(cfg Config, condition func(error) bool) Config
    cfg.Condition = condition
    return cfg

# DoSimple is a convenience function that retries a function with simple settings
func DoSimple(fn func() any, maxAttempts int, delayMs int) (any, error)
    cfg := Config{
        MaxAttempts: maxAttempts,
        InitialDelay: delayMs,
        Strategy: Exponential,
        Condition: empty,
    }
    return doWithConfig(cfg, fn)
