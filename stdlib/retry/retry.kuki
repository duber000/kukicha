# Kukicha Standard Library - Retry Operations

petiole retry

import "time"

# Note: This package has limited functionality due to current Kukicha limitations:
# - No constants or type aliases
# - Functions passed to retry need to return (any, error) but Kukicha uses onerr
# - Type conversions (float64, int) not supported
#
# This is a simplified stub implementation for now.

# Config holds retry configuration
type Config
    MaxAttempts int
    InitialDelay int  # milliseconds
    Strategy int  # 0 = Linear, 1 = Exponential

# New creates a default retry configuration
func New() Config
    return Config{MaxAttempts: 3, InitialDelay: 1000, Strategy: 1}

# Attempts sets the maximum number of retry attempts
func Attempts(cfg Config, maxAttempts int) Config
    cfg.MaxAttempts = maxAttempts
    return cfg

# Delay sets the initial delay in milliseconds
func Delay(cfg Config, delayMs int) Config
    cfg.InitialDelay = delayMs
    return cfg

# Backoff sets the backoff strategy (0 = Linear, 1 = Exponential)
func Backoff(cfg Config, strategy int) Config
    cfg.Strategy = strategy
    return cfg

# Sleep pauses execution for the configured delay
# This is a helper for manual retry logic
func Sleep(cfg Config, attempt int)
    delay := calculateDelay(cfg, attempt)
    time.Sleep(time.Duration(delay) * time.Millisecond)

# calculateDelay calculates the delay for a given attempt
func calculateDelay(cfg Config, attempt int) int
    if cfg.Strategy == 0
        return cfg.InitialDelay

    # Exponential backoff: calculate 2^attempt using a loop
    multiplier := 1
    i := 0
    for i < attempt
        multiplier = multiplier * 2
        i = i + 1

    return cfg.InitialDelay * multiplier

# Example manual retry pattern:
# cfg := retry.New() |> retry.Attempts(5) |> retry.Delay(500)
# attempt := 0
# for attempt < cfg.MaxAttempts
#     result := doSomething() onerr discard
#     if result != empty
#         # Success!
#         break
#     retry.Sleep(cfg, attempt)
#     attempt = attempt + 1
