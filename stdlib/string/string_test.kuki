# Tests for Kukicha Standard Library - String Package

petiole string_test

import "stdlib/string"
import "stdlib/test"
import "testing"

# Shared case type for single-string transformations
type StringCase
    name  string
    input string
    want  string

# --- TestToUpperToLower ---
func TestToUpperToLower(t reference testing.T)
    upperCases := list of StringCase{
        StringCase{name: "all lower", input: "hello", want: "HELLO"},
        StringCase{name: "mixed", input: "Hello World", want: "HELLO WORLD"},
        StringCase{name: "empty", input: "", want: ""},
    }
    for tc in upperCases
        t.Run("ToUpper/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.ToUpper(tc.input), tc.want)
        )

    lowerCases := list of StringCase{
        StringCase{name: "all upper", input: "HELLO", want: "hello"},
        StringCase{name: "mixed", input: "Hello World", want: "hello world"},
        StringCase{name: "empty", input: "", want: ""},
    }
    for tc in lowerCases
        t.Run("ToLower/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.ToLower(tc.input), tc.want)
        )

# --- TestTrimFunctions ---
type TrimCase
    name   string
    input  string
    cutset string
    want   string

func TestTrimFunctions(t reference testing.T)
    trimCases := list of TrimCase{
        TrimCase{name: "spaces", input: "  hello  ", cutset: " ", want: "hello"},
        TrimCase{name: "x chars", input: "xxhelloxx", cutset: "x", want: "hello"},
    }
    for tc in trimCases
        t.Run("Trim/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.Trim(tc.input, tc.cutset), tc.want)
        )

    trimSpaceCases := list of StringCase{
        StringCase{name: "spaces", input: "  hello  ", want: "hello"},
        StringCase{name: "tabs and newlines", input: "\t hello \n", want: "hello"},
    }
    for tc in trimSpaceCases
        t.Run("TrimSpace/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.TrimSpace(tc.input), tc.want)
        )

    prefixCases := list of TrimCase{
        TrimCase{name: "removes prefix", input: "hello world", cutset: "hello ", want: "world"},
        TrimCase{name: "not present", input: "hello world", cutset: "xyz", want: "hello world"},
        TrimCase{name: "empty prefix", input: "hello world", cutset: "", want: "hello world"},
    }
    for tc in prefixCases
        t.Run("TrimPrefix/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.TrimPrefix(tc.input, tc.cutset), tc.want)
        )

    suffixCases := list of TrimCase{
        TrimCase{name: "removes suffix", input: "hello world", cutset: " world", want: "hello"},
        TrimCase{name: "not present", input: "hello world", cutset: "xyz", want: "hello world"},
    }
    for tc in suffixCases
        t.Run("TrimSuffix/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.TrimSuffix(tc.input, tc.cutset), tc.want)
        )

    t.Run("TrimLeft removes leading x", (t reference testing.T) =>
        test.AssertEqual(t, string.TrimLeft("xxhello", "x"), "hello")
    )
    t.Run("TrimRight removes trailing x", (t reference testing.T) =>
        test.AssertEqual(t, string.TrimRight("helloxx", "x"), "hello")
    )

# --- TestSplitJoin ---
func TestSplitJoin(t reference testing.T)
    t.Run("split on comma", (t reference testing.T) =>
        parts := string.Split("a,b,c", ",")
        test.AssertEqual(t, len(parts), 3)
        test.AssertEqual(t, parts[0], "a")
        test.AssertEqual(t, parts[1], "b")
        test.AssertEqual(t, parts[2], "c")
    )
    t.Run("join with dash", (t reference testing.T) =>
        parts := string.Split("a,b,c", ",")
        test.AssertEqual(t, string.Join(parts, "-"), "a-b-c")
    )
    t.Run("split on empty string", (t reference testing.T) =>
        chars := string.Split("abc", "")
        test.AssertEqual(t, len(chars), 3)
    )
    t.Run("join with empty separator", (t reference testing.T) =>
        chars := string.Split("abc", "")
        test.AssertEqual(t, string.Join(chars, ""), "abc")
    )

# --- TestSplitN ---
func TestSplitN(t reference testing.T)
    t.Run("limit to 2 parts", (t reference testing.T) =>
        parts := string.SplitN("a:b:c:d", ":", 2)
        test.AssertEqual(t, len(parts), 2)
        test.AssertEqual(t, parts[0], "a")
        test.AssertEqual(t, parts[1], "b:c:d")
    )

# --- TestFields ---
func TestFields(t reference testing.T)
    t.Run("splits on whitespace", (t reference testing.T) =>
        parts := string.Fields("  hello   world  ")
        test.AssertEqual(t, len(parts), 2)
        test.AssertEqual(t, parts[0], "hello")
        test.AssertEqual(t, parts[1], "world")
    )
    t.Run("empty string returns empty slice", (t reference testing.T) =>
        none := string.Fields("")
        test.AssertEqual(t, len(none), 0)
    )

# --- TestSearchFunctions ---
func TestSearchFunctions(t reference testing.T)
    s := "hello world"

    containsCases := list of TrimCase{
        TrimCase{name: "world present", input: s, cutset: "world", want: "true"},
        TrimCase{name: "hello present", input: s, cutset: "hello", want: "true"},
        TrimCase{name: "xyz absent", input: s, cutset: "xyz", want: "false"},
        TrimCase{name: "empty always present", input: s, cutset: "", want: "true"},
    }
    for tc in containsCases
        t.Run("Contains/{tc.name}", (t reference testing.T) =>
            got := string.Contains(tc.input, tc.cutset)
            wantBool := tc.want == "true"
            test.AssertEqual(t, got, wantBool)
        )

    t.Run("HasPrefix/hello", (t reference testing.T) =>
        test.AssertEqual(t, string.HasPrefix(s, "hello"), true)
    )
    t.Run("HasPrefix/world false", (t reference testing.T) =>
        test.AssertEqual(t, string.HasPrefix(s, "world"), false)
    )
    t.Run("HasSuffix/world", (t reference testing.T) =>
        test.AssertEqual(t, string.HasSuffix(s, "world"), true)
    )
    t.Run("HasSuffix/hello false", (t reference testing.T) =>
        test.AssertEqual(t, string.HasSuffix(s, "hello"), false)
    )

# --- TestIndexFunctions ---
type IndexCase
    name  string
    input string
    sub   string
    want  int

func TestIndexFunctions(t reference testing.T)
    indexCases := list of IndexCase{
        IndexCase{name: "world at 6", input: "hello world", sub: "world", want: 6},
        IndexCase{name: "hello at 0", input: "hello world", sub: "hello", want: 0},
        IndexCase{name: "xyz not found", input: "hello world", sub: "xyz", want: -1},
    }
    for tc in indexCases
        t.Run("Index/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.Index(tc.input, tc.sub), tc.want)
        )

    lastIndexCases := list of IndexCase{
        IndexCase{name: "last abc at 3", input: "abcabc", sub: "abc", want: 3},
        IndexCase{name: "xyz not found", input: "abcabc", sub: "xyz", want: -1},
    }
    for tc in lastIndexCases
        t.Run("LastIndex/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.LastIndex(tc.input, tc.sub), tc.want)
        )

# --- TestCount ---
type CountCase
    name  string
    input string
    sub   string
    want  int

func TestCount(t reference testing.T)
    cases := list of CountCase{
        CountCase{name: "l appears twice", input: "hello", sub: "l", want: 2},
        CountCase{name: "ll appears once", input: "hello", sub: "ll", want: 1},
        CountCase{name: "x absent", input: "hello", sub: "x", want: 0},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            test.AssertEqual(t, string.Count(tc.input, tc.sub), tc.want)
        )

# --- TestReplaceFunctions ---
func TestReplaceFunctions(t reference testing.T)
    t.Run("ReplaceAll replaces all", (t reference testing.T) =>
        test.AssertEqual(t, string.ReplaceAll("aabbcc", "b", "x"), "aaxxcc")
    )
    t.Run("ReplaceAll no match", (t reference testing.T) =>
        test.AssertEqual(t, string.ReplaceAll("hello", "x", "y"), "hello")
    )
    t.Run("Replace first only", (t reference testing.T) =>
        test.AssertEqual(t, string.Replace("aabbcc", "b", "x", 1), "aaxbcc")
    )
    t.Run("Replace n=-1 replaces all", (t reference testing.T) =>
        test.AssertEqual(t, string.Replace("aabbcc", "b", "x", -1), "aaxxcc")
    )

# --- TestRepeat ---
func TestRepeat(t reference testing.T)
    cases := list of StringCase{
        StringCase{name: "repeat 3 times", input: "ab", want: "ababab"},
        StringCase{name: "repeat 1 time", input: "x", want: "x"},
        StringCase{name: "repeat 0 times", input: "x", want: ""},
    }
    counts := list of int{3, 1, 0}
    for i from 0 to len(cases)
        tc := cases[i]
        n := counts[i]
        t.Run(tc.name, (t reference testing.T) =>
            test.AssertEqual(t, string.Repeat(tc.input, n), tc.want)
        )

# --- TestPadFunctions ---
type PadCase
    name  string
    input string
    width int
    pad   string
    want  string

func TestPadFunctions(t reference testing.T)
    rightCases := list of PadCase{
        PadCase{name: "pad with spaces", input: "hi", width: 5, pad: " ", want: "hi   "},
        PadCase{name: "already long enough", input: "hello", width: 3, pad: " ", want: "hello"},
        PadCase{name: "pad with dash", input: "hi", width: 5, pad: "-", want: "hi---"},
    }
    for tc in rightCases
        t.Run("PadRight/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.PadRight(tc.input, tc.width, tc.pad), tc.want)
        )

    leftCases := list of PadCase{
        PadCase{name: "pad with spaces", input: "hi", width: 5, pad: " ", want: "   hi"},
        PadCase{name: "already long enough", input: "hello", width: 3, pad: " ", want: "hello"},
        PadCase{name: "pad with dash", input: "hi", width: 5, pad: "-", want: "---hi"},
    }
    for tc in leftCases
        t.Run("PadLeft/{tc.name}", (t reference testing.T) =>
            test.AssertEqual(t, string.PadLeft(tc.input, tc.width, tc.pad), tc.want)
        )

# --- TestEqualFold ---
func TestEqualFold(t reference testing.T)
    cases := list of TrimCase{
        TrimCase{name: "same case diff", input: "Hello", cutset: "hello", want: "true"},
        TrimCase{name: "all caps", input: "WORLD", cutset: "world", want: "true"},
        TrimCase{name: "different strings", input: "hello", cutset: "world", want: "false"},
        TrimCase{name: "both empty", input: "", cutset: "", want: "true"},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            got := string.EqualFold(tc.input, tc.cutset)
            wantBool := tc.want == "true"
            test.AssertEqual(t, got, wantBool)
        )

# --- TestLen ---
func TestLen(t reference testing.T)
    cases := list of IndexCase{
        IndexCase{name: "hello is 5", input: "hello", sub: "", want: 5},
        IndexCase{name: "empty is 0", input: "", sub: "", want: 0},
        IndexCase{name: "single char is 1", input: "a", sub: "", want: 1},
    }
    for tc in cases
        t.Run(tc.name, (t reference testing.T) =>
            test.AssertEqual(t, string.Len(tc.input), tc.want)
        )

# --- TestIsEmptyIsBlank ---
func TestIsEmptyIsBlank(t reference testing.T)
    t.Run("IsEmpty/empty string", (t reference testing.T) =>
        test.AssertEqual(t, string.IsEmpty(""), true)
    )
    t.Run("IsEmpty/non-empty", (t reference testing.T) =>
        test.AssertEqual(t, string.IsEmpty("hello"), false)
    )
    t.Run("IsEmpty/space is not empty", (t reference testing.T) =>
        test.AssertEqual(t, string.IsEmpty(" "), false)
    )
    t.Run("IsBlank/empty", (t reference testing.T) =>
        test.AssertEqual(t, string.IsBlank(""), true)
    )
    t.Run("IsBlank/spaces", (t reference testing.T) =>
        test.AssertEqual(t, string.IsBlank("   "), true)
    )
    t.Run("IsBlank/tabs and newlines", (t reference testing.T) =>
        test.AssertEqual(t, string.IsBlank("\t\n"), true)
    )
    t.Run("IsBlank/non-blank", (t reference testing.T) =>
        test.AssertEqual(t, string.IsBlank("hello"), false)
    )
    t.Run("IsBlank/space with char", (t reference testing.T) =>
        test.AssertEqual(t, string.IsBlank(" x "), false)
    )

# --- TestLines ---
func TestLines(t reference testing.T)
    t.Run("three lines", (t reference testing.T) =>
        lines := string.Lines("line1\nline2\nline3")
        test.AssertEqual(t, len(lines), 3)
        test.AssertEqual(t, lines[0], "line1")
        test.AssertEqual(t, lines[2], "line3")
    )
    t.Run("single line no newline", (t reference testing.T) =>
        single := string.Lines("hello")
        test.AssertEqual(t, len(single), 1)
        test.AssertEqual(t, single[0], "hello")
    )

# --- TestConcat ---
func TestConcat(t reference testing.T)
    t.Run("joins parts", (t reference testing.T) =>
        parts := list of string{"hello", " ", "world"}
        test.AssertEqual(t, string.Concat(parts), "hello world")
    )
    t.Run("empty slice", (t reference testing.T) =>
        noParts := list of string{}
        test.AssertEqual(t, string.Concat(noParts), "")
    )
    t.Run("single element", (t reference testing.T) =>
        single := list of string{"alone"}
        test.AssertEqual(t, string.Concat(single), "alone")
    )
