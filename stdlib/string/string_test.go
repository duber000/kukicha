// Generated by Kukicha v0.0.10 (requires Go 1.26+)

package string_test

import (
	"fmt"
	kukistring "github.com/duber000/kukicha/stdlib/string"
	"github.com/duber000/kukicha/stdlib/test"
	"testing"
)

//line /home/user/kukicha/stdlib/string/string_test.kuki:10
type StringCase struct {
	name  string
	input string
	want  string
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:16
func TestToUpperToLower(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:21
	upperCases := []StringCase{StringCase{name: "all lower", input: "hello", want: "HELLO"}, StringCase{name: "mixed", input: "Hello World", want: "HELLO WORLD"}, StringCase{name: "empty", input: "", want: ""}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:22
	for _, tc := range upperCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:23
		t.Run(fmt.Sprintf("ToUpper/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:24
			test.AssertEqual(t, kukistring.ToUpper(tc.input), tc.want)
		})
	}
//line /home/user/kukicha/stdlib/string/string_test.kuki:31
	lowerCases := []StringCase{StringCase{name: "all upper", input: "HELLO", want: "hello"}, StringCase{name: "mixed", input: "Hello World", want: "hello world"}, StringCase{name: "empty", input: "", want: ""}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:32
	for _, tc := range lowerCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:33
		t.Run(fmt.Sprintf("ToLower/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:34
			test.AssertEqual(t, kukistring.ToLower(tc.input), tc.want)
		})
	}
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:38
type TrimCase struct {
	name   string
	input  string
	cutset string
	want   string
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:44
func TestTrimFunctions(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:48
	trimCases := []TrimCase{TrimCase{name: "spaces", input: "  hello  ", cutset: " ", want: "hello"}, TrimCase{name: "x chars", input: "xxhelloxx", cutset: "x", want: "hello"}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:49
	for _, tc := range trimCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:50
		t.Run(fmt.Sprintf("Trim/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:51
			test.AssertEqual(t, kukistring.Trim(tc.input, tc.cutset), tc.want)
		})
	}
//line /home/user/kukicha/stdlib/string/string_test.kuki:57
	trimSpaceCases := []StringCase{StringCase{name: "spaces", input: "  hello  ", want: "hello"}, StringCase{name: "tabs and newlines", input: "\t hello \n", want: "hello"}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:58
	for _, tc := range trimSpaceCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:59
		t.Run(fmt.Sprintf("TrimSpace/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:60
			test.AssertEqual(t, kukistring.TrimSpace(tc.input), tc.want)
		})
	}
//line /home/user/kukicha/stdlib/string/string_test.kuki:67
	prefixCases := []TrimCase{TrimCase{name: "removes prefix", input: "hello world", cutset: "hello ", want: "world"}, TrimCase{name: "not present", input: "hello world", cutset: "xyz", want: "hello world"}, TrimCase{name: "empty prefix", input: "hello world", cutset: "", want: "hello world"}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:68
	for _, tc := range prefixCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:69
		t.Run(fmt.Sprintf("TrimPrefix/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:70
			test.AssertEqual(t, kukistring.TrimPrefix(tc.input, tc.cutset), tc.want)
		})
	}
//line /home/user/kukicha/stdlib/string/string_test.kuki:76
	suffixCases := []TrimCase{TrimCase{name: "removes suffix", input: "hello world", cutset: " world", want: "hello"}, TrimCase{name: "not present", input: "hello world", cutset: "xyz", want: "hello world"}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:77
	for _, tc := range suffixCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:78
		t.Run(fmt.Sprintf("TrimSuffix/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:79
			test.AssertEqual(t, kukistring.TrimSuffix(tc.input, tc.cutset), tc.want)
		})
	}
//line /home/user/kukicha/stdlib/string/string_test.kuki:82
	t.Run("TrimLeft removes leading x", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:83
		test.AssertEqual(t, kukistring.TrimLeft("xxhello", "x"), "hello")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:85
	t.Run("TrimRight removes trailing x", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:86
		test.AssertEqual(t, kukistring.TrimRight("helloxx", "x"), "hello")
	})
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:90
func TestSplitJoin(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:91
	t.Run("split on comma", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:92
		parts := kukistring.Split("a,b,c", ",")
//line /home/user/kukicha/stdlib/string/string_test.kuki:93
		test.AssertEqual(t, len(parts), 3)
//line /home/user/kukicha/stdlib/string/string_test.kuki:94
		test.AssertEqual(t, parts[0], "a")
//line /home/user/kukicha/stdlib/string/string_test.kuki:95
		test.AssertEqual(t, parts[1], "b")
//line /home/user/kukicha/stdlib/string/string_test.kuki:96
		test.AssertEqual(t, parts[2], "c")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:98
	t.Run("join with dash", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:99
		parts := kukistring.Split("a,b,c", ",")
//line /home/user/kukicha/stdlib/string/string_test.kuki:100
		test.AssertEqual(t, kukistring.Join(parts, "-"), "a-b-c")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:102
	t.Run("split on empty string", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:103
		chars := kukistring.Split("abc", "")
//line /home/user/kukicha/stdlib/string/string_test.kuki:104
		test.AssertEqual(t, len(chars), 3)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:106
	t.Run("join with empty separator", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:107
		chars := kukistring.Split("abc", "")
//line /home/user/kukicha/stdlib/string/string_test.kuki:108
		test.AssertEqual(t, kukistring.Join(chars, ""), "abc")
	})
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:112
func TestSplitN(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:113
	t.Run("limit to 2 parts", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:114
		parts := kukistring.SplitN("a:b:c:d", ":", 2)
//line /home/user/kukicha/stdlib/string/string_test.kuki:115
		test.AssertEqual(t, len(parts), 2)
//line /home/user/kukicha/stdlib/string/string_test.kuki:116
		test.AssertEqual(t, parts[0], "a")
//line /home/user/kukicha/stdlib/string/string_test.kuki:117
		test.AssertEqual(t, parts[1], "b:c:d")
	})
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:121
func TestFields(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:122
	t.Run("splits on whitespace", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:123
		parts := kukistring.Fields("  hello   world  ")
//line /home/user/kukicha/stdlib/string/string_test.kuki:124
		test.AssertEqual(t, len(parts), 2)
//line /home/user/kukicha/stdlib/string/string_test.kuki:125
		test.AssertEqual(t, parts[0], "hello")
//line /home/user/kukicha/stdlib/string/string_test.kuki:126
		test.AssertEqual(t, parts[1], "world")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:128
	t.Run("empty string returns empty slice", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:129
		none := kukistring.Fields("")
//line /home/user/kukicha/stdlib/string/string_test.kuki:130
		test.AssertEqual(t, len(none), 0)
	})
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:134
func TestSearchFunctions(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:135
	s := "hello world"
//line /home/user/kukicha/stdlib/string/string_test.kuki:142
	containsCases := []TrimCase{TrimCase{name: "world present", input: s, cutset: "world", want: "true"}, TrimCase{name: "hello present", input: s, cutset: "hello", want: "true"}, TrimCase{name: "xyz absent", input: s, cutset: "xyz", want: "false"}, TrimCase{name: "empty always present", input: s, cutset: "", want: "true"}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:143
	for _, tc := range containsCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:144
		t.Run(fmt.Sprintf("Contains/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:145
			got := kukistring.Contains(tc.input, tc.cutset)
//line /home/user/kukicha/stdlib/string/string_test.kuki:146
			wantBool := (tc.want == "true")
//line /home/user/kukicha/stdlib/string/string_test.kuki:147
			test.AssertEqual(t, got, wantBool)
		})
	}
//line /home/user/kukicha/stdlib/string/string_test.kuki:150
	t.Run("HasPrefix/hello", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:151
		test.AssertEqual(t, kukistring.HasPrefix(s, "hello"), true)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:153
	t.Run("HasPrefix/world false", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:154
		test.AssertEqual(t, kukistring.HasPrefix(s, "world"), false)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:156
	t.Run("HasSuffix/world", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:157
		test.AssertEqual(t, kukistring.HasSuffix(s, "world"), true)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:159
	t.Run("HasSuffix/hello false", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:160
		test.AssertEqual(t, kukistring.HasSuffix(s, "hello"), false)
	})
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:164
type IndexCase struct {
	name  string
	input string
	sub   string
	want  int
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:170
func TestIndexFunctions(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:175
	indexCases := []IndexCase{IndexCase{name: "world at 6", input: "hello world", sub: "world", want: 6}, IndexCase{name: "hello at 0", input: "hello world", sub: "hello", want: 0}, IndexCase{name: "xyz not found", input: "hello world", sub: "xyz", want: -1}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:176
	for _, tc := range indexCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:177
		t.Run(fmt.Sprintf("Index/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:178
			test.AssertEqual(t, kukistring.Index(tc.input, tc.sub), tc.want)
		})
	}
//line /home/user/kukicha/stdlib/string/string_test.kuki:184
	lastIndexCases := []IndexCase{IndexCase{name: "last abc at 3", input: "abcabc", sub: "abc", want: 3}, IndexCase{name: "xyz not found", input: "abcabc", sub: "xyz", want: -1}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:185
	for _, tc := range lastIndexCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:186
		t.Run(fmt.Sprintf("LastIndex/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:187
			test.AssertEqual(t, kukistring.LastIndex(tc.input, tc.sub), tc.want)
		})
	}
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:191
type CountCase struct {
	name  string
	input string
	sub   string
	want  int
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:197
func TestCount(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:202
	cases := []CountCase{CountCase{name: "l appears twice", input: "hello", sub: "l", want: 2}, CountCase{name: "ll appears once", input: "hello", sub: "ll", want: 1}, CountCase{name: "x absent", input: "hello", sub: "x", want: 0}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:203
	for _, tc := range cases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:204
		t.Run(tc.name, func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:205
			test.AssertEqual(t, kukistring.Count(tc.input, tc.sub), tc.want)
		})
	}
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:209
func TestReplaceFunctions(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:210
	t.Run("ReplaceAll replaces all", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:211
		test.AssertEqual(t, kukistring.ReplaceAll("aabbcc", "b", "x"), "aaxxcc")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:213
	t.Run("ReplaceAll no match", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:214
		test.AssertEqual(t, kukistring.ReplaceAll("hello", "x", "y"), "hello")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:216
	t.Run("Replace first only", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:217
		test.AssertEqual(t, kukistring.Replace("aabbcc", "b", "x", 1), "aaxbcc")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:219
	t.Run("Replace n=-1 replaces all", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:220
		test.AssertEqual(t, kukistring.Replace("aabbcc", "b", "x", -1), "aaxxcc")
	})
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:224
func TestRepeat(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:229
	cases := []StringCase{StringCase{name: "repeat 3 times", input: "ab", want: "ababab"}, StringCase{name: "repeat 1 time", input: "x", want: "x"}, StringCase{name: "repeat 0 times", input: "x", want: ""}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:230
	counts := []int{3, 1, 0}
//line /home/user/kukicha/stdlib/string/string_test.kuki:231
	for i := range len(cases) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:232
		tc := cases[i]
//line /home/user/kukicha/stdlib/string/string_test.kuki:233
		n := counts[i]
//line /home/user/kukicha/stdlib/string/string_test.kuki:234
		t.Run(tc.name, func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:235
			test.AssertEqual(t, kukistring.Repeat(tc.input, n), tc.want)
		})
	}
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:239
type PadCase struct {
	name  string
	input string
	width int
	pad   string
	want  string
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:246
func TestPadFunctions(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:251
	rightCases := []PadCase{PadCase{name: "pad with spaces", input: "hi", width: 5, pad: " ", want: "hi   "}, PadCase{name: "already long enough", input: "hello", width: 3, pad: " ", want: "hello"}, PadCase{name: "pad with dash", input: "hi", width: 5, pad: "-", want: "hi---"}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:252
	for _, tc := range rightCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:253
		t.Run(fmt.Sprintf("PadRight/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:254
			test.AssertEqual(t, kukistring.PadRight(tc.input, tc.width, tc.pad), tc.want)
		})
	}
//line /home/user/kukicha/stdlib/string/string_test.kuki:261
	leftCases := []PadCase{PadCase{name: "pad with spaces", input: "hi", width: 5, pad: " ", want: "   hi"}, PadCase{name: "already long enough", input: "hello", width: 3, pad: " ", want: "hello"}, PadCase{name: "pad with dash", input: "hi", width: 5, pad: "-", want: "---hi"}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:262
	for _, tc := range leftCases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:263
		t.Run(fmt.Sprintf("PadLeft/%v", tc.name), func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:264
			test.AssertEqual(t, kukistring.PadLeft(tc.input, tc.width, tc.pad), tc.want)
		})
	}
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:268
func TestEqualFold(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:274
	cases := []TrimCase{TrimCase{name: "same case diff", input: "Hello", cutset: "hello", want: "true"}, TrimCase{name: "all caps", input: "WORLD", cutset: "world", want: "true"}, TrimCase{name: "different strings", input: "hello", cutset: "world", want: "false"}, TrimCase{name: "both empty", input: "", cutset: "", want: "true"}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:275
	for _, tc := range cases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:276
		t.Run(tc.name, func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:277
			got := kukistring.EqualFold(tc.input, tc.cutset)
//line /home/user/kukicha/stdlib/string/string_test.kuki:278
			wantBool := (tc.want == "true")
//line /home/user/kukicha/stdlib/string/string_test.kuki:279
			test.AssertEqual(t, got, wantBool)
		})
	}
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:283
func TestLen(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:288
	cases := []IndexCase{IndexCase{name: "hello is 5", input: "hello", sub: "", want: 5}, IndexCase{name: "empty is 0", input: "", sub: "", want: 0}, IndexCase{name: "single char is 1", input: "a", sub: "", want: 1}}
//line /home/user/kukicha/stdlib/string/string_test.kuki:289
	for _, tc := range cases {
//line /home/user/kukicha/stdlib/string/string_test.kuki:290
		t.Run(tc.name, func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:291
			test.AssertEqual(t, kukistring.Len(tc.input), tc.want)
		})
	}
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:295
func TestIsEmptyIsBlank(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:296
	t.Run("IsEmpty/empty string", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:297
		test.AssertEqual(t, kukistring.IsEmpty(""), true)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:299
	t.Run("IsEmpty/non-empty", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:300
		test.AssertEqual(t, kukistring.IsEmpty("hello"), false)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:302
	t.Run("IsEmpty/space is not empty", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:303
		test.AssertEqual(t, kukistring.IsEmpty(" "), false)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:305
	t.Run("IsBlank/empty", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:306
		test.AssertEqual(t, kukistring.IsBlank(""), true)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:308
	t.Run("IsBlank/spaces", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:309
		test.AssertEqual(t, kukistring.IsBlank("   "), true)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:311
	t.Run("IsBlank/tabs and newlines", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:312
		test.AssertEqual(t, kukistring.IsBlank("\t\n"), true)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:314
	t.Run("IsBlank/non-blank", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:315
		test.AssertEqual(t, kukistring.IsBlank("hello"), false)
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:317
	t.Run("IsBlank/space with char", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:318
		test.AssertEqual(t, kukistring.IsBlank(" x "), false)
	})
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:322
func TestLines(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:323
	t.Run("three lines", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:324
		lines := kukistring.Lines("line1\nline2\nline3")
//line /home/user/kukicha/stdlib/string/string_test.kuki:325
		test.AssertEqual(t, len(lines), 3)
//line /home/user/kukicha/stdlib/string/string_test.kuki:326
		test.AssertEqual(t, lines[0], "line1")
//line /home/user/kukicha/stdlib/string/string_test.kuki:327
		test.AssertEqual(t, lines[2], "line3")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:329
	t.Run("single line no newline", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:330
		single := kukistring.Lines("hello")
//line /home/user/kukicha/stdlib/string/string_test.kuki:331
		test.AssertEqual(t, len(single), 1)
//line /home/user/kukicha/stdlib/string/string_test.kuki:332
		test.AssertEqual(t, single[0], "hello")
	})
}

//line /home/user/kukicha/stdlib/string/string_test.kuki:336
func TestConcat(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:337
	t.Run("joins parts", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:338
		parts := []string{"hello", " ", "world"}
//line /home/user/kukicha/stdlib/string/string_test.kuki:339
		test.AssertEqual(t, kukistring.Concat(parts), "hello world")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:341
	t.Run("empty slice", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:342
		noParts := []string{}
//line /home/user/kukicha/stdlib/string/string_test.kuki:343
		test.AssertEqual(t, kukistring.Concat(noParts), "")
	})
//line /home/user/kukicha/stdlib/string/string_test.kuki:345
	t.Run("single element", func(t *testing.T) {
//line /home/user/kukicha/stdlib/string/string_test.kuki:346
		single := []string{"alone"}
//line /home/user/kukicha/stdlib/string/string_test.kuki:347
		test.AssertEqual(t, kukistring.Concat(single), "alone")
	})
}
