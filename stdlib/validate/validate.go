// Generated by Kukicha v0.0.1 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package validate

import (
	"errors"
	"fmt"
	"net/url"
	"regexp"
	"strconv"
	"strings"
	"unicode"
)

func NotEmpty(s string) (string, error) {
	if strings.TrimSpace(s) == "" {
		return "", errors.New("value cannot be empty")
	}
	return s, nil
}

func MinLength(s string, n int) (string, error) {
	if len(s) < n {
		return s, errors.New(fmt.Sprintf("value must be at least %v characters", n))
	}
	return s, nil
}

func MaxLength(s string, n int) (string, error) {
	if len(s) > n {
		return s, errors.New(fmt.Sprintf("value must be at most %v characters", n))
	}
	return s, nil
}

func Length(s string, n int) (string, error) {
	if len(s) != n {
		return s, errors.New(fmt.Sprintf("value must be exactly %v characters", n))
	}
	return s, nil
}

func LengthBetween(s string, min int, max int) (string, error) {
	length := len(s)
	if (length < min) || (length > max) {
		return s, errors.New(fmt.Sprintf("value must be between %v and %v characters", min, max))
	}
	return s, nil
}

func Matches(s string, pattern string) (string, error) {
	matched, err := regexp.MatchString(pattern, s)
	if err != nil {
		return s, errors.New(fmt.Sprintf("invalid pattern: %v", err))
	}
	if !matched {
		return s, errors.New("value does not match required pattern")
	}
	return s, nil
}

func Email(s string) (string, error) {
	pattern := fmt.Sprintf("^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]%v$", 2)
	matched, _ := regexp.MatchString(pattern, s)
	if !matched {
		return s, errors.New("invalid email address")
	}
	return s, nil
}

func URL(s string) (string, error) {
	parsed, err := url.Parse(s)
	if err != nil {
		return s, errors.New(fmt.Sprintf("invalid URL: %v", err))
	}
	if (parsed.Scheme == "") || (parsed.Host == "") {
		return s, errors.New("URL must have scheme and host")
	}
	return s, nil
}

func Alpha(s string) (string, error) {
	for _, r := range s {
		if !unicode.IsLetter(r) {
			return s, errors.New("value must contain only letters")
		}
	}
	return s, nil
}

func Alphanumeric(s string) (string, error) {
	for _, r := range s {
		if !unicode.IsLetter(r) && !unicode.IsDigit(r) {
			return s, errors.New("value must contain only letters and numbers")
		}
	}
	return s, nil
}

func Numeric(s string) (string, error) {
	for _, r := range s {
		if !unicode.IsDigit(r) {
			return s, errors.New("value must contain only digits")
		}
	}
	return s, nil
}

func NoWhitespace(s string) (string, error) {
	for _, r := range s {
		if unicode.IsSpace(r) {
			return s, errors.New("value cannot contain whitespace")
		}
	}
	return s, nil
}

func StartsWith(s string, prefix string) (string, error) {
	if !strings.HasPrefix(s, prefix) {
		return s, errors.New(fmt.Sprintf("value must start with '%v'", prefix))
	}
	return s, nil
}

func EndsWith(s string, suffix string) (string, error) {
	if !strings.HasSuffix(s, suffix) {
		return s, errors.New(fmt.Sprintf("value must end with '%v'", suffix))
	}
	return s, nil
}

func Contains(s string, substr string) (string, error) {
	if !strings.Contains(s, substr) {
		return s, errors.New(fmt.Sprintf("value must contain '%v'", substr))
	}
	return s, nil
}

func OneOf(s string, allowed ...string) (string, error) {
	for _, a := range allowed {
		if s == a {
			return s, nil
		}
	}
	return s, errors.New("value must be one of the allowed options")
}

func Positive(n int) (int, error) {
	if n <= 0 {
		return n, errors.New("value must be positive")
	}
	return n, nil
}

func Negative(n int) (int, error) {
	if n >= 0 {
		return n, errors.New("value must be negative")
	}
	return n, nil
}

func NonNegative(n int) (int, error) {
	if n < 0 {
		return n, errors.New("value cannot be negative")
	}
	return n, nil
}

func NonZero(n int) (int, error) {
	if n == 0 {
		return n, errors.New("value cannot be zero")
	}
	return n, nil
}

func InRange(n int, min int, max int) (int, error) {
	if (n < min) || (n > max) {
		return n, errors.New(fmt.Sprintf("value must be between %v and %v", min, max))
	}
	return n, nil
}

func Min(n int, min int) (int, error) {
	if n < min {
		return n, errors.New(fmt.Sprintf("value must be at least %v", min))
	}
	return n, nil
}

func Max(n int, max int) (int, error) {
	if n > max {
		return n, errors.New(fmt.Sprintf("value must be at most %v", max))
	}
	return n, nil
}

func PositiveFloat(n float64) (float64, error) {
	if n <= 0.000000 {
		return n, errors.New("value must be positive")
	}
	return n, nil
}

func InRangeFloat(n float64, min float64, max float64) (float64, error) {
	if (n < min) || (n > max) {
		return n, errors.New(fmt.Sprintf("value must be between %v and %v", min, max))
	}
	return n, nil
}

func ParseInt(s string) (int, error) {
	n, err := strconv.Atoi(s)
	if err != nil {
		return 0, errors.New(fmt.Sprintf("invalid integer: %v", s))
	}
	return n, nil
}

func ParsePositiveInt(s string) (int, error) {
	n, err := strconv.Atoi(s)
	if err != nil {
		return 0, errors.New(fmt.Sprintf("invalid integer: %v", s))
	}
	if n <= 0 {
		return n, errors.New("value must be positive")
	}
	return n, nil
}

func ParseFloat(s string) (float64, error) {
	n, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return 0.000000, errors.New(fmt.Sprintf("invalid number: %v", s))
	}
	return n, nil
}

func ParseBool(s string) (bool, error) {
	lower := strings.ToLower(strings.TrimSpace(s))
	if ((lower == "true") || (lower == "1")) || (lower == "yes") {
		return true, nil
	}
	if ((lower == "false") || (lower == "0")) || (lower == "no") {
		return false, nil
	}
	return false, errors.New(fmt.Sprintf("invalid boolean: %v", s))
}

func NotEmptyList(items []any) ([]any, error) {
	if len(items) == 0 {
		return items, errors.New("list cannot be empty")
	}
	return items, nil
}

func ListMinLength(items []any, n int) ([]any, error) {
	if len(items) < n {
		return items, errors.New(fmt.Sprintf("list must have at least %v elements", n))
	}
	return items, nil
}

func ListMaxLength(items []any, n int) ([]any, error) {
	if len(items) > n {
		return items, errors.New(fmt.Sprintf("list must have at most %v elements", n))
	}
	return items, nil
}

func WithMessage(value string, err error, message string) (string, error) {
	if err != nil {
		return value, errors.New(message)
	}
	return value, nil
}

func Require(s string, fieldName string) (string, error) {
	if strings.TrimSpace(s) == "" {
		return "", errors.New(fmt.Sprintf("%v is required", fieldName))
	}
	return s, nil
}
