// Generated by Kukicha v1.0.0 (requires Go 1.25+)
//
// Performance options:
//   GOEXPERIMENT=greenteagc  - Green Tea GC (10-40% faster, default in Go 1.26)
//   GOEXPERIMENT=jsonv2      - Faster JSON parsing (2-10x improvement)

package iter

import "iter"

func Filter[T any](seq iter.Seq[T], keep func(T) bool) iter.Seq[T] {
	return func(yield func(T) bool) bool {
		for _, item := range seq {
			if keep(item) {
				if !yield(item) {
					return false
				}
			}
		}
		return true
	}
}

func Map[T any, U any](seq iter.Seq[T], transform func(T) U) iter.Seq[U] {
	return func(yield func(U) bool) bool {
		for _, item := range seq {
			if !yield(transform(item)) {
				return false
			}
		}
		return true
	}
}

func FlatMap[T any](seq iter.Seq[T], transform func(T) iter.Seq[T]) iter.Seq[T] {
	return func(yield func(T) bool) bool {
		for _, item := range seq {
			for _, subItem := range transform(item) {
				if !yield(subItem) {
					return false
				}
			}
		}
		return true
	}
}

func Take[T any](seq iter.Seq[T], n int) iter.Seq[T] {
	return func(yield func(T) bool) bool {
		count := 0
		for _, item := range seq {
			if count >= n {
				return true
			}
			if !yield(item) {
				return false
			}
			count++
		}
		return true
	}
}

func Skip[T any](seq iter.Seq[T], n int) iter.Seq[T] {
	return func(yield func(T) bool) bool {
		count := 0
		for _, item := range seq {
			if count >= n {
				if !yield(item) {
					return false
				}
			}
			count++
		}
		return true
	}
}

func Enumerate[T any](seq iter.Seq[T]) iter.Seq2[int, T] {
	return func(yield func(int, T) bool) bool {
		i := 0
		for _, item := range seq {
			if !yield(i, item) {
				return false
			}
			i++
		}
		return true
	}
}

func Chunk[T any](seq iter.Seq[T], n int) iter.Seq[[]T] {
	return func(yield func([]T) bool) bool {
		chunk := make([]T, 0)
		for _, item := range seq {
			chunk = append(chunk, item)
			if len(chunk) == n {
				if !yield(chunk) {
					return false
				}
				chunk = make([]T, 0)
			}
		}
		if len(chunk) > 0 {
			return yield(chunk)
		}
		return true
	}
}

func Zip[T any](seq1 iter.Seq[T], seq2 iter.Seq[T]) iter.Seq2[T, T] {
	return func(yield func(T, T) bool) bool {
		done := false
		for _, v1 := range seq1 {
			if done {
				return true
			}
			v2Exists := false
			v2 := *new(T)
			for _, v2Candidate := range seq2 {
				v2 = v2Candidate
				v2Exists = true
				break
			}
			if !v2Exists {
				done = true
			} else if !yield(v1, v2) {
				return false
			}
		}
		return true
	}
}

func Reduce[T any](seq iter.Seq[T], initial T, reducer func(T, T) T) T {
	acc := initial
	for _, item := range seq {
		acc = reducer(acc, item)
	}
	return acc
}

func Collect[T any](seq iter.Seq[T]) []T {
	result := make([]T, 0)
	for _, item := range seq {
		result = append(result, item)
	}
	return result
}

func Any[T any](seq iter.Seq[T], predicate func(T) bool) bool {
	for _, item := range seq {
		if predicate(item) {
			return true
		}
	}
	return false
}

func All[T any](seq iter.Seq[T], predicate func(T) bool) bool {
	for _, item := range seq {
		if !predicate(item) {
			return false
		}
	}
	return true
}

func Find[T any](seq iter.Seq[T], predicate func(T) bool) (T, bool) {
	for _, item := range seq {
		if predicate(item) {
			return item, true
		}
	}
	return *new(T), false
}
